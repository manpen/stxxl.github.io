<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Stxxl: priority_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
<h1>priority_queue.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef PRIORITY_QUEUE_HEADER</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define PRIORITY_QUEUE_HEADER</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/***************************************************************************</span>
<a name="l00005"></a>00005 <span class="comment"> *            priority_queue.h</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> *  Thu Jul  3 15:22:50 2003</span>
<a name="l00008"></a>00008 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
<a name="l00009"></a>00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
<a name="l00010"></a>00010 <span class="comment"> ****************************************************************************/</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include "stxxl/bits/mng/mng.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "stxxl/bits/mng/prefetch_pool.h"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "stxxl/bits/mng/write_pool.h"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "stxxl/bits/common/tmeta.h"</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 __STXXL_BEGIN_NAMESPACE
<a name="l00023"></a>00023 
<a name="l00027"></a>00027 
<a name="l00030"></a><a class="code" href="namespacepriority__queue__local.html">00030</a> <span class="keyword">namespace </span>priority_queue_local
<a name="l00031"></a>00031 {
<a name="l00033"></a>00033 <span class="comment">// auxiliary functions</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">// merge sz element from the two sentinel terminated input</span>
<a name="l00036"></a>00036 <span class="comment">// sequences *f0 and *f1 to "to"</span>
<a name="l00037"></a>00037 <span class="comment">// advance *fo and *f1 accordingly.</span>
<a name="l00038"></a>00038 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1</span>
<a name="l00039"></a>00039 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00040"></a>00040 <span class="comment">//   *fx + sz is before the end of fx</span>
<a name="l00041"></a>00041     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_, <span class="keyword">class</span> Cmp_&gt;
<a name="l00042"></a>00042     <span class="keywordtype">void</span> merge(Value_ * * f0,
<a name="l00043"></a>00043                Value_ * * f1,
<a name="l00044"></a>00044                Value_ * to, int_type sz, Cmp_ cmp)
<a name="l00045"></a>00045     {
<a name="l00046"></a>00046         Value_ * from0   = *f0;
<a name="l00047"></a>00047         Value_ * from1   = *f1;
<a name="l00048"></a>00048         Value_ * done    = to + sz;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="keywordflow">while</span> (to != done)
<a name="l00051"></a>00051         {
<a name="l00052"></a>00052             <span class="keywordflow">if</span> (cmp(*from0, *from1))
<a name="l00053"></a>00053             {
<a name="l00054"></a>00054                 *to = *from1;
<a name="l00055"></a>00055                 ++from1;
<a name="l00056"></a>00056             }
<a name="l00057"></a>00057             <span class="keywordflow">else</span>
<a name="l00058"></a>00058             {
<a name="l00059"></a>00059                 *to = *from0;
<a name="l00060"></a>00060                 ++from0;
<a name="l00061"></a>00061             }
<a name="l00062"></a>00062             ++to;
<a name="l00063"></a>00063         }
<a name="l00064"></a>00064         *f0   = from0;
<a name="l00065"></a>00065         *f1   = from1;
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">// iterator version</span>
<a name="l00069"></a>00069     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Cmp_&gt;
<a name="l00070"></a>00070     <span class="keywordtype">void</span> merge_iterator(
<a name="l00071"></a>00071         InputIterator &amp; from0,
<a name="l00072"></a>00072         InputIterator &amp; from1,
<a name="l00073"></a>00073         OutputIterator to, int_type sz, Cmp_ cmp)
<a name="l00074"></a>00074     {
<a name="l00075"></a>00075         OutputIterator done = to + sz;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         <span class="keywordflow">while</span> (to != done)
<a name="l00078"></a>00078         {
<a name="l00079"></a>00079             <span class="keywordflow">if</span> (cmp(*from0, *from1))
<a name="l00080"></a>00080             {
<a name="l00081"></a>00081                 *to = *from1;
<a name="l00082"></a>00082                 ++from1;
<a name="l00083"></a>00083             }
<a name="l00084"></a>00084             <span class="keywordflow">else</span>
<a name="l00085"></a>00085             {
<a name="l00086"></a>00086                 *to = *from0;
<a name="l00087"></a>00087                 ++from0;
<a name="l00088"></a>00088             }
<a name="l00089"></a>00089             ++to;
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">// merge sz element from the three sentinel terminated input</span>
<a name="l00096"></a>00096 <span class="comment">// sequences *f0, *f1 and *f2 to "to"</span>
<a name="l00097"></a>00097 <span class="comment">// advance *f0, *f1 and *f2 accordingly.</span>
<a name="l00098"></a>00098 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1 and f2</span>
<a name="l00099"></a>00099 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00100"></a>00100 <span class="comment">//   *fx + sz is before the end of fx</span>
<a name="l00101"></a>00101     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_, <span class="keyword">class</span> Cmp_&gt;
<a name="l00102"></a>00102     <span class="keywordtype">void</span> merge3(
<a name="l00103"></a>00103         Value_ * * f0,
<a name="l00104"></a>00104         Value_ * * f1,
<a name="l00105"></a>00105         Value_ * * f2,
<a name="l00106"></a>00106         Value_ * to, int_type sz, Cmp_ cmp)
<a name="l00107"></a>00107     {
<a name="l00108"></a>00108         Value_ * from0   = *f0;
<a name="l00109"></a>00109         Value_ * from1   = *f1;
<a name="l00110"></a>00110         Value_ * from2   = *f2;
<a name="l00111"></a>00111         Value_ * done    = to + sz;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="keywordflow">if</span> (cmp(*from1, *from0)) {
<a name="l00114"></a>00114             <span class="keywordflow">if</span> (cmp(*from2, *from1)) {
<a name="l00115"></a>00115                 <span class="keywordflow">goto</span> s012;
<a name="l00116"></a>00116             }
<a name="l00117"></a>00117             <span class="keywordflow">else</span> {
<a name="l00118"></a>00118                 <span class="keywordflow">if</span> (cmp(*from0, *from2)) {
<a name="l00119"></a>00119                     <span class="keywordflow">goto</span> s201;
<a name="l00120"></a>00120                 }
<a name="l00121"></a>00121                 <span class="keywordflow">else</span> {
<a name="l00122"></a>00122                     <span class="keywordflow">goto</span> s021;
<a name="l00123"></a>00123                 }
<a name="l00124"></a>00124             }
<a name="l00125"></a>00125         } <span class="keywordflow">else</span> {
<a name="l00126"></a>00126             <span class="keywordflow">if</span> (cmp(*from2, *from1)) {
<a name="l00127"></a>00127                 <span class="keywordflow">if</span> (cmp(*from2, *from0)) {
<a name="l00128"></a>00128                     <span class="keywordflow">goto</span> s102;
<a name="l00129"></a>00129                 }
<a name="l00130"></a>00130                 <span class="keywordflow">else</span> {
<a name="l00131"></a>00131                     <span class="keywordflow">goto</span> s120;
<a name="l00132"></a>00132                 }
<a name="l00133"></a>00133             } <span class="keywordflow">else</span> {
<a name="l00134"></a>00134                 <span class="keywordflow">goto</span> s210;
<a name="l00135"></a>00135             }
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="preprocessor">#define Merge3Case(a, b, c)\</span>
<a name="l00139"></a>00139 <span class="preprocessor">    s ## a ## b ## c : \</span>
<a name="l00140"></a>00140 <span class="preprocessor">    if (to == done) \</span>
<a name="l00141"></a>00141 <span class="preprocessor">        goto finish;\</span>
<a name="l00142"></a>00142 <span class="preprocessor">    *to = *from ## a; \</span>
<a name="l00143"></a>00143 <span class="preprocessor">    ++to; \</span>
<a name="l00144"></a>00144 <span class="preprocessor">    ++from ## a; \</span>
<a name="l00145"></a>00145 <span class="preprocessor">    if (cmp(*from ## b, *from ## a )) \</span>
<a name="l00146"></a>00146 <span class="preprocessor">        goto s ## a ## b ## c;\</span>
<a name="l00147"></a>00147 <span class="preprocessor">    if (cmp(*from ## c, *from ## a )) \</span>
<a name="l00148"></a>00148 <span class="preprocessor">        goto s ## b ## a ## c;\</span>
<a name="l00149"></a>00149 <span class="preprocessor">    goto s ## b ## c ## a;</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151         <span class="comment">// the order is choosen in such a way that</span>
<a name="l00152"></a>00152         <span class="comment">// four of the trailing gotos can be eliminated by the optimizer</span>
<a name="l00153"></a>00153         Merge3Case(0, 1, 2);
<a name="l00154"></a>00154         Merge3Case(1, 2, 0);
<a name="l00155"></a>00155         Merge3Case(2, 0, 1);
<a name="l00156"></a>00156         Merge3Case(1, 0, 2);
<a name="l00157"></a>00157         Merge3Case(0, 2, 1);
<a name="l00158"></a>00158         Merge3Case(2, 1, 0);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 finish:
<a name="l00161"></a>00161         *f0   = from0;
<a name="l00162"></a>00162         *f1   = from1;
<a name="l00163"></a>00163         *f2   = from2;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">// merge sz element from the three sentinel terminated input</span>
<a name="l00168"></a>00168 <span class="comment">// sequences *f0, *f1, *f2 and *f3 to "to"</span>
<a name="l00169"></a>00169 <span class="comment">// advance *f0, *f1, *f2 and *f3 accordingly.</span>
<a name="l00170"></a>00170 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1, f2 and f2</span>
<a name="l00171"></a>00171 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00172"></a>00172 <span class="comment">//   *fx + sz is before the end of fx</span>
<a name="l00173"></a>00173     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_, <span class="keyword">class</span> Cmp_&gt;
<a name="l00174"></a>00174     <span class="keywordtype">void</span> merge4(
<a name="l00175"></a>00175         Value_ * * f0,
<a name="l00176"></a>00176         Value_ * * f1,
<a name="l00177"></a>00177         Value_ * * f2,
<a name="l00178"></a>00178         Value_ * * f3,
<a name="l00179"></a>00179         Value_ * to, int_type sz, Cmp_ cmp)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181         Value_ * from0   = *f0;
<a name="l00182"></a>00182         Value_ * from1   = *f1;
<a name="l00183"></a>00183         Value_ * from2   = *f2;
<a name="l00184"></a>00184         Value_ * from3   = *f3;
<a name="l00185"></a>00185         Value_ * done    = to + sz;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="preprocessor">#define StartMerge4(a, b, c, d)\</span>
<a name="l00188"></a>00188 <span class="preprocessor">    if ( (!cmp(*from ## a, *from ## b )) &amp;&amp; (!cmp(*from ## b, *from ## c )) &amp;&amp; (!cmp(*from ## c, *from ## d )) ) \</span>
<a name="l00189"></a>00189 <span class="preprocessor">        goto s ## a ## b ## c ## d;</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191         <span class="comment">// b&gt;a c&gt;b d&gt;c</span>
<a name="l00192"></a>00192         <span class="comment">// a&lt;b b&lt;c c&lt;d</span>
<a name="l00193"></a>00193         <span class="comment">// a&lt;=b b&lt;=c c&lt;=d</span>
<a name="l00194"></a>00194         <span class="comment">// !(a&gt;b) !(b&gt;c) !(c&gt;d)</span>
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         StartMerge4(0, 1, 2, 3);
<a name="l00197"></a>00197         StartMerge4(1, 2, 3, 0);
<a name="l00198"></a>00198         StartMerge4(2, 3, 0, 1);
<a name="l00199"></a>00199         StartMerge4(3, 0, 1, 2);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201         StartMerge4(0, 3, 1, 2);
<a name="l00202"></a>00202         StartMerge4(3, 1, 2, 0);
<a name="l00203"></a>00203         StartMerge4(1, 2, 0, 3);
<a name="l00204"></a>00204         StartMerge4(2, 0, 3, 1);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         StartMerge4(0, 2, 3, 1);
<a name="l00207"></a>00207         StartMerge4(2, 3, 1, 0);
<a name="l00208"></a>00208         StartMerge4(3, 1, 0, 2);
<a name="l00209"></a>00209         StartMerge4(1, 0, 2, 3);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         StartMerge4(2, 0, 1, 3);
<a name="l00212"></a>00212         StartMerge4(0, 1, 3, 2);
<a name="l00213"></a>00213         StartMerge4(1, 3, 2, 0);
<a name="l00214"></a>00214         StartMerge4(3, 2, 0, 1);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         StartMerge4(3, 0, 2, 1);
<a name="l00217"></a>00217         StartMerge4(0, 2, 1, 3);
<a name="l00218"></a>00218         StartMerge4(2, 1, 3, 0);
<a name="l00219"></a>00219         StartMerge4(1, 3, 0, 2);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         StartMerge4(1, 0, 3, 2);
<a name="l00222"></a>00222         StartMerge4(0, 3, 2, 1);
<a name="l00223"></a>00223         StartMerge4(3, 2, 1, 0);
<a name="l00224"></a>00224         StartMerge4(2, 1, 0, 3);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="preprocessor">#define Merge4Case(a, b, c, d)\</span>
<a name="l00227"></a>00227 <span class="preprocessor">    s ## a ## b ## c ## d : \</span>
<a name="l00228"></a>00228 <span class="preprocessor">    if (to == done) \</span>
<a name="l00229"></a>00229 <span class="preprocessor">        goto finish;\</span>
<a name="l00230"></a>00230 <span class="preprocessor">    *to = *from ## a; \</span>
<a name="l00231"></a>00231 <span class="preprocessor">    ++to; \</span>
<a name="l00232"></a>00232 <span class="preprocessor">    ++from ## a; \</span>
<a name="l00233"></a>00233 <span class="preprocessor">    if (cmp(*from ## c, *from ## a)) \</span>
<a name="l00234"></a>00234 <span class="preprocessor">    { \</span>
<a name="l00235"></a>00235 <span class="preprocessor">        if (cmp(*from ## b, *from ## a )) \</span>
<a name="l00236"></a>00236 <span class="preprocessor">            goto s ## a ## b ## c ## d;\</span>
<a name="l00237"></a>00237 <span class="preprocessor">        else \</span>
<a name="l00238"></a>00238 <span class="preprocessor">            goto s ## b ## a ## c ## d;\</span>
<a name="l00239"></a>00239 <span class="preprocessor">    } \</span>
<a name="l00240"></a>00240 <span class="preprocessor">    else \</span>
<a name="l00241"></a>00241 <span class="preprocessor">    { \</span>
<a name="l00242"></a>00242 <span class="preprocessor">        if (cmp(*from ## d, *from ## a)) \</span>
<a name="l00243"></a>00243 <span class="preprocessor">            goto s ## b ## c ## a ## d;\</span>
<a name="l00244"></a>00244 <span class="preprocessor">        else \</span>
<a name="l00245"></a>00245 <span class="preprocessor">            goto s ## b ## c ## d ## a;\</span>
<a name="l00246"></a>00246 <span class="preprocessor">    }</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span>
<a name="l00248"></a>00248         Merge4Case(0, 1, 2, 3);
<a name="l00249"></a>00249         Merge4Case(1, 2, 3, 0);
<a name="l00250"></a>00250         Merge4Case(2, 3, 0, 1);
<a name="l00251"></a>00251         Merge4Case(3, 0, 1, 2);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         Merge4Case(0, 3, 1, 2);
<a name="l00254"></a>00254         Merge4Case(3, 1, 2, 0);
<a name="l00255"></a>00255         Merge4Case(1, 2, 0, 3);
<a name="l00256"></a>00256         Merge4Case(2, 0, 3, 1);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         Merge4Case(0, 2, 3, 1);
<a name="l00259"></a>00259         Merge4Case(2, 3, 1, 0);
<a name="l00260"></a>00260         Merge4Case(3, 1, 0, 2);
<a name="l00261"></a>00261         Merge4Case(1, 0, 2, 3);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         Merge4Case(2, 0, 1, 3);
<a name="l00264"></a>00264         Merge4Case(0, 1, 3, 2);
<a name="l00265"></a>00265         Merge4Case(1, 3, 2, 0);
<a name="l00266"></a>00266         Merge4Case(3, 2, 0, 1);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         Merge4Case(3, 0, 2, 1);
<a name="l00269"></a>00269         Merge4Case(0, 2, 1, 3);
<a name="l00270"></a>00270         Merge4Case(2, 1, 3, 0);
<a name="l00271"></a>00271         Merge4Case(1, 3, 0, 2);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         Merge4Case(1, 0, 3, 2);
<a name="l00274"></a>00274         Merge4Case(0, 3, 2, 1);
<a name="l00275"></a>00275         Merge4Case(3, 2, 1, 0);
<a name="l00276"></a>00276         Merge4Case(2, 1, 0, 3);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 finish:
<a name="l00279"></a>00279         *f0   = from0;
<a name="l00280"></a>00280         *f1   = from1;
<a name="l00281"></a>00281         *f2   = from2;
<a name="l00282"></a>00282         *f3   = from3;
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="comment">// iterator version</span>
<a name="l00288"></a>00288     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Cmp_&gt;
<a name="l00289"></a>00289     <span class="keywordtype">void</span> merge4_iterator(
<a name="l00290"></a>00290         InputIterator &amp; from0,
<a name="l00291"></a>00291         InputIterator &amp; from1,
<a name="l00292"></a>00292         InputIterator &amp; from2,
<a name="l00293"></a>00293         InputIterator &amp; from3,
<a name="l00294"></a>00294         OutputIterator to, int_type sz, Cmp_ cmp)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296         OutputIterator done    = to + sz;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="preprocessor">#define StartMerge4(a, b, c, d)\</span>
<a name="l00299"></a>00299 <span class="preprocessor">    if ( (!cmp(*from ## a, *from ## b )) &amp;&amp; (!cmp(*from ## b, *from ## c )) &amp;&amp; (!cmp(*from ## c, *from ## d )) ) \</span>
<a name="l00300"></a>00300 <span class="preprocessor">        goto s ## a ## b ## c ## d;</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span>
<a name="l00302"></a>00302         <span class="comment">// b&gt;a c&gt;b d&gt;c</span>
<a name="l00303"></a>00303         <span class="comment">// a&lt;b b&lt;c c&lt;d</span>
<a name="l00304"></a>00304         <span class="comment">// a&lt;=b b&lt;=c c&lt;=d</span>
<a name="l00305"></a>00305         <span class="comment">// !(a&gt;b) !(b&gt;c) !(c&gt;d)</span>
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         StartMerge4(0, 1, 2, 3);
<a name="l00308"></a>00308         StartMerge4(1, 2, 3, 0);
<a name="l00309"></a>00309         StartMerge4(2, 3, 0, 1);
<a name="l00310"></a>00310         StartMerge4(3, 0, 1, 2);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         StartMerge4(0, 3, 1, 2);
<a name="l00313"></a>00313         StartMerge4(3, 1, 2, 0);
<a name="l00314"></a>00314         StartMerge4(1, 2, 0, 3);
<a name="l00315"></a>00315         StartMerge4(2, 0, 3, 1);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         StartMerge4(0, 2, 3, 1);
<a name="l00318"></a>00318         StartMerge4(2, 3, 1, 0);
<a name="l00319"></a>00319         StartMerge4(3, 1, 0, 2);
<a name="l00320"></a>00320         StartMerge4(1, 0, 2, 3);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         StartMerge4(2, 0, 1, 3);
<a name="l00323"></a>00323         StartMerge4(0, 1, 3, 2);
<a name="l00324"></a>00324         StartMerge4(1, 3, 2, 0);
<a name="l00325"></a>00325         StartMerge4(3, 2, 0, 1);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         StartMerge4(3, 0, 2, 1);
<a name="l00328"></a>00328         StartMerge4(0, 2, 1, 3);
<a name="l00329"></a>00329         StartMerge4(2, 1, 3, 0);
<a name="l00330"></a>00330         StartMerge4(1, 3, 0, 2);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332         StartMerge4(1, 0, 3, 2);
<a name="l00333"></a>00333         StartMerge4(0, 3, 2, 1);
<a name="l00334"></a>00334         StartMerge4(3, 2, 1, 0);
<a name="l00335"></a>00335         StartMerge4(2, 1, 0, 3);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="preprocessor">#define Merge4Case(a, b, c, d)\</span>
<a name="l00338"></a>00338 <span class="preprocessor">    s ## a ## b ## c ## d : \</span>
<a name="l00339"></a>00339 <span class="preprocessor">    if (to == done) \</span>
<a name="l00340"></a>00340 <span class="preprocessor">        goto finish;\</span>
<a name="l00341"></a>00341 <span class="preprocessor">    *to = *from ## a; \</span>
<a name="l00342"></a>00342 <span class="preprocessor">    ++to; \</span>
<a name="l00343"></a>00343 <span class="preprocessor">    ++from ## a; \</span>
<a name="l00344"></a>00344 <span class="preprocessor">    if (cmp(*from ## c, *from ## a)) \</span>
<a name="l00345"></a>00345 <span class="preprocessor">    { \</span>
<a name="l00346"></a>00346 <span class="preprocessor">        if (cmp(*from ## b, *from ## a )) \</span>
<a name="l00347"></a>00347 <span class="preprocessor">            goto s ## a ## b ## c ## d;\</span>
<a name="l00348"></a>00348 <span class="preprocessor">        else \</span>
<a name="l00349"></a>00349 <span class="preprocessor">            goto s ## b ## a ## c ## d;\</span>
<a name="l00350"></a>00350 <span class="preprocessor">    } \</span>
<a name="l00351"></a>00351 <span class="preprocessor">    else \</span>
<a name="l00352"></a>00352 <span class="preprocessor">    { \</span>
<a name="l00353"></a>00353 <span class="preprocessor">        if (cmp(*from ## d, *from ## a)) \</span>
<a name="l00354"></a>00354 <span class="preprocessor">            goto s ## b ## c ## a ## d;\</span>
<a name="l00355"></a>00355 <span class="preprocessor">        else \</span>
<a name="l00356"></a>00356 <span class="preprocessor">            goto s ## b ## c ## d ## a;\</span>
<a name="l00357"></a>00357 <span class="preprocessor">    }</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>
<a name="l00359"></a>00359         Merge4Case(0, 1, 2, 3);
<a name="l00360"></a>00360         Merge4Case(1, 2, 3, 0);
<a name="l00361"></a>00361         Merge4Case(2, 3, 0, 1);
<a name="l00362"></a>00362         Merge4Case(3, 0, 1, 2);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         Merge4Case(0, 3, 1, 2);
<a name="l00365"></a>00365         Merge4Case(3, 1, 2, 0);
<a name="l00366"></a>00366         Merge4Case(1, 2, 0, 3);
<a name="l00367"></a>00367         Merge4Case(2, 0, 3, 1);
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         Merge4Case(0, 2, 3, 1);
<a name="l00370"></a>00370         Merge4Case(2, 3, 1, 0);
<a name="l00371"></a>00371         Merge4Case(3, 1, 0, 2);
<a name="l00372"></a>00372         Merge4Case(1, 0, 2, 3);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         Merge4Case(2, 0, 1, 3);
<a name="l00375"></a>00375         Merge4Case(0, 1, 3, 2);
<a name="l00376"></a>00376         Merge4Case(1, 3, 2, 0);
<a name="l00377"></a>00377         Merge4Case(3, 2, 0, 1);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         Merge4Case(3, 0, 2, 1);
<a name="l00380"></a>00380         Merge4Case(0, 2, 1, 3);
<a name="l00381"></a>00381         Merge4Case(2, 1, 3, 0);
<a name="l00382"></a>00382         Merge4Case(1, 3, 0, 2);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         Merge4Case(1, 0, 3, 2);
<a name="l00385"></a>00385         Merge4Case(0, 3, 2, 1);
<a name="l00386"></a>00386         Merge4Case(3, 2, 1, 0);
<a name="l00387"></a>00387         Merge4Case(2, 1, 0, 3);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 finish:
<a name="l00390"></a>00390         <span class="keywordflow">return</span>;
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="keyword">template</span> &lt;  <span class="keyword">class </span>BlockType_,
<a name="l00396"></a>00396               <span class="keyword">class </span>Cmp_,
<a name="l00397"></a>00397               <span class="keywordtype">unsigned</span> Arity_,
<a name="l00398"></a>00398               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00399"></a>00399     <span class="keyword">class </span>ext_merger
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401     <span class="keyword">public</span>:
<a name="l00402"></a>00402         <span class="keyword">typedef</span> stxxl::int64 size_type;
<a name="l00403"></a>00403         <span class="keyword">typedef</span> BlockType_ block_type;
<a name="l00404"></a>00404         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structBID.html" title="Block identifier class.">block_type::bid_type</a> bid_type;
<a name="l00405"></a>00405         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
<a name="l00406"></a>00406         <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l00407"></a>00407         <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
<a name="l00408"></a>00408         <span class="keyword">typedef</span> value_type Element;
<a name="l00409"></a>00409         <span class="keyword">typedef</span> typed_block &lt; sizeof(value_type), value_type &gt; sentinel_block_type;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         <span class="keyword">enum</span> { arity = Arity_, KNKMAX = 1UL &lt;&lt; (LOG &lt; Arity_ &gt; ::value + 1) };
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         block_type * convert_block_pointer(sentinel_block_type * arg)
<a name="l00414"></a>00414         {
<a name="l00415"></a>00415             <span class="keywordflow">return</span> (block_type *)arg;
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     <span class="keyword">protected</span>:
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         comparator_type cmp;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00423"></a>00423 <span class="keyword">        </span>{
<a name="l00424"></a>00424             <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a));
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426         <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00427"></a>00427 <span class="keyword">        </span>{
<a name="l00428"></a>00428             <span class="keywordflow">return</span> cmp(cmp.min_value(), a);
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="keyword">struct </span>sequence_type
<a name="l00432"></a>00432         {
<a name="l00433"></a>00433             unsigned_type current;
<a name="l00434"></a>00434             block_type * block;
<a name="l00435"></a>00435             std::list&lt;bid_type&gt; * bids; <span class="comment">// TODO: really need a pointer ?</span>
<a name="l00436"></a>00436             comparator_type cmp;
<a name="l00437"></a>00437             ext_merger * merger;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439             <span class="keyword">const</span> value_type &amp; operator * ()<span class="keyword"> const</span>
<a name="l00440"></a>00440 <span class="keyword">            </span>{
<a name="l00441"></a>00441                 <span class="keywordflow">return</span> (* block)[current];
<a name="l00442"></a>00442             }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444             sequence_type() : bids(NULL)
<a name="l00445"></a>00445             { }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00448"></a>00448             ~sequence_type()
<a name="l00449"></a>00449             {
<a name="l00450"></a>00450                 STXXL_VERBOSE1(<span class="stringliteral">"ext_merger sequence_type::~sequence_type()"</span>);
<a name="l00451"></a>00451                 <span class="keywordflow">if</span> (bids)
<a name="l00452"></a>00452                 {
<a name="l00453"></a>00453                     <a class="code" href="classblock__manager.html" title="Block manager class.">block_manager</a> * bm = <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>();
<a name="l00454"></a>00454                     bm-&gt;<a class="code" href="group__mnglayer.html#g0a41492a2faef107fb3c5a7c1ce5ee2d" title="Deallocates blocks.">delete_blocks</a>(bids-&gt;begin(), bids-&gt;end());
<a name="l00455"></a>00455                     <span class="keyword">delete</span> bids;
<a name="l00456"></a>00456                 }
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459             <span class="keywordtype">void</span> make_inf()
<a name="l00460"></a>00460             {
<a name="l00461"></a>00461                 current = 0;
<a name="l00462"></a>00462                 (*block)[0] = cmp.min_value();
<a name="l00463"></a>00463             }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465             <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00466"></a>00466 <span class="keyword">            </span>{
<a name="l00467"></a>00467                 <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a));
<a name="l00468"></a>00468             }
<a name="l00469"></a>00469             <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00470"></a>00470 <span class="keyword">            </span>{
<a name="l00471"></a>00471                 <span class="keywordflow">return</span> cmp(cmp.min_value(), a);
<a name="l00472"></a>00472             }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474             sequence_type &amp; operator = (sequence_type &amp; obj)
<a name="l00475"></a>00475             {
<a name="l00476"></a>00476                 <span class="keywordflow">if</span> (&amp;obj != <span class="keyword">this</span>)
<a name="l00477"></a>00477                 {
<a name="l00478"></a>00478                     assert(is_sentinel((*block)[current]));
<a name="l00479"></a>00479                     current = obj.current;
<a name="l00480"></a>00480                     std::swap(block, obj.block);
<a name="l00481"></a>00481                     std::swap(bids, obj.bids);
<a name="l00482"></a>00482                 }
<a name="l00483"></a>00483                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00484"></a>00484             }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             sequence_type &amp; operator ++ ()
<a name="l00487"></a>00487             {
<a name="l00488"></a>00488                 assert(not_sentinel((*block)[current]));
<a name="l00489"></a>00489                 assert(current &lt; block-&gt;size);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491                 ++current;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493                 <span class="keywordflow">if</span> (current == block-&gt;size )
<a name="l00494"></a>00494                 {
<a name="l00495"></a>00495                     STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_type operator++ crossing block border "</span>);
<a name="l00496"></a>00496                     <span class="comment">// go to the next block</span>
<a name="l00497"></a>00497                     assert(bids);
<a name="l00498"></a>00498                     <span class="keywordflow">if</span> (bids-&gt;empty()) <span class="comment">// if there is no next block</span>
<a name="l00499"></a>00499                     {
<a name="l00500"></a>00500                         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_type operator++ it was the last block in the sequence "</span>);
<a name="l00501"></a>00501                         <span class="keyword">delete</span> bids;
<a name="l00502"></a>00502                         bids = NULL;
<a name="l00503"></a>00503                         make_inf();
<a name="l00504"></a>00504                     }
<a name="l00505"></a>00505                     <span class="keywordflow">else</span>
<a name="l00506"></a>00506                     {
<a name="l00507"></a>00507                         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_type operator++ there is another block "</span>);
<a name="l00508"></a>00508                         bid_type bid = bids-&gt;front();
<a name="l00509"></a>00509                         bids-&gt;pop_front();
<a name="l00510"></a>00510                         <span class="keywordflow">if</span> (!(bids-&gt;empty()))
<a name="l00511"></a>00511                         {
<a name="l00512"></a>00512                             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_type operator++ one more block exists in a sequence: "</span> &lt;&lt;
<a name="l00513"></a>00513                                            <span class="stringliteral">"flushing this block in write cache (if not written yet) and giving hint to prefetcher"</span>);
<a name="l00514"></a>00514                             bid_type next_bid = bids-&gt;front();
<a name="l00515"></a>00515                             merger-&gt;p_pool-&gt;hint(next_bid, *(merger-&gt;w_pool));
<a name="l00516"></a>00516                         }
<a name="l00517"></a>00517                         merger-&gt;p_pool-&gt;read(block, bid)-&gt;wait();
<a name="l00518"></a>00518                         <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>()-&gt;<a class="code" href="group__mnglayer.html#g021e2ef7f3d56eb6dda56958ff5e0739" title="Deallocates a block.">delete_block</a>(bid);
<a name="l00519"></a>00519                         current = 0;
<a name="l00520"></a>00520                     }
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00523"></a>00523             }
<a name="l00524"></a>00524         };
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="comment">// this version of ext_merger is based on the loser tree data structure</span>
<a name="l00528"></a>00528 
<a name="l00529"></a>00529         <span class="keyword">struct </span>Entry
<a name="l00530"></a>00530         {
<a name="l00531"></a>00531             value_type key; <span class="comment">// Key of Looser element (winner for 0)</span>
<a name="l00532"></a>00532             int_type index; <span class="comment">// the number of losing segment</span>
<a name="l00533"></a>00533         };
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="comment">// stack of empty segments</span>
<a name="l00536"></a>00536         int_type empty[KNKMAX]; <span class="comment">// indices of empty segments</span>
<a name="l00537"></a>00537         int_type lastFree; <span class="comment">// where in "empty" is the last valid entry?</span>
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         unsigned_type size_; <span class="comment">// total number of elements stored</span>
<a name="l00540"></a>00540         <span class="comment">// previously size_type nelements;</span>
<a name="l00541"></a>00541         <span class="keywordtype">unsigned</span> logK; <span class="comment">// log of current tree size</span>
<a name="l00542"></a>00542         unsigned_type k; <span class="comment">// invariant k = 1 &lt;&lt; logK</span>
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         <span class="comment">//Element dummy; // target of empty segment pointers</span>
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <span class="comment">// upper levels of loser trees</span>
<a name="l00547"></a>00547         <span class="comment">// entry[0] contains the winner info</span>
<a name="l00548"></a>00548         Entry entry[KNKMAX];
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         <span class="comment">// leaf information</span>
<a name="l00551"></a>00551         <span class="comment">// note that Knuth uses indices k..k-1</span>
<a name="l00552"></a>00552         <span class="comment">// while we use 0..k-1</span>
<a name="l00553"></a>00553         sequence_type current[KNKMAX]; <span class="comment">// pointer to actual element</span>
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> *p_pool;
<a name="l00556"></a>00556         <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> *w_pool;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         sentinel_block_type sentinel_block;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         <span class="comment">// private member functions</span>
<a name="l00561"></a>00561         <span class="comment">/*</span>
<a name="l00562"></a>00562 <span class="comment">           int_type initWinner(int_type root);</span>
<a name="l00563"></a>00563 <span class="comment">           void updateOnInsert(int_type node, const Element &amp; newKey, int_type newIndex,</span>
<a name="l00564"></a>00564 <span class="comment">                          Element * winnerKey, int_type * winnerIndex, int_type * mask);</span>
<a name="l00565"></a>00565 <span class="comment">           void deallocateSegment(int_type index);</span>
<a name="l00566"></a>00566 <span class="comment">           void doubleK();</span>
<a name="l00567"></a>00567 <span class="comment">           void compactTree();</span>
<a name="l00568"></a>00568 <span class="comment">           void rebuildLooserTree();</span>
<a name="l00569"></a>00569 <span class="comment">           bool segmentIsEmpty(int_type i);</span>
<a name="l00570"></a>00570 <span class="comment">           void multi_merge_k(Element * to, int_type l);</span>
<a name="l00571"></a>00571 <span class="comment">         */</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="keyword">private</span>:
<a name="l00574"></a>00574         ext_merger(<span class="keyword">const</span> ext_merger &amp;);   <span class="comment">// forbiden</span>
<a name="l00575"></a>00575         ext_merger &amp; operator = (<span class="keyword">const</span> ext_merger &amp;);  <span class="comment">// forbiden</span>
<a name="l00576"></a>00576     <span class="keyword">public</span>:
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         ext_merger() : lastFree(0), size_(0), logK(0), k(1)
<a name="l00580"></a>00580         {
<a name="l00581"></a>00581             sentinel_block[0] = cmp.min_value();
<a name="l00582"></a>00582 
<a name="l00583"></a>00583             <span class="keywordflow">for</span> (int_type i = 0; i &lt; KNKMAX; ++i)
<a name="l00584"></a>00584             {
<a name="l00585"></a>00585                 current[i].merger = <span class="keyword">this</span>;
<a name="l00586"></a>00586                 <span class="keywordflow">if</span> (i &gt;= arity)
<a name="l00587"></a>00587                     current[i].block = convert_block_pointer(&amp;(sentinel_block));
<a name="l00588"></a>00588 
<a name="l00589"></a>00589                 <span class="keywordflow">else</span>
<a name="l00590"></a>00590                     current[i].block = <span class="keyword">new</span> block_type;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 
<a name="l00593"></a>00593                 current[i].make_inf();
<a name="l00594"></a>00594             }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596             empty  [0] = 0;
<a name="l00597"></a>00597             init();
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         ext_merger( prefetch_pool &lt; block_type &gt; * p_pool_,
<a name="l00601"></a>00601                     <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> * w_pool_) :
<a name="l00602"></a>00602             lastFree(0), size_(0), logK(0), k(1),
<a name="l00603"></a>00603             p_pool(p_pool_),
<a name="l00604"></a>00604             w_pool(w_pool_)
<a name="l00605"></a>00605         {
<a name="l00606"></a>00606             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::ext_merger(...)"</span>);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608             sentinel_block[0] = cmp.min_value();
<a name="l00609"></a>00609 
<a name="l00610"></a>00610             <span class="keywordflow">for</span> (int_type i = 0; i &lt; KNKMAX; ++i)
<a name="l00611"></a>00611             {
<a name="l00612"></a>00612                 current[i].merger = <span class="keyword">this</span>;
<a name="l00613"></a>00613                 <span class="keywordflow">if</span> (i &gt;= arity)
<a name="l00614"></a>00614                     current[i].block = convert_block_pointer(&amp;(sentinel_block));
<a name="l00615"></a>00615 
<a name="l00616"></a>00616                 <span class="keywordflow">else</span>
<a name="l00617"></a>00617                     current[i].block = <span class="keyword">new</span> block_type;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                 current[i].make_inf();
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 
<a name="l00624"></a>00624             empty  [0] = 0;
<a name="l00625"></a>00625             init();
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         <span class="keyword">virtual</span> ~ext_merger()
<a name="l00629"></a>00629         {
<a name="l00630"></a>00630             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::~ext_merger()"</span>);
<a name="l00631"></a>00631             <span class="keywordflow">for</span> (int_type i = 0; i &lt; arity; ++i)
<a name="l00632"></a>00632             {
<a name="l00633"></a>00633                 <span class="keyword">delete</span> current[i].block;
<a name="l00634"></a>00634             }
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637         <span class="keywordtype">void</span> set_pools(prefetch_pool &lt; block_type &gt; * p_pool_,
<a name="l00638"></a>00638                        <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> * w_pool_)
<a name="l00639"></a>00639         {
<a name="l00640"></a>00640             p_pool = p_pool_;
<a name="l00641"></a>00641             w_pool = w_pool_;
<a name="l00642"></a>00642         }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="keywordtype">void</span> init()
<a name="l00645"></a>00645         {
<a name="l00646"></a>00646             rebuildLooserTree();
<a name="l00647"></a>00647             assert(is_sentinel(*current[entry[0].index]));
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="comment">// rebuild loser tree information from the values in current</span>
<a name="l00651"></a>00651         <span class="keywordtype">void</span> rebuildLooserTree()
<a name="l00652"></a>00652         {
<a name="l00653"></a>00653             int_type winner = initWinner(1);
<a name="l00654"></a>00654             entry[0].index = winner;
<a name="l00655"></a>00655             entry[0].key   = *(current[winner]);
<a name="l00656"></a>00656         }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <span class="comment">// given any values in the leaves this</span>
<a name="l00660"></a>00660         <span class="comment">// routing recomputes upper levels of the tree</span>
<a name="l00661"></a>00661         <span class="comment">// from scratch in linear time</span>
<a name="l00662"></a>00662         <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
<a name="l00663"></a>00663         <span class="comment">// return winner index</span>
<a name="l00664"></a>00664         int_type initWinner(int_type root)
<a name="l00665"></a>00665         {
<a name="l00666"></a>00666             <span class="keywordflow">if</span> (root &gt;= int_type(k)) { <span class="comment">// leaf reached</span>
<a name="l00667"></a>00667                 <span class="keywordflow">return</span> root - k;
<a name="l00668"></a>00668             } <span class="keywordflow">else</span> {
<a name="l00669"></a>00669                 int_type left  = initWinner(2 * root    );
<a name="l00670"></a>00670                 int_type right = initWinner(2 * root + 1);
<a name="l00671"></a>00671                 Element lk    = *(current[left ]);
<a name="l00672"></a>00672                 Element rk    = *(current[right]);
<a name="l00673"></a>00673                 <span class="keywordflow">if</span> (!(cmp(lk, rk))) { <span class="comment">// right subtree looses</span>
<a name="l00674"></a>00674                     entry[root].index = right;
<a name="l00675"></a>00675                     entry[root].key   = rk;
<a name="l00676"></a>00676                     <span class="keywordflow">return</span> left;
<a name="l00677"></a>00677                 } <span class="keywordflow">else</span> {
<a name="l00678"></a>00678                     entry[root].index = left;
<a name="l00679"></a>00679                     entry[root].key   = lk;
<a name="l00680"></a>00680                     <span class="keywordflow">return</span> right;
<a name="l00681"></a>00681                 }
<a name="l00682"></a>00682             }
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="comment">// first go up the tree all the way to the root</span>
<a name="l00686"></a>00686         <span class="comment">// hand down old winner for the respective subtree</span>
<a name="l00687"></a>00687         <span class="comment">// based on new value, and old winner and loser</span>
<a name="l00688"></a>00688         <span class="comment">// update each node on the path to the root top down.</span>
<a name="l00689"></a>00689         <span class="comment">// This is implemented recursively</span>
<a name="l00690"></a>00690         <span class="keywordtype">void</span> updateOnInsert(
<a name="l00691"></a>00691             int_type node,
<a name="l00692"></a>00692             <span class="keyword">const</span> Element &amp; newKey,
<a name="l00693"></a>00693             int_type newIndex,
<a name="l00694"></a>00694             Element * winnerKey,
<a name="l00695"></a>00695             int_type * winnerIndex,        <span class="comment">// old winner</span>
<a name="l00696"></a>00696             int_type * mask)        <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
<a name="l00697"></a>00697         {
<a name="l00698"></a>00698             <span class="keywordflow">if</span> (node == 0) { <span class="comment">// winner part of root</span>
<a name="l00699"></a>00699                 *mask = 1 &lt;&lt; (logK - 1);
<a name="l00700"></a>00700                 *winnerKey   = entry[0].key;
<a name="l00701"></a>00701                 *winnerIndex = entry[0].index;
<a name="l00702"></a>00702                 <span class="keywordflow">if</span> (cmp(entry[node].key, newKey))
<a name="l00703"></a>00703                 {
<a name="l00704"></a>00704                     entry[node].key   = newKey;
<a name="l00705"></a>00705                     entry[node].index = newIndex;
<a name="l00706"></a>00706                 }
<a name="l00707"></a>00707             } <span class="keywordflow">else</span> {
<a name="l00708"></a>00708                 updateOnInsert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
<a name="l00709"></a>00709                 Element loserKey   = entry[node].key;
<a name="l00710"></a>00710                 int_type loserIndex = entry[node].index;
<a name="l00711"></a>00711                 <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
<a name="l00712"></a>00712                     <span class="keywordflow">if</span> (cmp(loserKey, newKey)) { <span class="comment">// newKey will have influence here</span>
<a name="l00713"></a>00713                         <span class="keywordflow">if</span> (cmp(*winnerKey, newKey) ) { <span class="comment">// old winner loses here</span>
<a name="l00714"></a>00714                             entry[node].key   = *winnerKey;
<a name="l00715"></a>00715                             entry[node].index = *winnerIndex;
<a name="l00716"></a>00716                         } <span class="keywordflow">else</span> { <span class="comment">// new entry looses here</span>
<a name="l00717"></a>00717                             entry[node].key   = newKey;
<a name="l00718"></a>00718                             entry[node].index = newIndex;
<a name="l00719"></a>00719                         }
<a name="l00720"></a>00720                     }
<a name="l00721"></a>00721                     *winnerKey   = loserKey;
<a name="l00722"></a>00722                     *winnerIndex = loserIndex;
<a name="l00723"></a>00723                 }
<a name="l00724"></a>00724                 <span class="comment">// note that nothing needs to be done if</span>
<a name="l00725"></a>00725                 <span class="comment">// the winner came from the same subtree</span>
<a name="l00726"></a>00726                 <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to loose</span>
<a name="l00727"></a>00727                 <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
<a name="l00728"></a>00728                 <span class="comment">//                           entry further down the tree</span>
<a name="l00729"></a>00729                 <span class="comment">// also the same old winner is handed down the tree</span>
<a name="l00730"></a>00730 
<a name="l00731"></a>00731                 *mask &gt;&gt;= 1; <span class="comment">// next level</span>
<a name="l00732"></a>00732             }
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="comment">// make the tree two times as wide</span>
<a name="l00736"></a>00736         <span class="comment">// may only be called if no free slots are left ?? necessary ??</span>
<a name="l00737"></a>00737         <span class="keywordtype">void</span> doubleK()
<a name="l00738"></a>00738         {
<a name="l00739"></a>00739             <span class="comment">// make all new entries empty</span>
<a name="l00740"></a>00740             <span class="comment">// and push them on the free stack</span>
<a name="l00741"></a>00741             assert(lastFree == -1); <span class="comment">// stack was empty (probably not needed)</span>
<a name="l00742"></a>00742             assert(k &lt; KNKMAX);
<a name="l00743"></a>00743             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::doubleK (before) k: "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" KNKMAX:"</span> &lt;&lt; KNKMAX);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745             <span class="keywordflow">for</span> (int_type i = 2 * k - 1;  i &gt;= int_type(k);  i--)
<a name="l00746"></a>00746             {
<a name="l00747"></a>00747                 current[i].make_inf();
<a name="l00748"></a>00748                 <span class="keywordflow">if</span> (i &lt; arity)
<a name="l00749"></a>00749                 {
<a name="l00750"></a>00750                     lastFree++;
<a name="l00751"></a>00751                     empty[lastFree] = i;
<a name="l00752"></a>00752                 }
<a name="l00753"></a>00753             }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755             <span class="comment">// double the size</span>
<a name="l00756"></a>00756             k *= 2;
<a name="l00757"></a>00757             logK++;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759             <span class="comment">// recompute loser tree information</span>
<a name="l00760"></a>00760             rebuildLooserTree();
<a name="l00761"></a>00761 
<a name="l00762"></a>00762             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::doubleK (after) k: "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" KNKMAX:"</span> &lt;&lt; KNKMAX);
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="comment">// compact nonempty segments in the left half of the tree</span>
<a name="l00767"></a>00767         <span class="keywordtype">void</span> compactTree()
<a name="l00768"></a>00768         {
<a name="l00769"></a>00769             assert(logK &gt; 0);
<a name="l00770"></a>00770 
<a name="l00771"></a>00771             <span class="comment">// compact all nonempty segments to the left</span>
<a name="l00772"></a>00772             int_type from = 0;
<a name="l00773"></a>00773             int_type to   = 0;
<a name="l00774"></a>00774             <span class="keywordflow">for</span> ( ;  from &lt; int_type(k);  from++)
<a name="l00775"></a>00775             {
<a name="l00776"></a>00776                 <span class="keywordflow">if</span> (not_sentinel(*(current[from])))
<a name="l00777"></a>00777                 {
<a name="l00778"></a>00778                     current[to] = current[from];
<a name="l00779"></a>00779                     to++;
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781             }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783             <span class="comment">// half degree as often as possible</span>
<a name="l00784"></a>00784             <span class="keywordflow">while</span> (to &lt; int_type(k / 2)) {
<a name="l00785"></a>00785                 k /= 2;
<a name="l00786"></a>00786                 logK--;
<a name="l00787"></a>00787             }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789             <span class="comment">// overwrite garbage and compact the stack of empty segments</span>
<a name="l00790"></a>00790             lastFree = -1; <span class="comment">// none free</span>
<a name="l00791"></a>00791             <span class="keywordflow">for</span> ( ;  to &lt; int_type(k);  to++) {
<a name="l00792"></a>00792                 <span class="comment">// push</span>
<a name="l00793"></a>00793                 <span class="keywordflow">if</span> (to &lt; arity)
<a name="l00794"></a>00794                 {
<a name="l00795"></a>00795                     lastFree++;
<a name="l00796"></a>00796                     empty[lastFree] = to;
<a name="l00797"></a>00797                 }
<a name="l00798"></a>00798                 current[to].make_inf();
<a name="l00799"></a>00799             }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801             <span class="comment">// recompute loser tree information</span>
<a name="l00802"></a>00802             rebuildLooserTree();
<a name="l00803"></a>00803         }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         <span class="keywordtype">void</span> swap(ext_merger &amp; obj)
<a name="l00807"></a>00807         {
<a name="l00808"></a>00808             std::swap(cmp, obj.cmp);
<a name="l00809"></a>00809             swap_1D_arrays(empty, obj.empty, KNKMAX);
<a name="l00810"></a>00810             std::swap(lastFree, obj.lastFree);
<a name="l00811"></a>00811             std::swap(size_, obj.size_);
<a name="l00812"></a>00812             std::swap(logK, obj.logK);
<a name="l00813"></a>00813             std::swap(k, obj.k);
<a name="l00814"></a>00814             swap_1D_arrays(entry, obj.entry, KNKMAX);
<a name="l00815"></a>00815             swap_1D_arrays(current, obj.current, KNKMAX);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817             <span class="comment">// std::swap(p_pool,obj.p_pool);</span>
<a name="l00818"></a>00818             <span class="comment">// std::swap(w_pool,obj.w_pool);</span>
<a name="l00819"></a>00819         }
<a name="l00820"></a>00820         unsigned_type mem_cons() <span class="keyword">const</span> <span class="comment">// only rough estimation</span>
<a name="l00821"></a>00821         {
<a name="l00822"></a>00822             <span class="keywordflow">return</span> (arity * block_type::raw_size);
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="comment">// delete the (begin-end) smallest elements and write them to "to"</span>
<a name="l00826"></a>00826         <span class="comment">// empty segments are deallocated</span>
<a name="l00827"></a>00827         <span class="comment">// require:</span>
<a name="l00828"></a>00828         <span class="comment">// - there are at least l elements</span>
<a name="l00829"></a>00829         <span class="comment">// - segments are ended by sentinels</span>
<a name="l00830"></a>00830         <span class="comment">//void multi_merge(Element *to, unsigned_type l)</span>
<a name="l00831"></a>00831         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;
<a name="l00832"></a>00832         <span class="keywordtype">void</span> multi_merge(OutputIterator begin, OutputIterator end)
<a name="l00833"></a>00833         {
<a name="l00834"></a>00834             size_type l = end - begin;
<a name="l00835"></a>00835             STXXL_VERBOSE2(<span class="stringliteral">"ext_meerger::multi_merge l = "</span> &lt;&lt; l);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 
<a name="l00838"></a>00838             <span class="keywordflow">switch</span> (logK) {
<a name="l00839"></a>00839             <span class="keywordflow">case</span> 0:
<a name="l00840"></a>00840                 assert(k == 1);
<a name="l00841"></a>00841                 assert(entry[0].index == 0);
<a name="l00842"></a>00842                 assert(lastFree == -1 || l == 0);
<a name="l00843"></a>00843                 <span class="comment">//memcpy(to, current[0], l * sizeof(Element));</span>
<a name="l00844"></a>00844                 <span class="comment">//std::copy(current[0],current[0]+l,to);</span>
<a name="l00845"></a>00845                 <span class="keywordflow">for</span> (size_type i = 0; i &lt; l; ++i, ++ (current[0]), ++begin)
<a name="l00846"></a>00846                     *begin = *(current[0]);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 
<a name="l00849"></a>00849                 entry[0].key = **current;
<a name="l00850"></a>00850                 <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l00851"></a>00851                     deallocateSegment(0);
<a name="l00852"></a>00852 
<a name="l00853"></a>00853                 <span class="keywordflow">break</span>;
<a name="l00854"></a>00854             <span class="keywordflow">case</span> 1:
<a name="l00855"></a>00855                 assert(k == 2);
<a name="l00856"></a>00856                 merge_iterator(current[0], current[1], begin, l, cmp);
<a name="l00857"></a>00857                 rebuildLooserTree();
<a name="l00858"></a>00858                 <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l00859"></a>00859                     deallocateSegment(0);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861                 <span class="keywordflow">if</span> (segmentIsEmpty(1))
<a name="l00862"></a>00862                     deallocateSegment(1);
<a name="l00863"></a>00863 
<a name="l00864"></a>00864                 <span class="keywordflow">break</span>;
<a name="l00865"></a>00865             <span class="keywordflow">case</span> 2:
<a name="l00866"></a>00866                 assert(k == 4);
<a name="l00867"></a>00867                 merge4_iterator(current[0], current[1], current[2], current[3], begin, l, cmp);
<a name="l00868"></a>00868                 rebuildLooserTree();
<a name="l00869"></a>00869                 <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l00870"></a>00870                     deallocateSegment(0);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872                 <span class="keywordflow">if</span> (segmentIsEmpty(1))
<a name="l00873"></a>00873                     deallocateSegment(1);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875                 <span class="keywordflow">if</span> (segmentIsEmpty(2))
<a name="l00876"></a>00876                     deallocateSegment(2);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878                 <span class="keywordflow">if</span> (segmentIsEmpty(3))
<a name="l00879"></a>00879                     deallocateSegment(3);
<a name="l00880"></a>00880 
<a name="l00881"></a>00881                 <span class="keywordflow">break</span>;
<a name="l00882"></a>00882             <span class="keywordflow">case</span>  3: multi_merge_f &lt; OutputIterator, 3 &gt; (begin, end);
<a name="l00883"></a>00883                 <span class="keywordflow">break</span>;
<a name="l00884"></a>00884             <span class="keywordflow">case</span>  4: multi_merge_f &lt; OutputIterator, 4 &gt; (begin, end);
<a name="l00885"></a>00885                 <span class="keywordflow">break</span>;
<a name="l00886"></a>00886             <span class="keywordflow">case</span>  5: multi_merge_f &lt; OutputIterator, 5 &gt; (begin, end);
<a name="l00887"></a>00887                 <span class="keywordflow">break</span>;
<a name="l00888"></a>00888             <span class="keywordflow">case</span>  6: multi_merge_f &lt; OutputIterator, 6 &gt; (begin, end);
<a name="l00889"></a>00889                 <span class="keywordflow">break</span>;
<a name="l00890"></a>00890             <span class="keywordflow">case</span>  7: multi_merge_f &lt; OutputIterator, 7 &gt; (begin, end);
<a name="l00891"></a>00891                 <span class="keywordflow">break</span>;
<a name="l00892"></a>00892             <span class="keywordflow">case</span>  8: multi_merge_f &lt; OutputIterator, 8 &gt; (begin, end);
<a name="l00893"></a>00893                 <span class="keywordflow">break</span>;
<a name="l00894"></a>00894             <span class="keywordflow">case</span>  9: multi_merge_f &lt; OutputIterator, 9 &gt; (begin, end);
<a name="l00895"></a>00895                 <span class="keywordflow">break</span>;
<a name="l00896"></a>00896             <span class="keywordflow">case</span> 10: multi_merge_f &lt; OutputIterator, 10 &gt; (begin, end);
<a name="l00897"></a>00897                 <span class="keywordflow">break</span>;
<a name="l00898"></a>00898             <span class="keywordflow">default</span>: multi_merge_k(begin, end);
<a name="l00899"></a>00899                 <span class="keywordflow">break</span>;
<a name="l00900"></a>00900             }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 
<a name="l00904"></a>00904             size_ -= l;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906             <span class="comment">// compact tree if it got considerably smaller</span>
<a name="l00907"></a>00907             <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; int_type(lastFree) &gt;= int_type(3 * k / 5 - 1) ) {
<a name="l00908"></a>00908                 <span class="comment">// using k/2 would be worst case inefficient</span>
<a name="l00909"></a>00909                 compactTree();
<a name="l00910"></a>00910             }
<a name="l00911"></a>00911         }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="comment">// multi-merge for arbitrary K</span>
<a name="l00914"></a>00914         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;
<a name="l00915"></a>00915         <span class="keywordtype">void</span> multi_merge_k(OutputIterator begin, OutputIterator end)
<a name="l00916"></a>00916         <span class="comment">//void multi_merge_k(Element *to, int_type l)</span>
<a name="l00917"></a>00917         {
<a name="l00918"></a>00918             Entry * currentPos;
<a name="l00919"></a>00919             Element currentKey;
<a name="l00920"></a>00920             int_type currentIndex; <span class="comment">// leaf pointed to by current entry</span>
<a name="l00921"></a>00921             int_type kReg = k;
<a name="l00922"></a>00922             OutputIterator done = end;
<a name="l00923"></a>00923             OutputIterator to = begin;
<a name="l00924"></a>00924             int_type winnerIndex = entry[0].index;
<a name="l00925"></a>00925             Element winnerKey   = entry[0].key;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927             <span class="keywordflow">while</span> (to != done)
<a name="l00928"></a>00928             {
<a name="l00929"></a>00929                 <span class="comment">// write result</span>
<a name="l00930"></a>00930                 *to   = *(current[winnerIndex]);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932                 <span class="comment">// advance winner segment</span>
<a name="l00933"></a>00933                 ++ (current[winnerIndex]);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935                 winnerKey = *(current[winnerIndex]);
<a name="l00936"></a>00936 
<a name="l00937"></a>00937                 <span class="comment">// remove winner segment if empty now</span>
<a name="l00938"></a>00938                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))  <span class="comment">//</span>
<a name="l00939"></a>00939                     deallocateSegment(winnerIndex);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 
<a name="l00942"></a>00942                 <span class="comment">// go up the entry-tree</span>
<a name="l00943"></a>00943                 <span class="keywordflow">for</span> (int_type i = (winnerIndex + kReg) &gt;&gt; 1;  i &gt; 0;  i &gt;&gt;= 1) {
<a name="l00944"></a>00944                     currentPos = entry + i;
<a name="l00945"></a>00945                     currentKey = currentPos-&gt;key;
<a name="l00946"></a>00946                     <span class="keywordflow">if</span> (cmp(winnerKey, currentKey)) {
<a name="l00947"></a>00947                         currentIndex      = currentPos-&gt;index;
<a name="l00948"></a>00948                         currentPos-&gt;key   = winnerKey;
<a name="l00949"></a>00949                         currentPos-&gt;index = winnerIndex;
<a name="l00950"></a>00950                         winnerKey         = currentKey;
<a name="l00951"></a>00951                         winnerIndex       = currentIndex;
<a name="l00952"></a>00952                     }
<a name="l00953"></a>00953                 }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955                 ++to;
<a name="l00956"></a>00956             }
<a name="l00957"></a>00957             entry[0].index = winnerIndex;
<a name="l00958"></a>00958             entry[0].key   = winnerKey;
<a name="l00959"></a>00959         }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator, <span class="keywordtype">unsigned</span> LogK&gt;
<a name="l00962"></a>00962         <span class="comment">//void multi_merge_f(Element *to, int_type l)</span>
<a name="l00963"></a>00963         <span class="keywordtype">void</span> multi_merge_f(OutputIterator begin, OutputIterator end)
<a name="l00964"></a>00964         {
<a name="l00965"></a>00965             <span class="comment">//int_type kReg = k;</span>
<a name="l00966"></a>00966             OutputIterator done = end;
<a name="l00967"></a>00967             OutputIterator to = begin;
<a name="l00968"></a>00968             int_type winnerIndex = entry[0].index;
<a name="l00969"></a>00969             Entry * regEntry   = entry;
<a name="l00970"></a>00970             sequence_type * regCurrent = current;
<a name="l00971"></a>00971             Element winnerKey   = entry[0].key;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 
<a name="l00974"></a>00974             assert(logK &gt;= LogK);
<a name="l00975"></a>00975             <span class="keywordflow">while</span> (to != done)
<a name="l00976"></a>00976             {
<a name="l00977"></a>00977                 <span class="comment">// write result</span>
<a name="l00978"></a>00978                 *to   = *(regCurrent[winnerIndex]);
<a name="l00979"></a>00979 
<a name="l00980"></a>00980                 <span class="comment">// advance winner segment</span>
<a name="l00981"></a>00981                 ++ (regCurrent[winnerIndex]);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983                 winnerKey = *(regCurrent[winnerIndex]);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 
<a name="l00986"></a>00986                 <span class="comment">// remove winner segment if empty now</span>
<a name="l00987"></a>00987                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))
<a name="l00988"></a>00988                     deallocateSegment(winnerIndex);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 
<a name="l00991"></a>00991                 ++to;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993                 <span class="comment">// update loser tree</span>
<a name="l00994"></a>00994 <span class="preprocessor">#define TreeStep(L)\</span>
<a name="l00995"></a>00995 <span class="preprocessor">    if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) { \</span>
<a name="l00996"></a>00996 <span class="preprocessor">        Entry * pos ## L = regEntry + ((winnerIndex + (1 &lt;&lt; LogK)) &gt;&gt; (((int (LogK - L) + 1) &gt;= 0) ? ((LogK - L) + 1) : 0)); \</span>
<a name="l00997"></a>00997 <span class="preprocessor">        Element key ## L = pos ## L-&gt;key; \</span>
<a name="l00998"></a>00998 <span class="preprocessor">        if (cmp(winnerKey, key ## L)) { \</span>
<a name="l00999"></a>00999 <span class="preprocessor">            int_type index ## L  = pos ## L-&gt;index; \</span>
<a name="l01000"></a>01000 <span class="preprocessor">            pos ## L-&gt;key   = winnerKey; \</span>
<a name="l01001"></a>01001 <span class="preprocessor">            pos ## L-&gt;index = winnerIndex; \</span>
<a name="l01002"></a>01002 <span class="preprocessor">            winnerKey     = key ## L; \</span>
<a name="l01003"></a>01003 <span class="preprocessor">            winnerIndex   = index ## L; \</span>
<a name="l01004"></a>01004 <span class="preprocessor">        } \</span>
<a name="l01005"></a>01005 <span class="preprocessor">    }</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span>                TreeStep(10);
<a name="l01007"></a>01007                 TreeStep(9);
<a name="l01008"></a>01008                 TreeStep(8);
<a name="l01009"></a>01009                 TreeStep(7);
<a name="l01010"></a>01010                 TreeStep(6);
<a name="l01011"></a>01011                 TreeStep(5);
<a name="l01012"></a>01012                 TreeStep(4);
<a name="l01013"></a>01013                 TreeStep(3);
<a name="l01014"></a>01014                 TreeStep(2);
<a name="l01015"></a>01015                 TreeStep(1);
<a name="l01016"></a>01016 <span class="preprocessor">#undef TreeStep</span>
<a name="l01017"></a>01017 <span class="preprocessor"></span>            }
<a name="l01018"></a>01018             regEntry[0].index = winnerIndex;
<a name="l01019"></a>01019             regEntry[0].key   = winnerKey;
<a name="l01020"></a>01020         }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022 
<a name="l01023"></a>01023         <span class="keywordtype">bool</span> spaceIsAvailable() <span class="keyword">const</span> <span class="comment">// for new segment</span>
<a name="l01024"></a>01024         {
<a name="l01025"></a>01025             <span class="keywordflow">return</span> k &lt; arity || lastFree &gt;= 0;
<a name="l01026"></a>01026         }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         <span class="comment">// insert segment beginning at to</span>
<a name="l01030"></a>01030         <span class="comment">// require: spaceIsAvailable() == 1</span>
<a name="l01031"></a>01031         <span class="comment">//void insert_segment(Element *to, unsigned_type sz)</span>
<a name="l01032"></a>01032         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Merger&gt;
<a name="l01033"></a>01033         <span class="keywordtype">void</span> insert_segment(Merger &amp; another_merger, size_type segment_size)
<a name="l01034"></a>01034         {
<a name="l01035"></a>01035             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::insert_segment(merger,...)"</span>);
<a name="l01036"></a>01036 
<a name="l01037"></a>01037             <span class="keywordflow">if</span> (segment_size &gt; 0)
<a name="l01038"></a>01038             {
<a name="l01039"></a>01039                 <span class="comment">// get a free slot</span>
<a name="l01040"></a>01040                 <span class="keywordflow">if</span> (lastFree &lt; 0) { <span class="comment">// tree is too small</span>
<a name="l01041"></a>01041                     doubleK();
<a name="l01042"></a>01042                 }
<a name="l01043"></a>01043                 int_type index = empty[lastFree];
<a name="l01044"></a>01044                 lastFree--; <span class="comment">// pop</span>
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 
<a name="l01047"></a>01047                 <span class="comment">// link new segment</span>
<a name="l01048"></a>01048                 assert(segment_size);
<a name="l01049"></a>01049                 unsigned_type nblocks = segment_size / block_type::size;
<a name="l01050"></a>01050                 STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::insert_segment(merger,...) inserting segment with "</span> &lt;&lt; nblocks &lt;&lt; <span class="stringliteral">" blocks"</span>);
<a name="l01051"></a>01051                 <span class="comment">//assert(nblocks); // at least one block</span>
<a name="l01052"></a>01052                 STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment nblocks="</span> &lt;&lt; nblocks);
<a name="l01053"></a>01053                 <span class="keywordflow">if</span> (nblocks == 0)
<a name="l01054"></a>01054                 {
<a name="l01055"></a>01055                     STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(merger,...) WARNING: inserting a segment with "</span> &lt;&lt;
<a name="l01056"></a>01056                                    nblocks &lt;&lt; <span class="stringliteral">" blocks"</span>);
<a name="l01057"></a>01057                     STXXL_VERBOSE1(<span class="stringliteral">"THIS IS INEFFICIENT: TRY TO CHANGE PRIORITY QUEUE PARAMETERS"</span>);
<a name="l01058"></a>01058                 }
<a name="l01059"></a>01059                 unsigned_type first_size = segment_size % block_type::size;
<a name="l01060"></a>01060                 <span class="keywordflow">if</span> (first_size == 0)
<a name="l01061"></a>01061                 {
<a name="l01062"></a>01062                     first_size = block_type::size;
<a name="l01063"></a>01063                     --nblocks;
<a name="l01064"></a>01064                 }
<a name="l01065"></a>01065                 <a class="code" href="classblock__manager.html" title="Block manager class.">block_manager</a> * bm = <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>();
<a name="l01066"></a>01066                 std::list&lt;bid_type&gt; *bids = <span class="keyword">new</span> std::list&lt;bid_type&gt;(nblocks);
<a name="l01067"></a>01067                 bm-&gt;<a class="code" href="group__mnglayer.html#g4128bf4658033cc39eeebc21ebe2b93a" title="Allocates new blocks.">new_blocks</a>(alloc_strategy(), bids-&gt;begin(), bids-&gt;end());
<a name="l01068"></a>01068                 block_type * first_block = <span class="keyword">new</span> block_type;
<a name="l01069"></a>01069                 another_merger.multi_merge(
<a name="l01070"></a>01070                     first_block-&gt;begin() + (block_type::size - first_size),
<a name="l01071"></a>01071                     first_block-&gt;end());
<a name="l01072"></a>01072 
<a name="l01073"></a>01073                 assert(w_pool-&gt;<a class="code" href="classwrite__pool.html#587aa787257f33fb015ecdb2b64e6aaa" title="Returns number of owned blocks.">size</a>() &gt; 0);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075                 <span class="keyword">typename</span> std::list&lt;bid_type&gt;::iterator curbid = bids-&gt;begin();
<a name="l01076"></a>01076                 <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; nblocks; ++i, ++curbid)
<a name="l01077"></a>01077                 {
<a name="l01078"></a>01078                     block_type * b = w_pool-&gt;<a class="code" href="classwrite__pool.html#c482070824867e4d08d46c9ccfaef04f" title="Take out a block from the pool.">steal</a>();
<a name="l01079"></a>01079                     another_merger.multi_merge(b-&gt;begin(), b-&gt;end());
<a name="l01080"></a>01080                     w_pool-&gt;<a class="code" href="classwrite__pool.html#4be1e4ab0391051bec733a9060a5404a" title="Passes a block to the pool for writing.">write</a>(b, *curbid);
<a name="l01081"></a>01081                 }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083                 insert_segment(bids, first_block, first_size, index);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085                 size_ += segment_size;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087                 <span class="comment">// propagate new information up the tree</span>
<a name="l01088"></a>01088                 Element dummyKey;
<a name="l01089"></a>01089                 int_type dummyIndex;
<a name="l01090"></a>01090                 int_type dummyMask;
<a name="l01091"></a>01091                 updateOnInsert((index + k) &gt;&gt; 1, *(current[index]), index,
<a name="l01092"></a>01092                                &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
<a name="l01093"></a>01093             } <span class="keywordflow">else</span> {
<a name="l01094"></a>01094                 <span class="comment">// deallocate memory ?</span>
<a name="l01095"></a>01095                 STXXL_VERBOSE1(<span class="stringliteral">"Merged segment with zero size."</span>);
<a name="l01096"></a>01096             }
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099         size_type size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="keyword">protected</span>:
<a name="l01104"></a>01104         <span class="keywordtype">void</span> insert_segment(std::list &lt; bid_type &gt; * segment, block_type * first_block,
<a name="l01105"></a>01105                             unsigned_type first_size, int_type index)
<a name="l01106"></a>01106         {
<a name="l01107"></a>01107             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(segment_bids,...) "</span> &lt;&lt; <span class="keyword">this</span>);
<a name="l01108"></a>01108             assert(first_size);
<a name="l01109"></a>01109 
<a name="l01110"></a>01110             sequence_type &amp; new_sequence = current[index];
<a name="l01111"></a>01111             new_sequence.current = block_type::size - first_size;
<a name="l01112"></a>01112             std::swap(new_sequence.block, first_block);
<a name="l01113"></a>01113             <span class="keyword">delete</span> first_block;
<a name="l01114"></a>01114             std::swap(new_sequence.bids, segment);
<a name="l01115"></a>01115             assert(segment == NULL || segment-&gt;empty());
<a name="l01116"></a>01116             <span class="keywordflow">if</span> (segment)
<a name="l01117"></a>01117             {
<a name="l01118"></a>01118                 assert(segment-&gt;empty());
<a name="l01119"></a>01119                 <span class="keyword">delete</span> segment;
<a name="l01120"></a>01120             }
<a name="l01121"></a>01121         }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         <span class="comment">// free an empty segment .</span>
<a name="l01124"></a>01124         <span class="keywordtype">void</span> deallocateSegment(int_type index)
<a name="l01125"></a>01125         {
<a name="l01126"></a>01126             <span class="comment">// reroute current pointer to some empty dummy segment</span>
<a name="l01127"></a>01127             <span class="comment">// with a sentinel key</span>
<a name="l01128"></a>01128             STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::deallocateSegment() deleting segment "</span> &lt;&lt;
<a name="l01129"></a>01129                            index);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131             current[index].make_inf();
<a name="l01132"></a>01132 
<a name="l01133"></a>01133             <span class="comment">// push on the stack of free segment indices</span>
<a name="l01134"></a>01134             lastFree++;
<a name="l01135"></a>01135             empty[lastFree] = index;
<a name="l01136"></a>01136         }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138         <span class="comment">// is this segment empty ?</span>
<a name="l01139"></a>01139         <span class="keywordtype">bool</span> segmentIsEmpty(int_type i)<span class="keyword"> const</span>
<a name="l01140"></a>01140 <span class="keyword">        </span>{
<a name="l01141"></a>01141             <span class="comment">//return (is_sentinel(*(current[i])) &amp;&amp;  (current[i] != &amp;dummy));</span>
<a name="l01142"></a>01142             <span class="keywordflow">return</span> is_sentinel(*(current[i]));
<a name="l01143"></a>01143         }
<a name="l01144"></a>01144     };
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 
<a name="l01148"></a>01148 <span class="comment">// The data structure from Knuth, "Sorting and Searching", Section 5.4.1</span>
<a name="l01149"></a>01149     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01150"></a>01150     <span class="keyword">class </span>loser_tree
<a name="l01151"></a>01151     {
<a name="l01152"></a>01152     <span class="keyword">public</span>:
<a name="l01153"></a>01153         <span class="keyword">typedef</span> ValTp_ value_type;
<a name="l01154"></a>01154         <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l01155"></a>01155         <span class="keyword">typedef</span> value_type Element;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     <span class="keyword">private</span>:
<a name="l01158"></a>01158         <span class="keyword">struct </span>Entry
<a name="l01159"></a>01159         {
<a name="l01160"></a>01160             value_type key; <span class="comment">// Key of Looser element (winner for 0)</span>
<a name="l01161"></a>01161             int_type index; <span class="comment">// number of loosing segment</span>
<a name="l01162"></a>01162         };
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         comparator_type cmp;
<a name="l01165"></a>01165         <span class="comment">// stack of empty segments</span>
<a name="l01166"></a>01166         int_type empty[KNKMAX]; <span class="comment">// indices of empty segments</span>
<a name="l01167"></a>01167         int_type lastFree; <span class="comment">// where in "empty" is the last valid entry?</span>
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         unsigned_type size_; <span class="comment">// total number of elements stored</span>
<a name="l01170"></a>01170         <span class="keywordtype">unsigned</span> logK; <span class="comment">// log of current tree size</span>
<a name="l01171"></a>01171         unsigned_type k; <span class="comment">// invariant k = 1 &lt;&lt; logK</span>
<a name="l01172"></a>01172 
<a name="l01173"></a>01173         Element dummy; <span class="comment">// target of empty segment pointers</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175         <span class="comment">// upper levels of loser trees</span>
<a name="l01176"></a>01176         <span class="comment">// entry[0] contains the winner info</span>
<a name="l01177"></a>01177         Entry entry[KNKMAX];
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         <span class="comment">// leaf information</span>
<a name="l01180"></a>01180         <span class="comment">// note that Knuth uses indices k..k-1</span>
<a name="l01181"></a>01181         <span class="comment">// while we use 0..k-1</span>
<a name="l01182"></a>01182         Element * current[KNKMAX]; <span class="comment">// pointer to actual element</span>
<a name="l01183"></a>01183         Element * segment[KNKMAX]; <span class="comment">// start of Segments</span>
<a name="l01184"></a>01184         unsigned_type segment_size[KNKMAX]; <span class="comment">// just to count the internal memory consumption</span>
<a name="l01185"></a>01185 
<a name="l01186"></a>01186         unsigned_type mem_cons_;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188         <span class="comment">// private member functions</span>
<a name="l01189"></a>01189         int_type initWinner(int_type root);
<a name="l01190"></a>01190         <span class="keywordtype">void</span> updateOnInsert(int_type node, <span class="keyword">const</span> Element &amp; newKey, int_type newIndex,
<a name="l01191"></a>01191                             Element * winnerKey, int_type * winnerIndex, int_type * mask);
<a name="l01192"></a>01192         <span class="keywordtype">void</span> deallocateSegment(int_type index);
<a name="l01193"></a>01193         <span class="keywordtype">void</span> doubleK();
<a name="l01194"></a>01194         <span class="keywordtype">void</span> compactTree();
<a name="l01195"></a>01195         <span class="keywordtype">void</span> rebuildLooserTree();
<a name="l01196"></a>01196         <span class="keywordtype">bool</span> segmentIsEmpty(int_type i);
<a name="l01197"></a>01197         <span class="keywordtype">void</span> multi_merge_k(Element * to, int_type l);
<a name="l01198"></a>01198         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> LogK&gt;
<a name="l01199"></a>01199         <span class="keywordtype">void</span> multi_merge_f(Element * to, int_type l)
<a name="l01200"></a>01200         {
<a name="l01201"></a>01201             <span class="comment">//Entry *currentPos;</span>
<a name="l01202"></a>01202             <span class="comment">//Element currentKey;</span>
<a name="l01203"></a>01203             <span class="comment">//int currentIndex; // leaf pointed to by current entry</span>
<a name="l01204"></a>01204             Element * done = to + l;
<a name="l01205"></a>01205             Entry * regEntry   = entry;
<a name="l01206"></a>01206             Element * * regCurrent = current;
<a name="l01207"></a>01207             int_type winnerIndex = regEntry[0].index;
<a name="l01208"></a>01208             Element winnerKey   = regEntry[0].key;
<a name="l01209"></a>01209             Element * winnerPos;
<a name="l01210"></a>01210             <span class="comment">//Element sup = dummy; // supremum</span>
<a name="l01211"></a>01211 
<a name="l01212"></a>01212             assert(logK &gt;= LogK);
<a name="l01213"></a>01213             <span class="keywordflow">while</span> (to != done)
<a name="l01214"></a>01214             {
<a name="l01215"></a>01215                 winnerPos = regCurrent[winnerIndex];
<a name="l01216"></a>01216 
<a name="l01217"></a>01217                 <span class="comment">// write result</span>
<a name="l01218"></a>01218                 *to   = winnerKey;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220                 <span class="comment">// advance winner segment</span>
<a name="l01221"></a>01221                 ++winnerPos;
<a name="l01222"></a>01222                 regCurrent[winnerIndex] = winnerPos;
<a name="l01223"></a>01223                 winnerKey = *winnerPos;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225                 <span class="comment">// remove winner segment if empty now</span>
<a name="l01226"></a>01226                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))
<a name="l01227"></a>01227                 {
<a name="l01228"></a>01228                     deallocateSegment(winnerIndex);
<a name="l01229"></a>01229                 }
<a name="l01230"></a>01230                 ++to;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232                 <span class="comment">// update loser tree</span>
<a name="l01233"></a>01233 <span class="preprocessor">#define TreeStep(L)\</span>
<a name="l01234"></a>01234 <span class="preprocessor">    if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) { \</span>
<a name="l01235"></a>01235 <span class="preprocessor">        Entry * pos ## L = regEntry + ((winnerIndex + (1 &lt;&lt; LogK)) &gt;&gt; (((int (LogK - L) + 1) &gt;= 0) ? ((LogK - L) + 1) : 0)); \</span>
<a name="l01236"></a>01236 <span class="preprocessor">        Element key ## L = pos ## L-&gt;key; \</span>
<a name="l01237"></a>01237 <span class="preprocessor">        if (cmp(winnerKey, key ## L)) { \</span>
<a name="l01238"></a>01238 <span class="preprocessor">            int_type index ## L  = pos ## L-&gt;index; \</span>
<a name="l01239"></a>01239 <span class="preprocessor">            pos ## L-&gt;key   = winnerKey; \</span>
<a name="l01240"></a>01240 <span class="preprocessor">            pos ## L-&gt;index = winnerIndex; \</span>
<a name="l01241"></a>01241 <span class="preprocessor">            winnerKey     = key ## L; \</span>
<a name="l01242"></a>01242 <span class="preprocessor">            winnerIndex   = index ## L; \</span>
<a name="l01243"></a>01243 <span class="preprocessor">        } \</span>
<a name="l01244"></a>01244 <span class="preprocessor">    }</span>
<a name="l01245"></a>01245 <span class="preprocessor"></span>                TreeStep(10);
<a name="l01246"></a>01246                 TreeStep(9);
<a name="l01247"></a>01247                 TreeStep(8);
<a name="l01248"></a>01248                 TreeStep(7);
<a name="l01249"></a>01249                 TreeStep(6);
<a name="l01250"></a>01250                 TreeStep(5);
<a name="l01251"></a>01251                 TreeStep(4);
<a name="l01252"></a>01252                 TreeStep(3);
<a name="l01253"></a>01253                 TreeStep(2);
<a name="l01254"></a>01254                 TreeStep(1);
<a name="l01255"></a>01255 <span class="preprocessor">#undef TreeStep</span>
<a name="l01256"></a>01256 <span class="preprocessor"></span>            }
<a name="l01257"></a>01257             regEntry[0].index = winnerIndex;
<a name="l01258"></a>01258             regEntry[0].key   = winnerKey;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     <span class="keyword">public</span>:
<a name="l01262"></a>01262         <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l01263"></a>01263         {
<a name="l01264"></a>01264             <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a));
<a name="l01265"></a>01265         }
<a name="l01266"></a>01266         <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l01267"></a>01267         {
<a name="l01268"></a>01268             <span class="keywordflow">return</span> cmp(cmp.min_value(), a);
<a name="l01269"></a>01269         }
<a name="l01270"></a>01270     <span class="keyword">private</span>:
<a name="l01271"></a>01271         loser_tree &amp; operator = (<span class="keyword">const</span> loser_tree &amp;); <span class="comment">// forbidden</span>
<a name="l01272"></a>01272         loser_tree(<span class="keyword">const</span> loser_tree &amp;); <span class="comment">// forbidden</span>
<a name="l01273"></a>01273     <span class="keyword">public</span>:
<a name="l01274"></a>01274         loser_tree();
<a name="l01275"></a>01275         ~loser_tree();
<a name="l01276"></a>01276         <span class="keywordtype">void</span> init();
<a name="l01277"></a>01277 
<a name="l01278"></a>01278         <span class="keywordtype">void</span> swap(loser_tree &amp; obj)
<a name="l01279"></a>01279         {
<a name="l01280"></a>01280             std::swap(cmp, obj.cmp);
<a name="l01281"></a>01281             swap_1D_arrays(empty, obj.empty, KNKMAX);
<a name="l01282"></a>01282             std::swap(lastFree, obj.lastFree);
<a name="l01283"></a>01283             std::swap(size_, obj.size_);
<a name="l01284"></a>01284             std::swap(logK, obj.logK);
<a name="l01285"></a>01285             std::swap(k, obj.k);
<a name="l01286"></a>01286             std::swap(dummy, obj.dummy);
<a name="l01287"></a>01287             swap_1D_arrays(entry, obj.entry, KNKMAX);
<a name="l01288"></a>01288             swap_1D_arrays(current, obj.current, KNKMAX);
<a name="l01289"></a>01289             swap_1D_arrays(segment, obj.segment, KNKMAX);
<a name="l01290"></a>01290             swap_1D_arrays(segment_size, obj.segment_size, KNKMAX);
<a name="l01291"></a>01291             std::swap(mem_cons_, obj.mem_cons_);
<a name="l01292"></a>01292         }
<a name="l01293"></a>01293 
<a name="l01294"></a>01294         <span class="keywordtype">void</span> multi_merge(Element * begin, Element * end)
<a name="l01295"></a>01295         {
<a name="l01296"></a>01296             multi_merge(begin, end - begin);
<a name="l01297"></a>01297         }
<a name="l01298"></a>01298         <span class="keywordtype">void</span> multi_merge(Element *, unsigned_type l);
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         unsigned_type mem_cons()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mem_cons_; }
<a name="l01301"></a>01301         <span class="keywordtype">bool</span> spaceIsAvailable() <span class="comment">// for new segment</span>
<a name="l01302"></a>01302         { <span class="keywordflow">return</span> k &lt; KNKMAX || lastFree &gt;= 0; }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         <span class="keywordtype">void</span> insert_segment(Element * to, unsigned_type sz); <span class="comment">// insert segment beginning at to</span>
<a name="l01305"></a>01305         unsigned_type size() { <span class="keywordflow">return</span> size_; }
<a name="l01306"></a>01306     };
<a name="l01307"></a>01307 
<a name="l01309"></a>01309     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01310"></a>01310     loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::loser_tree() : lastFree(0), size_(0), logK(0), k(1), mem_cons_(0)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312         empty  [0] = 0;
<a name="l01313"></a>01313         segment[0] = 0;
<a name="l01314"></a>01314         current[0] = &amp;dummy;
<a name="l01315"></a>01315         <span class="comment">// entry and dummy are initialized by init</span>
<a name="l01316"></a>01316         <span class="comment">// since they need the value of supremum</span>
<a name="l01317"></a>01317         init();
<a name="l01318"></a>01318     }
<a name="l01319"></a>01319 
<a name="l01320"></a>01320     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01321"></a>01321     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::init()
<a name="l01322"></a>01322     {
<a name="l01323"></a>01323         dummy      = cmp.min_value();
<a name="l01324"></a>01324         rebuildLooserTree();
<a name="l01325"></a>01325         assert(current[entry[0].index] == &amp;dummy);
<a name="l01326"></a>01326     }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 
<a name="l01329"></a>01329 <span class="comment">// rebuild loser tree information from the values in current</span>
<a name="l01330"></a>01330     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01331"></a>01331     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::rebuildLooserTree()
<a name="l01332"></a>01332     {
<a name="l01333"></a>01333         int_type winner = initWinner(1);
<a name="l01334"></a>01334         entry[0].index = winner;
<a name="l01335"></a>01335         entry[0].key   = *(current[winner]);
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 <span class="comment">// given any values in the leaves this</span>
<a name="l01340"></a>01340 <span class="comment">// routing recomputes upper levels of the tree</span>
<a name="l01341"></a>01341 <span class="comment">// from scratch in linear time</span>
<a name="l01342"></a>01342 <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
<a name="l01343"></a>01343 <span class="comment">// return winner index</span>
<a name="l01344"></a>01344     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01345"></a>01345     int_type loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::initWinner(int_type root)
<a name="l01346"></a>01346     {
<a name="l01347"></a>01347         <span class="keywordflow">if</span> (root &gt;= int_type(k)) { <span class="comment">// leaf reached</span>
<a name="l01348"></a>01348             <span class="keywordflow">return</span> root - k;
<a name="l01349"></a>01349         } <span class="keywordflow">else</span> {
<a name="l01350"></a>01350             int_type left  = initWinner(2 * root    );
<a name="l01351"></a>01351             int_type right = initWinner(2 * root + 1);
<a name="l01352"></a>01352             Element lk    = *(current[left ]);
<a name="l01353"></a>01353             Element rk    = *(current[right]);
<a name="l01354"></a>01354             <span class="keywordflow">if</span> (!(cmp(lk, rk))) { <span class="comment">// right subtree looses</span>
<a name="l01355"></a>01355                 entry[root].index = right;
<a name="l01356"></a>01356                 entry[root].key   = rk;
<a name="l01357"></a>01357                 <span class="keywordflow">return</span> left;
<a name="l01358"></a>01358             } <span class="keywordflow">else</span> {
<a name="l01359"></a>01359                 entry[root].index = left;
<a name="l01360"></a>01360                 entry[root].key   = lk;
<a name="l01361"></a>01361                 <span class="keywordflow">return</span> right;
<a name="l01362"></a>01362             }
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 <span class="comment">// first go up the tree all the way to the root</span>
<a name="l01368"></a>01368 <span class="comment">// hand down old winner for the respective subtree</span>
<a name="l01369"></a>01369 <span class="comment">// based on new value, and old winner and loser</span>
<a name="l01370"></a>01370 <span class="comment">// update each node on the path to the root top down.</span>
<a name="l01371"></a>01371 <span class="comment">// This is implemented recursively</span>
<a name="l01372"></a>01372     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01373"></a>01373     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::updateOnInsert(
<a name="l01374"></a>01374         int_type node,
<a name="l01375"></a>01375         <span class="keyword">const</span> Element &amp; newKey,
<a name="l01376"></a>01376         int_type newIndex,
<a name="l01377"></a>01377         Element * winnerKey,
<a name="l01378"></a>01378         int_type * winnerIndex,       <span class="comment">// old winner</span>
<a name="l01379"></a>01379         int_type * mask)       <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
<a name="l01380"></a>01380     {
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (node == 0) { <span class="comment">// winner part of root</span>
<a name="l01382"></a>01382             *mask = 1 &lt;&lt; (logK - 1);
<a name="l01383"></a>01383             *winnerKey   = entry[0].key;
<a name="l01384"></a>01384             *winnerIndex = entry[0].index;
<a name="l01385"></a>01385             <span class="keywordflow">if</span> (cmp(entry[node].key, newKey))
<a name="l01386"></a>01386             {
<a name="l01387"></a>01387                 entry[node].key   = newKey;
<a name="l01388"></a>01388                 entry[node].index = newIndex;
<a name="l01389"></a>01389             }
<a name="l01390"></a>01390         } <span class="keywordflow">else</span> {
<a name="l01391"></a>01391             updateOnInsert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
<a name="l01392"></a>01392             Element loserKey   = entry[node].key;
<a name="l01393"></a>01393             int_type loserIndex = entry[node].index;
<a name="l01394"></a>01394             <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
<a name="l01395"></a>01395                 <span class="keywordflow">if</span> (cmp(loserKey, newKey)) { <span class="comment">// newKey will have influence here</span>
<a name="l01396"></a>01396                     <span class="keywordflow">if</span> (cmp(*winnerKey, newKey) ) { <span class="comment">// old winner loses here</span>
<a name="l01397"></a>01397                         entry[node].key   = *winnerKey;
<a name="l01398"></a>01398                         entry[node].index = *winnerIndex;
<a name="l01399"></a>01399                     } <span class="keywordflow">else</span> { <span class="comment">// new entry looses here</span>
<a name="l01400"></a>01400                         entry[node].key   = newKey;
<a name="l01401"></a>01401                         entry[node].index = newIndex;
<a name="l01402"></a>01402                     }
<a name="l01403"></a>01403                 }
<a name="l01404"></a>01404                 *winnerKey   = loserKey;
<a name="l01405"></a>01405                 *winnerIndex = loserIndex;
<a name="l01406"></a>01406             }
<a name="l01407"></a>01407             <span class="comment">// note that nothing needs to be done if</span>
<a name="l01408"></a>01408             <span class="comment">// the winner came from the same subtree</span>
<a name="l01409"></a>01409             <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to loose</span>
<a name="l01410"></a>01410             <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
<a name="l01411"></a>01411             <span class="comment">//                           entry further down the tree</span>
<a name="l01412"></a>01412             <span class="comment">// also the same old winner is handed down the tree</span>
<a name="l01413"></a>01413 
<a name="l01414"></a>01414             *mask &gt;&gt;= 1; <span class="comment">// next level</span>
<a name="l01415"></a>01415         }
<a name="l01416"></a>01416     }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 <span class="comment">// make the tree two times as wide</span>
<a name="l01420"></a>01420 <span class="comment">// may only be called if no free slots are left ?? necessary ??</span>
<a name="l01421"></a>01421     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01422"></a>01422     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::doubleK()
<a name="l01423"></a>01423     {
<a name="l01424"></a>01424         <span class="comment">// make all new entries empty</span>
<a name="l01425"></a>01425         <span class="comment">// and push them on the free stack</span>
<a name="l01426"></a>01426         assert(lastFree == -1); <span class="comment">// stack was empty (probably not needed)</span>
<a name="l01427"></a>01427         assert(k &lt; KNKMAX);
<a name="l01428"></a>01428         <span class="keywordflow">for</span> (int_type i = 2 * k - 1;  i &gt;= int_type(k);  i--)
<a name="l01429"></a>01429         {
<a name="l01430"></a>01430             current[i] = &amp;dummy;
<a name="l01431"></a>01431             segment[i] = NULL;
<a name="l01432"></a>01432             lastFree++;
<a name="l01433"></a>01433             empty[lastFree] = i;
<a name="l01434"></a>01434         }
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         <span class="comment">// double the size</span>
<a name="l01437"></a>01437         k *= 2;
<a name="l01438"></a>01438         logK++;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         <span class="comment">// recompute loser tree information</span>
<a name="l01441"></a>01441         rebuildLooserTree();
<a name="l01442"></a>01442     }
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="comment">// compact nonempty segments in the left half of the tree</span>
<a name="l01446"></a>01446     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01447"></a>01447     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::compactTree()
<a name="l01448"></a>01448     {
<a name="l01449"></a>01449         assert(logK &gt; 0);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451         <span class="comment">// compact all nonempty segments to the left</span>
<a name="l01452"></a>01452         int_type from = 0;
<a name="l01453"></a>01453         int_type to   = 0;
<a name="l01454"></a>01454         <span class="keywordflow">for</span> ( ;  from &lt; int_type(k);  from++)
<a name="l01455"></a>01455         {
<a name="l01456"></a>01456             <span class="keywordflow">if</span> (not_sentinel(*(current[from])))
<a name="l01457"></a>01457             {
<a name="l01458"></a>01458                 segment_size[to] = segment_size[from];
<a name="l01459"></a>01459                 current[to] = current[from];
<a name="l01460"></a>01460                 segment[to] = segment[from];
<a name="l01461"></a>01461                 to++;
<a name="l01462"></a>01462             }<span class="comment">/*</span>
<a name="l01463"></a>01463 <span class="comment">                else</span>
<a name="l01464"></a>01464 <span class="comment">                {</span>
<a name="l01465"></a>01465 <span class="comment">                if(segment[from])</span>
<a name="l01466"></a>01466 <span class="comment">                {</span>
<a name="l01467"></a>01467 <span class="comment">                STXXL_VERBOSE2("loser_tree::compactTree() deleting segment "&lt;&lt;from&lt;&lt;</span>
<a name="l01468"></a>01468 <span class="comment">                                        " address: "&lt;&lt;segment[from]&lt;&lt;" size: "&lt;&lt;segment_size[from]);</span>
<a name="l01469"></a>01469 <span class="comment">                delete [] segment[from];</span>
<a name="l01470"></a>01470 <span class="comment">                segment[from] = 0;</span>
<a name="l01471"></a>01471 <span class="comment">                mem_cons_ -= segment_size[from];</span>
<a name="l01472"></a>01472 <span class="comment">                }</span>
<a name="l01473"></a>01473 <span class="comment">                }*/</span>
<a name="l01474"></a>01474         }
<a name="l01475"></a>01475 
<a name="l01476"></a>01476         <span class="comment">// half degree as often as possible</span>
<a name="l01477"></a>01477         <span class="keywordflow">while</span> (to &lt; int_type(k / 2)) {
<a name="l01478"></a>01478             k /= 2;
<a name="l01479"></a>01479             logK--;
<a name="l01480"></a>01480         }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482         <span class="comment">// overwrite garbage and compact the stack of empty segments</span>
<a name="l01483"></a>01483         lastFree = -1; <span class="comment">// none free</span>
<a name="l01484"></a>01484         <span class="keywordflow">for</span> ( ;  to &lt; int_type(k);  to++) {
<a name="l01485"></a>01485             <span class="comment">// push</span>
<a name="l01486"></a>01486             lastFree++;
<a name="l01487"></a>01487             empty[lastFree] = to;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489             current[to] = &amp;dummy;
<a name="l01490"></a>01490         }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492         <span class="comment">// recompute loser tree information</span>
<a name="l01493"></a>01493         rebuildLooserTree();
<a name="l01494"></a>01494     }
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 
<a name="l01497"></a>01497 <span class="comment">// insert segment beginning at to</span>
<a name="l01498"></a>01498 <span class="comment">// require: spaceIsAvailable() == 1</span>
<a name="l01499"></a>01499     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01500"></a>01500     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::insert_segment(Element * to, unsigned_type sz)
<a name="l01501"></a>01501     {
<a name="l01502"></a>01502         STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::insert_segment("</span> &lt;&lt; to &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l01503"></a>01503         <span class="comment">//std::copy(to,to + sz,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
<a name="l01504"></a>01504 
<a name="l01505"></a>01505         <span class="keywordflow">if</span> (sz &gt; 0)
<a name="l01506"></a>01506         {
<a name="l01507"></a>01507             assert( not_sentinel(to[0])   );
<a name="l01508"></a>01508             assert( not_sentinel(to[sz - 1]));
<a name="l01509"></a>01509             <span class="comment">// get a free slot</span>
<a name="l01510"></a>01510             <span class="keywordflow">if</span> (lastFree &lt; 0) { <span class="comment">// tree is too small</span>
<a name="l01511"></a>01511                 doubleK();
<a name="l01512"></a>01512             }
<a name="l01513"></a>01513             int_type index = empty[lastFree];
<a name="l01514"></a>01514             lastFree--; <span class="comment">// pop</span>
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 
<a name="l01517"></a>01517             <span class="comment">// link new segment</span>
<a name="l01518"></a>01518             current[index] = segment[index] = to;
<a name="l01519"></a>01519             segment_size[index] = (sz + 1) * <span class="keyword">sizeof</span>(value_type);
<a name="l01520"></a>01520             mem_cons_ += (sz + 1) * <span class="keyword">sizeof</span>(value_type);
<a name="l01521"></a>01521             size_ += sz;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523             <span class="comment">// propagate new information up the tree</span>
<a name="l01524"></a>01524             Element dummyKey;
<a name="l01525"></a>01525             int_type dummyIndex;
<a name="l01526"></a>01526             int_type dummyMask;
<a name="l01527"></a>01527             updateOnInsert((index + k) &gt;&gt; 1, *to, index,
<a name="l01528"></a>01528                            &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
<a name="l01529"></a>01529         } <span class="keywordflow">else</span> {
<a name="l01530"></a>01530             <span class="comment">// immediately deallocate</span>
<a name="l01531"></a>01531             <span class="comment">// this is not only an optimization</span>
<a name="l01532"></a>01532             <span class="comment">// but also needed to keep empty segments from</span>
<a name="l01533"></a>01533             <span class="comment">// clogging up the tree</span>
<a name="l01534"></a>01534             <span class="keyword">delete</span> [] to;
<a name="l01535"></a>01535         }
<a name="l01536"></a>01536     }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01540"></a>01540     loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::~loser_tree()
<a name="l01541"></a>01541     {
<a name="l01542"></a>01542         STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::~loser_tree()"</span>);
<a name="l01543"></a>01543         <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; k; ++i)
<a name="l01544"></a>01544         {
<a name="l01545"></a>01545             <span class="keywordflow">if</span> (segment[i])
<a name="l01546"></a>01546             {
<a name="l01547"></a>01547                 STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::~loser_tree() deleting segment "</span> &lt;&lt; i);
<a name="l01548"></a>01548                 <span class="keyword">delete</span> [] segment[i];
<a name="l01549"></a>01549                 mem_cons_ -= segment_size[i];
<a name="l01550"></a>01550             }
<a name="l01551"></a>01551         }
<a name="l01552"></a>01552         <span class="comment">// check whether we did not loose memory</span>
<a name="l01553"></a>01553         assert(mem_cons_ == 0);
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 <span class="comment">// free an empty segment .</span>
<a name="l01557"></a>01557     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01558"></a>01558     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::deallocateSegment(int_type index)
<a name="l01559"></a>01559     {
<a name="l01560"></a>01560         <span class="comment">// reroute current pointer to some empty dummy segment</span>
<a name="l01561"></a>01561         <span class="comment">// with a sentinel key</span>
<a name="l01562"></a>01562         STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::deallocateSegment() deleting segment "</span> &lt;&lt;
<a name="l01563"></a>01563                        index &lt;&lt; <span class="stringliteral">" address: "</span> &lt;&lt; segment[index] &lt;&lt; <span class="stringliteral">" size: "</span> &lt;&lt; segment_size[index]);
<a name="l01564"></a>01564         current[index] = &amp;dummy;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566         <span class="comment">// free memory</span>
<a name="l01567"></a>01567         <span class="keyword">delete</span> [] segment[index];
<a name="l01568"></a>01568         segment[index] = 0;
<a name="l01569"></a>01569         mem_cons_ -= segment_size[index];
<a name="l01570"></a>01570 
<a name="l01571"></a>01571         <span class="comment">// push on the stack of free segment indices</span>
<a name="l01572"></a>01572         lastFree++;
<a name="l01573"></a>01573         empty[lastFree] = index;
<a name="l01574"></a>01574     }
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="comment">// delete the l smallest elements and write them to "to"</span>
<a name="l01578"></a>01578 <span class="comment">// empty segments are deallocated</span>
<a name="l01579"></a>01579 <span class="comment">// require:</span>
<a name="l01580"></a>01580 <span class="comment">// - there are at least l elements</span>
<a name="l01581"></a>01581 <span class="comment">// - segments are ended by sentinels</span>
<a name="l01582"></a>01582     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01583"></a>01583     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::multi_merge(Element * to, unsigned_type l)
<a name="l01584"></a>01584     {
<a name="l01585"></a>01585         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::multi_merge("</span> &lt;&lt; to &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587         <span class="comment">/*</span>
<a name="l01588"></a>01588 <span class="comment">           multi_merge_k(to,l);</span>
<a name="l01589"></a>01589 <span class="comment">         */</span>
<a name="l01590"></a>01590         <span class="keywordflow">switch</span> (logK) {
<a name="l01591"></a>01591         <span class="keywordflow">case</span> 0:
<a name="l01592"></a>01592             assert(k == 1);
<a name="l01593"></a>01593             assert(entry[0].index == 0);
<a name="l01594"></a>01594             assert(lastFree == -1 || l == 0);
<a name="l01595"></a>01595             <span class="comment">//memcpy(to, current[0], l * sizeof(Element));</span>
<a name="l01596"></a>01596             std::copy(current[0], current[0] + l, to);
<a name="l01597"></a>01597             current[0] += l;
<a name="l01598"></a>01598             entry[0].key = **current;
<a name="l01599"></a>01599             <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l01600"></a>01600                 deallocateSegment(0);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602             <span class="keywordflow">break</span>;
<a name="l01603"></a>01603         <span class="keywordflow">case</span> 1:
<a name="l01604"></a>01604             assert(k == 2);
<a name="l01605"></a>01605             merge(current + 0, current + 1, to, l, cmp);
<a name="l01606"></a>01606             rebuildLooserTree();
<a name="l01607"></a>01607             <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l01608"></a>01608                 deallocateSegment(0);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610             <span class="keywordflow">if</span> (segmentIsEmpty(1))
<a name="l01611"></a>01611                 deallocateSegment(1);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613             <span class="keywordflow">break</span>;
<a name="l01614"></a>01614         <span class="keywordflow">case</span> 2:
<a name="l01615"></a>01615             assert(k == 4);
<a name="l01616"></a>01616             merge4(current + 0, current + 1, current + 2, current + 3, to, l, cmp);
<a name="l01617"></a>01617             rebuildLooserTree();
<a name="l01618"></a>01618             <span class="keywordflow">if</span> (segmentIsEmpty(0))
<a name="l01619"></a>01619                 deallocateSegment(0);
<a name="l01620"></a>01620 
<a name="l01621"></a>01621             <span class="keywordflow">if</span> (segmentIsEmpty(1))
<a name="l01622"></a>01622                 deallocateSegment(1);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624             <span class="keywordflow">if</span> (segmentIsEmpty(2))
<a name="l01625"></a>01625                 deallocateSegment(2);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627             <span class="keywordflow">if</span> (segmentIsEmpty(3))
<a name="l01628"></a>01628                 deallocateSegment(3);
<a name="l01629"></a>01629 
<a name="l01630"></a>01630             <span class="keywordflow">break</span>;
<a name="l01631"></a>01631         <span class="keywordflow">case</span>  3: multi_merge_f &lt; 3 &gt; (to, l);
<a name="l01632"></a>01632             <span class="keywordflow">break</span>;
<a name="l01633"></a>01633         <span class="keywordflow">case</span>  4: multi_merge_f &lt; 4 &gt; (to, l);
<a name="l01634"></a>01634             <span class="keywordflow">break</span>;
<a name="l01635"></a>01635         <span class="keywordflow">case</span>  5: multi_merge_f &lt; 5 &gt; (to, l);
<a name="l01636"></a>01636             <span class="keywordflow">break</span>;
<a name="l01637"></a>01637         <span class="keywordflow">case</span>  6: multi_merge_f &lt; 6 &gt; (to, l);
<a name="l01638"></a>01638             <span class="keywordflow">break</span>;
<a name="l01639"></a>01639         <span class="keywordflow">case</span>  7: multi_merge_f &lt; 7 &gt; (to, l);
<a name="l01640"></a>01640             <span class="keywordflow">break</span>;
<a name="l01641"></a>01641         <span class="keywordflow">case</span>  8: multi_merge_f &lt; 8 &gt; (to, l);
<a name="l01642"></a>01642             <span class="keywordflow">break</span>;
<a name="l01643"></a>01643         <span class="keywordflow">case</span>  9: multi_merge_f &lt; 9 &gt; (to, l);
<a name="l01644"></a>01644             <span class="keywordflow">break</span>;
<a name="l01645"></a>01645         <span class="keywordflow">case</span> 10: multi_merge_f &lt; 10 &gt; (to, l);
<a name="l01646"></a>01646             <span class="keywordflow">break</span>;
<a name="l01647"></a>01647         <span class="keywordflow">default</span>: multi_merge_k(to, l);
<a name="l01648"></a>01648             <span class="keywordflow">break</span>;
<a name="l01649"></a>01649         }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 
<a name="l01653"></a>01653         size_ -= l;
<a name="l01654"></a>01654 
<a name="l01655"></a>01655         <span class="comment">// compact tree if it got considerably smaller</span>
<a name="l01656"></a>01656         <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; int_type(lastFree) &gt;= int_type(3 * k / 5 - 1) ) {
<a name="l01657"></a>01657             <span class="comment">// using k/2 would be worst case inefficient</span>
<a name="l01658"></a>01658             compactTree();
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660         <span class="comment">//std::copy(to,to + l,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
<a name="l01661"></a>01661     }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 <span class="comment">// is this segment empty and does not point to dummy yet?</span>
<a name="l01665"></a>01665     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01666"></a>01666     <span class="keyword">inline</span> <span class="keywordtype">bool</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::segmentIsEmpty(int_type i)
<a name="l01667"></a>01667     {
<a name="l01668"></a>01668         <span class="keywordflow">return</span> (is_sentinel(*(current[i])) &amp;&amp; (current[i] != &amp;dummy));
<a name="l01669"></a>01669     }
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 <span class="comment">// multi-merge for fixed K</span>
<a name="l01672"></a>01672 <span class="comment">/*</span>
<a name="l01673"></a>01673 <span class="comment">   template &lt;class ValTp_,class Cmp_,unsigned KNKMAX&gt; template &lt;unsigned LogK&gt;</span>
<a name="l01674"></a>01674 <span class="comment">   void loser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::multi_merge_f&lt;LogK&gt;(Element *to, int_type l)</span>
<a name="l01675"></a>01675 <span class="comment">   {</span>
<a name="l01676"></a>01676 <span class="comment">   }</span>
<a name="l01677"></a>01677 <span class="comment"> */</span>
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="comment">// multi-merge for arbitrary K</span>
<a name="l01680"></a>01680     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01681"></a>01681     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::
<a name="l01682"></a>01682     multi_merge_k(Element * to, int_type l)
<a name="l01683"></a>01683     {
<a name="l01684"></a>01684         Entry * currentPos;
<a name="l01685"></a>01685         Element currentKey;
<a name="l01686"></a>01686         int_type currentIndex; <span class="comment">// leaf pointed to by current entry</span>
<a name="l01687"></a>01687         int_type kReg = k;
<a name="l01688"></a>01688         Element * done = to + l;
<a name="l01689"></a>01689         int_type winnerIndex = entry[0].index;
<a name="l01690"></a>01690         Element winnerKey   = entry[0].key;
<a name="l01691"></a>01691         Element * winnerPos;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">while</span> (to != done)
<a name="l01694"></a>01694         {
<a name="l01695"></a>01695             winnerPos = current[winnerIndex];
<a name="l01696"></a>01696 
<a name="l01697"></a>01697             <span class="comment">// write result</span>
<a name="l01698"></a>01698             *to   = winnerKey;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700             <span class="comment">// advance winner segment</span>
<a name="l01701"></a>01701             ++winnerPos;
<a name="l01702"></a>01702             current[winnerIndex] = winnerPos;
<a name="l01703"></a>01703             winnerKey = *winnerPos;
<a name="l01704"></a>01704 
<a name="l01705"></a>01705             <span class="comment">// remove winner segment if empty now</span>
<a name="l01706"></a>01706             <span class="keywordflow">if</span> (is_sentinel(winnerKey))  <span class="comment">//</span>
<a name="l01707"></a>01707                 deallocateSegment(winnerIndex);
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 
<a name="l01710"></a>01710             <span class="comment">// go up the entry-tree</span>
<a name="l01711"></a>01711             <span class="keywordflow">for</span> (int_type i = (winnerIndex + kReg) &gt;&gt; 1;  i &gt; 0;  i &gt;&gt;= 1) {
<a name="l01712"></a>01712                 currentPos = entry + i;
<a name="l01713"></a>01713                 currentKey = currentPos-&gt;key;
<a name="l01714"></a>01714                 <span class="keywordflow">if</span> (cmp(winnerKey, currentKey)) {
<a name="l01715"></a>01715                     currentIndex      = currentPos-&gt;index;
<a name="l01716"></a>01716                     currentPos-&gt;key   = winnerKey;
<a name="l01717"></a>01717                     currentPos-&gt;index = winnerIndex;
<a name="l01718"></a>01718                     winnerKey         = currentKey;
<a name="l01719"></a>01719                     winnerIndex       = currentIndex;
<a name="l01720"></a>01720                 }
<a name="l01721"></a>01721             }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723             ++to;
<a name="l01724"></a>01724         }
<a name="l01725"></a>01725         entry[0].index = winnerIndex;
<a name="l01726"></a>01726         entry[0].key   = winnerKey;
<a name="l01727"></a>01727     }
<a name="l01728"></a>01728 }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 <span class="comment">/*</span>
<a name="l01731"></a>01731 <span class="comment"></span>
<a name="l01732"></a>01732 <span class="comment">   KNBufferSize1 = 32;</span>
<a name="l01733"></a>01733 <span class="comment">   KNN = 512; // bandwidth</span>
<a name="l01734"></a>01734 <span class="comment">   KNKMAX = 64;  // maximal arity</span>
<a name="l01735"></a>01735 <span class="comment">   KNLevels = 4; // overall capacity &gt;= KNN*KNKMAX^KNLevels</span>
<a name="l01736"></a>01736 <span class="comment">   LogKNKMAX = 6;  // ceil(log KNK)</span>
<a name="l01737"></a>01737 <span class="comment"> */</span>
<a name="l01738"></a>01738 
<a name="l01739"></a>01739 <span class="comment">// internal memory consumption &gt;= N_*(KMAX_^Levels_) + ext</span>
<a name="l01740"></a>01740 
<a name="l01741"></a>01741 <span class="keyword">template</span> &lt;
<a name="l01742"></a>01742           <span class="keyword">class </span>Tp_,
<a name="l01743"></a>01743           <span class="keyword">class </span>Cmp_,
<a name="l01744"></a>01744           <span class="keywordtype">unsigned</span> BufferSize1_ = 32, <span class="comment">// equalize procedure call overheads etc.</span>
<a name="l01745"></a>01745           <span class="keywordtype">unsigned</span> N_ = 512, <span class="comment">// bandwidth</span>
<a name="l01746"></a>01746           <span class="keywordtype">unsigned</span> IntKMAX_ = 64, <span class="comment">// maximal arity for internal mergers</span>
<a name="l01747"></a>01747           <span class="keywordtype">unsigned</span> IntLevels_ = 4,
<a name="l01748"></a>01748           <span class="keywordtype">unsigned</span> BlockSize_ = (2 * 1024 * 1024),
<a name="l01749"></a>01749           <span class="keywordtype">unsigned</span> ExtKMAX_ = 64, <span class="comment">// maximal arity for external mergers</span>
<a name="l01750"></a>01750           <span class="keywordtype">unsigned</span> ExtLevels_ = 2,
<a name="l01751"></a>01751           <span class="keyword">class</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY
<a name="l01752"></a>01752 &gt;
<a name="l01753"></a>01753 <span class="keyword">struct</span> priority_queue_config
<a name="l01754"></a>01754 {
<a name="l01755"></a>01755     <span class="keyword">typedef</span> Tp_ value_type;
<a name="l01756"></a>01756     <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l01757"></a>01757     <span class="keyword">typedef</span> AllocStr_ alloc_strategy_type;
<a name="l01758"></a>01758     <span class="keyword">enum</span>
<a name="l01759"></a>01759     {
<a name="l01760"></a>01760         BufferSize1 = BufferSize1_,
<a name="l01761"></a>01761         N = N_,
<a name="l01762"></a>01762         IntKMAX = IntKMAX_,
<a name="l01763"></a>01763         IntLevels = IntLevels_,
<a name="l01764"></a>01764         ExtLevels = ExtLevels_,
<a name="l01765"></a>01765         BlockSize = BlockSize_,
<a name="l01766"></a>01766         ExtKMAX = ExtKMAX_
<a name="l01767"></a>01767     };
<a name="l01768"></a>01768 };
<a name="l01769"></a>01769 
<a name="l01770"></a>01770 __STXXL_END_NAMESPACE
<a name="l01771"></a>01771 
<a name="l01772"></a>01772 <span class="keyword">namespace </span>std
<a name="l01773"></a>01773 {
<a name="l01774"></a>01774     <span class="keyword">template</span> &lt;  <span class="keyword">class </span>BlockType_,
<a name="l01775"></a>01775               <span class="keyword">class </span>Cmp_,
<a name="l01776"></a>01776               <span class="keywordtype">unsigned</span> Arity_,
<a name="l01777"></a>01777               <span class="keyword">class </span>AllocStr_ &gt;
<a name="l01778"></a>01778     <span class="keywordtype">void</span> swap(stxxl::priority_queue_local::ext_merger &lt; BlockType_, Cmp_, Arity_, AllocStr_ &gt; &amp; a,
<a name="l01779"></a>01779               stxxl::priority_queue_local::ext_merger&lt;BlockType_, Cmp_, Arity_, AllocStr_&gt; &amp; b )
<a name="l01780"></a>01780     {
<a name="l01781"></a>01781         a.swap(b);
<a name="l01782"></a>01782     }
<a name="l01783"></a>01783     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01784"></a>01784     <span class="keywordtype">void</span> swap(      stxxl::priority_queue_local::loser_tree &lt; ValTp_, Cmp_, KNKMAX &gt; &amp; a,
<a name="l01785"></a>01785                     stxxl::priority_queue_local::loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt; &amp; b)
<a name="l01786"></a>01786     {
<a name="l01787"></a>01787         a.swap(b);
<a name="l01788"></a>01788     }
<a name="l01789"></a>01789 }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 __STXXL_BEGIN_NAMESPACE
<a name="l01792"></a>01792 
<a name="l01794"></a>01794 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01795"></a><a class="code" href="classpriority__queue.html">01795</a> <span class="keyword">class </span><a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>
<a name="l01796"></a>01796 {
<a name="l01797"></a>01797 <span class="keyword">public</span>:
<a name="l01798"></a>01798     <span class="keyword">typedef</span> Config_ Config;
<a name="l01799"></a>01799     <span class="keyword">enum</span>
<a name="l01800"></a>01800     {
<a name="l01801"></a>01801         BufferSize1 = Config::BufferSize1,
<a name="l01802"></a>01802         N = Config::N,
<a name="l01803"></a>01803         IntKMAX = Config::IntKMAX,
<a name="l01804"></a>01804         IntLevels = Config::IntLevels,
<a name="l01805"></a>01805         ExtLevels = Config::ExtLevels,
<a name="l01806"></a>01806         Levels = Config::IntLevels + Config::ExtLevels,
<a name="l01807"></a>01807         BlockSize = Config::BlockSize,
<a name="l01808"></a>01808         ExtKMAX = Config::ExtKMAX
<a name="l01809"></a>01809     };
<a name="l01810"></a>01810 
<a name="l01812"></a><a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396">01812</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_type value_type;
<a name="l01814"></a><a class="code" href="classpriority__queue.html#aa45436f6af3da8217fbd21502595079">01814</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::comparator_type comparator_type;
<a name="l01815"></a>01815     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::alloc_strategy_type alloc_strategy_type;
<a name="l01817"></a><a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154">01817</a>     <span class="keyword">typedef</span> stxxl::int64 size_type;
<a name="l01818"></a>01818     <span class="keyword">typedef</span> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">typed_block&lt;BlockSize, value_type&gt;</a> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 
<a name="l01821"></a>01821 <span class="keyword">protected</span>:
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     <span class="keyword">typedef</span> std::priority_queue&lt;value_type, std::vector&lt;value_type&gt;, comparator_type&gt;
<a name="l01824"></a>01824     insert_heap_type;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826     <span class="keyword">typedef</span> priority_queue_local::loser_tree&lt;
<a name="l01827"></a>01827                                              value_type,
<a name="l01828"></a>01828                                              comparator_type,
<a name="l01829"></a>01829                                              IntKMAX&gt;  int_merger_type;
<a name="l01830"></a>01830 
<a name="l01831"></a>01831     <span class="keyword">typedef</span> priority_queue_local::ext_merger&lt;
<a name="l01832"></a>01832                                              <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>,
<a name="l01833"></a>01833                                              comparator_type,
<a name="l01834"></a>01834                                              ExtKMAX,
<a name="l01835"></a>01835                                              alloc_strategy_type&gt;   ext_merger_type;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 
<a name="l01838"></a>01838     int_merger_type itree[IntLevels];
<a name="l01839"></a>01839     <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> &amp;p_pool;
<a name="l01840"></a>01840     <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a>    &amp;w_pool;
<a name="l01841"></a>01841     ext_merger_type * etree;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843     <span class="comment">// one delete buffer for each tree (extra space for sentinel)</span>
<a name="l01844"></a>01844     value_type buffer2[Levels][N + 1]; <span class="comment">// tree-&gt;buffer2-&gt;buffer1</span>
<a name="l01845"></a>01845     value_type * minBuffer2[Levels];
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="comment">// overall delete buffer</span>
<a name="l01848"></a>01848     value_type buffer1[BufferSize1 + 1];
<a name="l01849"></a>01849     value_type * minBuffer1;
<a name="l01850"></a>01850 
<a name="l01851"></a>01851     comparator_type cmp;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     <span class="comment">// insert buffer</span>
<a name="l01854"></a>01854     insert_heap_type insertHeap;
<a name="l01855"></a>01855 
<a name="l01856"></a>01856     <span class="comment">// how many levels are active</span>
<a name="l01857"></a>01857     int_type activeLevels;
<a name="l01858"></a>01858 
<a name="l01859"></a>01859     <span class="comment">// total size not counting insertBuffer and buffer1</span>
<a name="l01860"></a>01860     size_type size_;
<a name="l01861"></a>01861     <span class="keywordtype">bool</span> deallocate_pools;
<a name="l01862"></a>01862 
<a name="l01863"></a>01863     <span class="comment">// private member functions</span>
<a name="l01864"></a>01864     <span class="keywordtype">void</span> refillBuffer1();
<a name="l01865"></a>01865     int_type refillBuffer2(int_type k);
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     int_type makeSpaceAvailable(int_type level);
<a name="l01868"></a>01868     <span class="keywordtype">void</span> emptyInsertHeap();
<a name="l01869"></a>01869 
<a name="l01870"></a>01870     value_type getSupremum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp.min_value(); } <span class="comment">//{ return buffer2[0][KNN].key; }</span>
<a name="l01871"></a>01871     int_type getSize1( )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( buffer1 + BufferSize1) - minBuffer1; }
<a name="l01872"></a>01872     int_type getSize2(int_type i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;(buffer2[i][N]) - minBuffer2[i]; }
<a name="l01873"></a>01873 
<a name="l01874"></a>01874 
<a name="l01875"></a>01875     <span class="comment">// forbidden cals</span>
<a name="l01876"></a>01876     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>();
<a name="l01877"></a>01877     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> &amp; operator = (<span class="keyword">const</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> &amp;);
<a name="l01878"></a>01878     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>(<span class="keyword">const</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> &amp; );
<a name="l01879"></a>01879 <span class="keyword">public</span>:
<a name="l01880"></a>01880 
<a name="l01890"></a>01890     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>(prefetch_pool &lt; block_type &gt; &amp; p_pool_, <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> &amp; w_pool_);
<a name="l01891"></a>01891 
<a name="l01901"></a>01901     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>(unsigned_type p_pool_mem, unsigned_type w_pool_mem);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     <span class="keywordtype">void</span> swap(<a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> &amp; obj)
<a name="l01904"></a>01904     {
<a name="l01905"></a>01905         <span class="comment">//swap_1D_arrays(itree,obj.itree,IntLevels); // does not work in g++ 3.4.3 :( bug?</span>
<a name="l01906"></a>01906         <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; IntLevels; ++i)
<a name="l01907"></a>01907             std::swap(itree[i], obj.<a class="code" href="classpriority__queue.html#d97dfe4af63b29dc3758497364d828a3">itree</a>[i]);
<a name="l01908"></a>01908 
<a name="l01909"></a>01909         <span class="comment">// std::swap(p_pool,obj.p_pool);</span>
<a name="l01910"></a>01910         <span class="comment">// std::swap(w_pool,obj.w_pool);</span>
<a name="l01911"></a>01911         std::swap(etree, obj.<a class="code" href="classpriority__queue.html#e728ae1c7645289323313daafe7af956">etree</a>);
<a name="l01912"></a>01912         <span class="keywordflow">for</span> (unsigned_type i1 = 0; i1 &lt; Levels; ++i1)
<a name="l01913"></a>01913             <span class="keywordflow">for</span> (unsigned_type i2 = 0; i2 &lt; (N + 1); ++i2)
<a name="l01914"></a>01914                 std::swap(buffer2[i1][i2], obj.<a class="code" href="classpriority__queue.html#c9a1c0624cbe18c546b9aec6a0a77e96">buffer2</a>[i1][i2]);
<a name="l01915"></a>01915 
<a name="l01916"></a>01916         swap_1D_arrays(minBuffer2, obj.<a class="code" href="classpriority__queue.html#3ba3ff48e228bd7a444d741fe0b9c19a">minBuffer2</a>, Levels);
<a name="l01917"></a>01917         swap_1D_arrays(buffer1, obj.<a class="code" href="classpriority__queue.html#bcdb3ebc9df2ed1678ae9ff8ec4eb519">buffer1</a>, BufferSize1 + 1);
<a name="l01918"></a>01918         std::swap(minBuffer1, obj.<a class="code" href="classpriority__queue.html#6b12870ed2e5c81d9b97ace56058ef90">minBuffer1</a>);
<a name="l01919"></a>01919         std::swap(cmp, obj.<a class="code" href="classpriority__queue.html#716317784bbe8b3b91f0b8baa1863048">cmp</a>);
<a name="l01920"></a>01920         std::swap(insertHeap, obj.<a class="code" href="classpriority__queue.html#8fa67cb48dca3bbe32b1c42605a9724c">insertHeap</a>);
<a name="l01921"></a>01921         std::swap(activeLevels, obj.<a class="code" href="classpriority__queue.html#21ac91d42eb64df0498627f9a0870649">activeLevels</a>);
<a name="l01922"></a>01922         std::swap(size_, obj.<a class="code" href="classpriority__queue.html#9d641577ce43f80c1730880df7439439">size_</a>);
<a name="l01923"></a>01923         <span class="comment">//std::swap(deallocate_pools,obj.deallocate_pools);</span>
<a name="l01924"></a>01924     }
<a name="l01925"></a>01925 
<a name="l01926"></a>01926     <span class="keyword">virtual</span> ~<a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>();
<a name="l01927"></a>01927 
<a name="l01930"></a>01930     size_type size() <span class="keyword">const</span>;
<a name="l01931"></a>01931 
<a name="l01934"></a><a class="code" href="classpriority__queue.html#32bfb3d2f08e07fbe4aed7fa58de1f5b">01934</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (size() == 0); }
<a name="l01935"></a>01935 
<a name="l01947"></a>01947     <span class="keyword">const</span> value_type &amp; top() <span class="keyword">const</span>;
<a name="l01948"></a>01948 
<a name="l01955"></a>01955     <span class="keywordtype">void</span> pop();
<a name="l01956"></a>01956 
<a name="l01961"></a>01961     <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; obj);
<a name="l01962"></a>01962 
<a name="l01967"></a><a class="code" href="classpriority__queue.html#4c1e9986ada44fed46b391805c13391b">01967</a>     unsigned_type mem_cons()<span class="keyword"> const</span>
<a name="l01968"></a>01968 <span class="keyword">    </span>{
<a name="l01969"></a>01969         unsigned_type dynam_alloc_mem(0), i(0);
<a name="l01970"></a>01970         <span class="comment">//dynam_alloc_mem += w_pool.mem_cons();</span>
<a name="l01971"></a>01971         <span class="comment">//dynam_alloc_mem += p_pool.mem_cons();</span>
<a name="l01972"></a>01972         <span class="keywordflow">for</span> ( ; i &lt; IntLevels; ++i)
<a name="l01973"></a>01973             dynam_alloc_mem += itree[i].mem_cons();
<a name="l01974"></a>01974 
<a name="l01975"></a>01975         <span class="keywordflow">for</span> (i = 0; i &lt; ExtLevels; ++i)
<a name="l01976"></a>01976             dynam_alloc_mem += etree[i].mem_cons();
<a name="l01977"></a>01977 
<a name="l01978"></a>01978 
<a name="l01979"></a>01979         <span class="keywordflow">return</span> (  <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) +
<a name="l01980"></a>01980                   <span class="keyword">sizeof</span>(ext_merger_type) * ExtLevels +
<a name="l01981"></a>01981                   dynam_alloc_mem );
<a name="l01982"></a>01982     }
<a name="l01983"></a>01983 };
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01987"></a><a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d">01987</a> <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::size_type</a> <a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">priority_queue&lt;Config_&gt;::size</a>()<span class="keyword"> const</span>
<a name="l01988"></a>01988 <span class="keyword"></span>{
<a name="l01989"></a>01989     <span class="keywordflow">return</span>
<a name="l01990"></a>01990            size_ +
<a name="l01991"></a>01991            insertHeap.size() - 1 +
<a name="l01992"></a>01992            ((buffer1 + BufferSize1) - minBuffer1);
<a name="l01993"></a>01993 }
<a name="l01994"></a>01994 
<a name="l01995"></a>01995 
<a name="l01996"></a>01996 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01997"></a><a class="code" href="group__stlcontinternals.html#g8475d4ea1887c50fd0e74ba37c47b9a7">01997</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::value_type</a> &amp; <a class="code" href="group__stlcontinternals.html#g8475d4ea1887c50fd0e74ba37c47b9a7" title="Returns &amp;quot;largest&amp;quot; element.">priority_queue&lt;Config_&gt;::top</a>()<span class="keyword"> const</span>
<a name="l01998"></a>01998 <span class="keyword"></span>{
<a name="l01999"></a>01999     assert(!insertHeap.empty());
<a name="l02000"></a>02000 
<a name="l02001"></a>02001     <span class="keywordflow">if</span> ( <span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1, insertHeap.top()))
<a name="l02002"></a>02002         <span class="keywordflow">return</span> insertHeap.top();
<a name="l02003"></a>02003 
<a name="l02004"></a>02004 
<a name="l02005"></a>02005     <span class="keywordflow">return</span> *minBuffer1;
<a name="l02006"></a>02006 }
<a name="l02007"></a>02007 
<a name="l02008"></a>02008 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02009"></a><a class="code" href="group__stlcontinternals.html#gca99f9b9ad7b0c7db4f7a1428fc50aac">02009</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__stlcontinternals.html#gca99f9b9ad7b0c7db4f7a1428fc50aac" title="Removes the element at the top.">priority_queue&lt;Config_&gt;::pop</a>()
<a name="l02010"></a>02010 {
<a name="l02011"></a>02011     <span class="comment">//STXXL_VERBOSE1("priority_queue::pop()");</span>
<a name="l02012"></a>02012     assert(!insertHeap.empty());
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     <span class="keywordflow">if</span> ( <span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1, insertHeap.top()))
<a name="l02015"></a>02015     {
<a name="l02016"></a>02016         insertHeap.pop();
<a name="l02017"></a>02017     }
<a name="l02018"></a>02018     <span class="keywordflow">else</span>
<a name="l02019"></a>02019     {
<a name="l02020"></a>02020         assert(minBuffer1 &lt; buffer1 + BufferSize1);
<a name="l02021"></a>02021         ++minBuffer1;
<a name="l02022"></a>02022         <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1)
<a name="l02023"></a>02023             refillBuffer1();
<a name="l02024"></a>02024     }
<a name="l02025"></a>02025 }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02028"></a><a class="code" href="group__stlcontinternals.html#g45ec8f50b6066c5f741bfdaac852a4b3">02028</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__stlcontinternals.html#g45ec8f50b6066c5f741bfdaac852a4b3" title="Inserts x into the priority_queue.">priority_queue&lt;Config_&gt;::push</a>(<span class="keyword">const</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> &amp; obj)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030     <span class="comment">//STXXL_VERBOSE3("priority_queue::push("&lt;&lt; obj &lt;&lt;")");</span>
<a name="l02031"></a>02031     assert(itree-&gt;not_sentinel(obj));
<a name="l02032"></a>02032     <span class="keywordflow">if</span> (insertHeap.size() == N + 1)
<a name="l02033"></a>02033         emptyInsertHeap();
<a name="l02034"></a>02034 
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     assert(!insertHeap.empty());
<a name="l02037"></a>02037 
<a name="l02038"></a>02038     insertHeap.push(obj);
<a name="l02039"></a>02039 }
<a name="l02040"></a>02040 
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02046"></a><a class="code" href="group__stlcontinternals.html#g861e6cbb1be531f25664f848c8728846">02046</a> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::priority_queue</a>(prefetch_pool &lt; block_type &gt; &amp;p_pool_, <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> &amp;w_pool_) :
<a name="l02047"></a>02047     p_pool(p_pool_), w_pool(w_pool_),
<a name="l02048"></a>02048     activeLevels(0), size_(0),
<a name="l02049"></a>02049     deallocate_pools(false)
<a name="l02050"></a>02050 {
<a name="l02051"></a>02051     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::priority_queue()"</span>);
<a name="l02052"></a>02052     <span class="comment">//etree = new ext_merger_type[ExtLevels](p_pool,w_pool);</span>
<a name="l02053"></a>02053     etree = <span class="keyword">new</span> ext_merger_type[ExtLevels];
<a name="l02054"></a>02054     <span class="keywordflow">for</span> (int_type j = 0; j &lt; ExtLevels; ++j)
<a name="l02055"></a>02055         etree[j].set_pools(&amp;p_pool, &amp;w_pool);
<a name="l02056"></a>02056 
<a name="l02057"></a>02057     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> sentinel = cmp.min_value();
<a name="l02058"></a>02058     buffer1[BufferSize1] = sentinel; <span class="comment">// sentinel</span>
<a name="l02059"></a>02059     insertHeap.push(sentinel); <span class="comment">// always keep the sentinel</span>
<a name="l02060"></a>02060     minBuffer1 = buffer1 + BufferSize1; <span class="comment">// empty</span>
<a name="l02061"></a>02061     <span class="keywordflow">for</span> (int_type i = 0;  i &lt; Levels;  i++)
<a name="l02062"></a>02062     {
<a name="l02063"></a>02063         buffer2[i][N] = sentinel; <span class="comment">// sentinel</span>
<a name="l02064"></a>02064         minBuffer2[i] = &amp;(buffer2[i][N]); <span class="comment">// empty</span>
<a name="l02065"></a>02065     }
<a name="l02066"></a>02066 }
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02069"></a><a class="code" href="group__stlcontinternals.html#g812eb7b157a681dfbabaa19503f8ccab">02069</a> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::priority_queue</a>(unsigned_type p_pool_mem, unsigned_type w_pool_mem) :
<a name="l02070"></a>02070     p_pool(*(new <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool</a>&lt;<a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>&gt;(p_pool_mem / BlockSize))),
<a name="l02071"></a>02071     w_pool(*(new <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool</a>&lt;<a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>&gt;(w_pool_mem / BlockSize))),
<a name="l02072"></a>02072     activeLevels(0), size_(0),
<a name="l02073"></a>02073     deallocate_pools(true)
<a name="l02074"></a>02074 {
<a name="l02075"></a>02075     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::priority_queue()"</span>);
<a name="l02076"></a>02076     etree = <span class="keyword">new</span> ext_merger_type[ExtLevels];
<a name="l02077"></a>02077     <span class="keywordflow">for</span> (int_type j = 0; j &lt; ExtLevels; ++j)
<a name="l02078"></a>02078         etree[j].set_pools(&amp;p_pool, &amp;w_pool);
<a name="l02079"></a>02079 
<a name="l02080"></a>02080     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> sentinel = cmp.min_value();
<a name="l02081"></a>02081     buffer1[BufferSize1] = sentinel; <span class="comment">// sentinel</span>
<a name="l02082"></a>02082     insertHeap.push(sentinel); <span class="comment">// always keep the sentinel</span>
<a name="l02083"></a>02083     minBuffer1 = buffer1 + BufferSize1; <span class="comment">// empty</span>
<a name="l02084"></a>02084     <span class="keywordflow">for</span> (int_type i = 0;  i &lt; Levels;  i++)
<a name="l02085"></a>02085     {
<a name="l02086"></a>02086         buffer2[i][N] = sentinel; <span class="comment">// sentinel</span>
<a name="l02087"></a>02087         minBuffer2[i] = &amp;(buffer2[i][N]); <span class="comment">// empty</span>
<a name="l02088"></a>02088     }
<a name="l02089"></a>02089 }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02092"></a>02092 <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::~priority_queue</a>()
<a name="l02093"></a>02093 {
<a name="l02094"></a>02094     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::~priority_queue()"</span>);
<a name="l02095"></a>02095     <span class="keywordflow">if</span> (deallocate_pools)
<a name="l02096"></a>02096     {
<a name="l02097"></a>02097         <span class="keyword">delete</span> &amp; p_pool;
<a name="l02098"></a>02098         <span class="keyword">delete</span> &amp; w_pool;
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101     <span class="keyword">delete</span> [] etree;
<a name="l02102"></a>02102 }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104 <span class="comment">//--------------------- Buffer refilling -------------------------------</span>
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 <span class="comment">// refill buffer2[j] and return number of elements found</span>
<a name="l02107"></a>02107 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02108"></a>02108 int_type <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::refillBuffer2</a>(int_type j)
<a name="l02109"></a>02109 {
<a name="l02110"></a>02110     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer2("</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l02111"></a>02111 
<a name="l02112"></a>02112     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * oldTarget;
<a name="l02113"></a>02113     int_type deleteSize;
<a name="l02114"></a>02114     <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a> treeSize = (j &lt; IntLevels) ? itree[j].<a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">size</a>() : etree[ j - IntLevels].size();
<a name="l02115"></a>02115     int_type bufferSize = (&amp;(buffer2[j][0]) + N) - minBuffer2[j];
<a name="l02116"></a>02116     <span class="keywordflow">if</span> (treeSize + bufferSize &gt;= <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a>(N) )
<a name="l02117"></a>02117     { <span class="comment">// buffer will be filled</span>
<a name="l02118"></a>02118         oldTarget = &amp;(buffer2[j][0]);
<a name="l02119"></a>02119         deleteSize = N - bufferSize;
<a name="l02120"></a>02120     }
<a name="l02121"></a>02121     <span class="keywordflow">else</span>
<a name="l02122"></a>02122     {
<a name="l02123"></a>02123         oldTarget = &amp;(buffer2[j][0]) + N - int_type(treeSize) - bufferSize;
<a name="l02124"></a>02124         deleteSize = treeSize;
<a name="l02125"></a>02125     }
<a name="l02126"></a>02126 
<a name="l02127"></a>02127     <span class="comment">// shift  rest to beginning</span>
<a name="l02128"></a>02128     <span class="comment">// possible hack:</span>
<a name="l02129"></a>02129     <span class="comment">// - use memcpy if no overlap</span>
<a name="l02130"></a>02130     memmove(oldTarget, minBuffer2[j], bufferSize * <span class="keyword">sizeof</span>(<a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a>));
<a name="l02131"></a>02131     minBuffer2[j] = oldTarget;
<a name="l02132"></a>02132 
<a name="l02133"></a>02133     <span class="comment">// fill remaining space from tree</span>
<a name="l02134"></a>02134     <span class="keywordflow">if</span> (j &lt; IntLevels)
<a name="l02135"></a>02135         itree[j].multi_merge(oldTarget + bufferSize, deleteSize);
<a name="l02136"></a>02136 
<a name="l02137"></a>02137     <span class="keywordflow">else</span>
<a name="l02138"></a>02138         etree[j - IntLevels].multi_merge(oldTarget + bufferSize,
<a name="l02139"></a>02139                                          oldTarget + bufferSize + deleteSize);
<a name="l02140"></a>02140 
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="comment">//STXXL_MSG(deleteSize + bufferSize);</span>
<a name="l02143"></a>02143     <span class="comment">//std::copy(oldTarget,oldTarget + deleteSize + bufferSize,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
<a name="l02144"></a>02144 
<a name="l02145"></a>02145     <span class="keywordflow">return</span> deleteSize + bufferSize;
<a name="l02146"></a>02146 }
<a name="l02147"></a>02147 
<a name="l02148"></a>02148 
<a name="l02149"></a>02149 <span class="comment">// move elements from the 2nd level buffers</span>
<a name="l02150"></a>02150 <span class="comment">// to the buffer</span>
<a name="l02151"></a>02151 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02152"></a>02152 <span class="keywordtype">void</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::refillBuffer1</a>()
<a name="l02153"></a>02153 {
<a name="l02154"></a>02154     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer1()"</span>);
<a name="l02155"></a>02155 
<a name="l02156"></a>02156     <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a> totalSize = 0;
<a name="l02157"></a>02157     int_type sz;
<a name="l02158"></a>02158     <span class="keywordflow">for</span> (int_type i = activeLevels - 1;  i &gt;= 0;  i--)
<a name="l02159"></a>02159     {
<a name="l02160"></a>02160         <span class="keywordflow">if</span> ((&amp;(buffer2[i][0]) + N) - minBuffer2[i] &lt; BufferSize1)
<a name="l02161"></a>02161         {
<a name="l02162"></a>02162             sz = refillBuffer2(i);
<a name="l02163"></a>02163             <span class="comment">// max active level dry now?</span>
<a name="l02164"></a>02164             <span class="keywordflow">if</span> (sz == 0 &amp;&amp; i == activeLevels - 1)
<a name="l02165"></a>02165                 --activeLevels;
<a name="l02166"></a>02166 
<a name="l02167"></a>02167             <span class="keywordflow">else</span>
<a name="l02168"></a>02168                 totalSize += sz;
<a name="l02169"></a>02169         }
<a name="l02170"></a>02170         <span class="keywordflow">else</span>
<a name="l02171"></a>02171         {
<a name="l02172"></a>02172             totalSize += BufferSize1; <span class="comment">// actually only a sufficient lower bound</span>
<a name="l02173"></a>02173         }
<a name="l02174"></a>02174     }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176     <span class="keywordflow">if</span> (totalSize &gt;= BufferSize1) <span class="comment">// buffer can be filled</span>
<a name="l02177"></a>02177     {
<a name="l02178"></a>02178         minBuffer1 = buffer1;
<a name="l02179"></a>02179         sz = BufferSize1; <span class="comment">// amount to be copied</span>
<a name="l02180"></a>02180         size_ -= <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a>(BufferSize1); <span class="comment">// amount left in buffer2</span>
<a name="l02181"></a>02181     }
<a name="l02182"></a>02182     <span class="keywordflow">else</span>
<a name="l02183"></a>02183     {
<a name="l02184"></a>02184         minBuffer1 = buffer1 + BufferSize1 - totalSize;
<a name="l02185"></a>02185         sz = totalSize;
<a name="l02186"></a>02186         assert(size_ == sz); <span class="comment">// trees and buffer2 get empty</span>
<a name="l02187"></a>02187         size_ = 0;
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190     <span class="comment">// now call simplified refill routines</span>
<a name="l02191"></a>02191     <span class="comment">// which can make the assumption that</span>
<a name="l02192"></a>02192     <span class="comment">// they find all they are asked to find in the buffers</span>
<a name="l02193"></a>02193     minBuffer1 = buffer1 + BufferSize1 - sz;
<a name="l02194"></a>02194     STXXL_VERBOSE2(<span class="stringliteral">"Active levels = "</span> &lt;&lt; activeLevels);
<a name="l02195"></a>02195     <span class="keywordflow">switch</span> (activeLevels)
<a name="l02196"></a>02196     {
<a name="l02197"></a>02197     <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>;
<a name="l02198"></a>02198     <span class="keywordflow">case</span> 1:
<a name="l02199"></a>02199         std::copy(minBuffer2[0], minBuffer2[0] + sz, minBuffer1);
<a name="l02200"></a>02200         minBuffer2[0] += sz;
<a name="l02201"></a>02201         <span class="keywordflow">break</span>;
<a name="l02202"></a>02202     <span class="keywordflow">case</span> 2: priority_queue_local::merge(
<a name="l02203"></a>02203             &amp;(minBuffer2[0]),
<a name="l02204"></a>02204             &amp;(minBuffer2[1]), minBuffer1, sz, cmp);
<a name="l02205"></a>02205         <span class="keywordflow">break</span>;
<a name="l02206"></a>02206     <span class="keywordflow">case</span> 3: priority_queue_local::merge3(
<a name="l02207"></a>02207             &amp;(minBuffer2[0]),
<a name="l02208"></a>02208             &amp;(minBuffer2[1]),
<a name="l02209"></a>02209             &amp;(minBuffer2[2]), minBuffer1, sz, cmp);
<a name="l02210"></a>02210         <span class="keywordflow">break</span>;
<a name="l02211"></a>02211     <span class="keywordflow">case</span> 4:
<a name="l02212"></a>02212         STXXL_VERBOSE2(<span class="stringliteral">"=1="</span> &lt;&lt; minBuffer2[0][0]); <span class="comment">//std::copy(minBuffer2[0],(&amp;(buffer2[0][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
<a name="l02213"></a>02213         STXXL_VERBOSE2(<span class="stringliteral">"=2="</span> &lt;&lt; minBuffer2[1][0]); <span class="comment">//std::copy(minBuffer2[1],(&amp;(buffer2[1][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
<a name="l02214"></a>02214         STXXL_VERBOSE2(<span class="stringliteral">"=3="</span> &lt;&lt; minBuffer2[2][0]); <span class="comment">//std::copy(minBuffer2[2],(&amp;(buffer2[2][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
<a name="l02215"></a>02215         STXXL_VERBOSE2(<span class="stringliteral">"=4="</span> &lt;&lt; minBuffer2[3][0]); <span class="comment">//std::copy(minBuffer2[3],(&amp;(buffer2[3][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
<a name="l02216"></a>02216         priority_queue_local::merge4(
<a name="l02217"></a>02217             &amp;(minBuffer2[0]),
<a name="l02218"></a>02218             &amp;(minBuffer2[1]),
<a name="l02219"></a>02219             &amp;(minBuffer2[2]),
<a name="l02220"></a>02220             &amp;(minBuffer2[3]), minBuffer1, sz, cmp);
<a name="l02221"></a>02221         <span class="keywordflow">break</span>;
<a name="l02222"></a>02222     <span class="keywordflow">default</span>:
<a name="l02223"></a>02223         STXXL_FORMAT_ERROR_MSG(msg, <span class="stringliteral">"priority_queue&lt;...&gt;::refillBuffer1(): Overflow! The number of buffers on 2nd level in stxxl::priority_queue is currently limited to 4"</span>)
<a name="l02224"></a>02224         throw std::runtime_error(msg.str());
<a name="l02225"></a>02225     }
<a name="l02226"></a>02226 
<a name="l02227"></a>02227     <span class="comment">//std::copy(minBuffer1,minBuffer1 + sz,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
<a name="l02228"></a>02228 }
<a name="l02229"></a>02229 
<a name="l02230"></a>02230 <span class="comment">//--------------------------------------------------------------------</span>
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 <span class="comment">// check if space is available on level k and</span>
<a name="l02233"></a>02233 <span class="comment">// empty this level if necessary leading to a recursive call.</span>
<a name="l02234"></a>02234 <span class="comment">// return the level where space was finally available</span>
<a name="l02235"></a>02235 template &lt;class Config_&gt;
<a name="l02236"></a>02236 int_type <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>&lt;Config_&gt;::makeSpaceAvailable(int_type level)
<a name="l02237"></a>02237 {
<a name="l02238"></a>02238     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::makeSpaceAvailable("</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l02239"></a>02239     int_type finalLevel;
<a name="l02240"></a>02240     assert(level &lt; Levels);
<a name="l02241"></a>02241     assert(level &lt;= activeLevels);
<a name="l02242"></a>02242 
<a name="l02243"></a>02243     <span class="keywordflow">if</span> (level == activeLevels)
<a name="l02244"></a>02244         activeLevels++;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246 
<a name="l02247"></a>02247     <span class="keyword">const</span> <span class="keywordtype">bool</span> spaceIsAvailable_ =
<a name="l02248"></a>02248         (level &lt; IntLevels) ? itree[level].spaceIsAvailable()
<a name="l02249"></a>02249         : ((level == Levels - 1) ? <span class="keyword">true</span> : (etree[level - IntLevels].spaceIsAvailable()));
<a name="l02250"></a>02250 
<a name="l02251"></a>02251     <span class="keywordflow">if</span> (spaceIsAvailable_)
<a name="l02252"></a>02252     {
<a name="l02253"></a>02253         finalLevel = level;
<a name="l02254"></a>02254     }
<a name="l02255"></a>02255     <span class="keywordflow">else</span>
<a name="l02256"></a>02256     {
<a name="l02257"></a>02257         finalLevel = makeSpaceAvailable(level + 1);
<a name="l02258"></a>02258 
<a name="l02259"></a>02259         <span class="keywordflow">if</span> (level &lt; IntLevels - 1) <span class="comment">// from internal to internal tree</span>
<a name="l02260"></a>02260         {
<a name="l02261"></a>02261             int_type segmentSize = itree[level].size();
<a name="l02262"></a>02262             <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * newSegment = <span class="keyword">new</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a>[segmentSize + 1];
<a name="l02263"></a>02263             itree[level].multi_merge(newSegment, segmentSize); <span class="comment">// empty this level</span>
<a name="l02264"></a>02264 
<a name="l02265"></a>02265             newSegment[segmentSize] = buffer1[BufferSize1]; <span class="comment">// sentinel</span>
<a name="l02266"></a>02266             <span class="comment">// for queues where size &lt;&lt; #inserts</span>
<a name="l02267"></a>02267             <span class="comment">// it might make sense to stay in this level if</span>
<a name="l02268"></a>02268             <span class="comment">// segmentSize &lt; alpha * KNN * k^level for some alpha &lt; 1</span>
<a name="l02269"></a>02269             itree[level + 1].insert_segment(newSegment, segmentSize);
<a name="l02270"></a>02270         }
<a name="l02271"></a>02271         <span class="keywordflow">else</span>
<a name="l02272"></a>02272         {
<a name="l02273"></a>02273             <span class="keywordflow">if</span> (level == IntLevels - 1) <span class="comment">// from internal to external tree</span>
<a name="l02274"></a>02274             {
<a name="l02275"></a>02275                 <span class="keyword">const</span> int_type segmentSize = itree[IntLevels - 1].size();
<a name="l02276"></a>02276                 etree[0].insert_segment(itree[IntLevels - 1], segmentSize);
<a name="l02277"></a>02277             }
<a name="l02278"></a>02278             <span class="keywordflow">else</span> <span class="comment">// from external to external tree</span>
<a name="l02279"></a>02279             {
<a name="l02280"></a>02280                 <span class="keyword">const</span> <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a> segmentSize = etree[level - IntLevels].size();
<a name="l02281"></a>02281                 etree[level - IntLevels + 1].insert_segment(etree[level - IntLevels], segmentSize);
<a name="l02282"></a>02282             }
<a name="l02283"></a>02283         }
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285     <span class="keywordflow">return</span> finalLevel;
<a name="l02286"></a>02286 }
<a name="l02287"></a>02287 
<a name="l02288"></a>02288 
<a name="l02289"></a>02289 <span class="comment">// empty the insert heap into the main data structure</span>
<a name="l02290"></a>02290 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02291"></a>02291 <span class="keywordtype">void</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::emptyInsertHeap</a>()
<a name="l02292"></a>02292 {
<a name="l02293"></a>02293     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::emptyInsertHeap()"</span>);
<a name="l02294"></a>02294     <span class="keyword">const</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> sup = getSupremum();
<a name="l02295"></a>02295 
<a name="l02296"></a>02296     <span class="comment">// build new segment</span>
<a name="l02297"></a>02297     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * newSegment = <span class="keyword">new</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a>[N + 1];
<a name="l02298"></a>02298     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * newPos = newSegment;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300     <span class="comment">// put the new data there for now</span>
<a name="l02301"></a>02301     <span class="comment">//insertHeap.sortTo(newSegment);</span>
<a name="l02302"></a>02302     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * SortTo = newSegment;
<a name="l02303"></a>02303     <span class="keyword">const</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * SortEnd = newSegment + N;
<a name="l02304"></a>02304     <span class="keywordflow">while</span> (SortTo != SortEnd)
<a name="l02305"></a>02305     {
<a name="l02306"></a>02306         assert(!insertHeap.empty());
<a name="l02307"></a>02307         *SortTo = insertHeap.top();
<a name="l02308"></a>02308         insertHeap.pop();
<a name="l02309"></a>02309         ++SortTo;
<a name="l02310"></a>02310     }
<a name="l02311"></a>02311 
<a name="l02312"></a>02312     assert(insertHeap.size() == 1);
<a name="l02313"></a>02313 
<a name="l02314"></a>02314     newSegment[N] = sup; <span class="comment">// sentinel</span>
<a name="l02315"></a>02315 
<a name="l02316"></a>02316     <span class="comment">// copy the buffer1 and buffer2[0] to temporary storage</span>
<a name="l02317"></a>02317     <span class="comment">// (the temporary can be eliminated using some dirty tricks)</span>
<a name="l02318"></a>02318     <span class="keyword">const</span> int_type tempSize = N + BufferSize1;
<a name="l02319"></a>02319     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> temp[tempSize + 1];
<a name="l02320"></a>02320     int_type sz1 = getSize1();
<a name="l02321"></a>02321     int_type sz2 = getSize2(0);
<a name="l02322"></a>02322     <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a> * pos = temp + tempSize - sz1 - sz2;
<a name="l02323"></a>02323     std::copy(minBuffer1, minBuffer1 + sz1, pos);
<a name="l02324"></a>02324     std::copy(minBuffer2[0], minBuffer2[0] + sz2, pos + sz1);
<a name="l02325"></a>02325     temp[tempSize] = sup; <span class="comment">// sentinel</span>
<a name="l02326"></a>02326 
<a name="l02327"></a>02327     <span class="comment">// refill buffer1</span>
<a name="l02328"></a>02328     <span class="comment">// (using more complicated code it could be made somewhat fuller</span>
<a name="l02329"></a>02329     <span class="comment">// in certein circumstances)</span>
<a name="l02330"></a>02330     priority_queue_local::merge(&amp;pos, &amp;newPos, minBuffer1, sz1, cmp);
<a name="l02331"></a>02331 
<a name="l02332"></a>02332     <span class="comment">// refill buffer2[0]</span>
<a name="l02333"></a>02333     <span class="comment">// (as above we might want to take the opportunity</span>
<a name="l02334"></a>02334     <span class="comment">// to make buffer2[0] fuller)</span>
<a name="l02335"></a>02335     priority_queue_local::merge(&amp;pos, &amp;newPos, minBuffer2[0], sz2, cmp);
<a name="l02336"></a>02336 
<a name="l02337"></a>02337     <span class="comment">// merge the rest to the new segment</span>
<a name="l02338"></a>02338     <span class="comment">// note that merge exactly trips into the footsteps</span>
<a name="l02339"></a>02339     <span class="comment">// of itself</span>
<a name="l02340"></a>02340     priority_queue_local::merge(&amp;pos, &amp;newPos, newSegment, N, cmp);
<a name="l02341"></a>02341 
<a name="l02342"></a>02342     <span class="comment">// and insert it</span>
<a name="l02343"></a>02343     int_type freeLevel = makeSpaceAvailable(0);
<a name="l02344"></a>02344     assert(freeLevel == 0 || itree[0].<a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">size</a>() == 0);
<a name="l02345"></a>02345     itree[0].insert_segment(newSegment, N);
<a name="l02346"></a>02346 
<a name="l02347"></a>02347     <span class="comment">// get rid of invalid level 2 buffers</span>
<a name="l02348"></a>02348     <span class="comment">// by inserting them into tree 0 (which is almost empty in this case)</span>
<a name="l02349"></a>02349     <span class="keywordflow">if</span> (freeLevel &gt; 0)
<a name="l02350"></a>02350     {
<a name="l02351"></a>02351         <span class="keywordflow">for</span> (int_type i = freeLevel;  i &gt;= 0;  i--)
<a name="l02352"></a>02352         { <span class="comment">// reverse order not needed</span>
<a name="l02353"></a>02353           <span class="comment">// but would allow immediate refill</span>
<a name="l02354"></a>02354 
<a name="l02355"></a>02355             newSegment = <span class="keyword">new</span> <a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396" title="The type of object stored in the priority_queue.">value_type</a>[getSize2(i) + 1]; <span class="comment">// with sentinel</span>
<a name="l02356"></a>02356             std::copy(minBuffer2[i], minBuffer2[i] + getSize2(i) + 1, newSegment);
<a name="l02357"></a>02357             itree[0].insert_segment(newSegment, getSize2(i));
<a name="l02358"></a>02358             minBuffer2[i] = buffer2[i] + N; <span class="comment">// empty</span>
<a name="l02359"></a>02359         }
<a name="l02360"></a>02360     }
<a name="l02361"></a>02361 
<a name="l02362"></a>02362     <span class="comment">// update size</span>
<a name="l02363"></a>02363     size_ += <a class="code" href="classpriority__queue.html#2a3ae2c53da89a8fa27d554f29e69154" title="An unsigned integral type (64 bit).">size_type</a>(N);
<a name="l02364"></a>02364 
<a name="l02365"></a>02365     <span class="comment">// special case if the tree was empty before</span>
<a name="l02366"></a>02366     <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1)
<a name="l02367"></a>02367         refillBuffer1();
<a name="l02368"></a>02368 }
<a name="l02369"></a>02369 
<a name="l02370"></a>02370 <span class="keyword">namespace </span>priority_queue_local
<a name="l02371"></a>02371 {
<a name="l02372"></a>02372     <span class="keyword">struct </span>Parameters_for_priority_queue_not_found_Increase_IntM
<a name="l02373"></a>02373     {
<a name="l02374"></a>02374         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02375"></a>02375         <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
<a name="l02376"></a>02376     };
<a name="l02377"></a>02377 
<a name="l02378"></a>02378     <span class="keyword">struct </span>dummy
<a name="l02379"></a>02379     {
<a name="l02380"></a>02380         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02381"></a>02381         <span class="keyword">typedef</span> dummy result;
<a name="l02382"></a>02382     };
<a name="l02383"></a>02383 
<a name="l02384"></a>02384     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type E_, <span class="keywordtype">int</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">int</span>_type B_, <span class="keywordtype">int</span>_type m_, <span class="keywordtype">bool</span> stop = false&gt;
<a name="l02385"></a>02385     <span class="keyword">struct </span>find_B_m
<a name="l02386"></a>02386     {
<a name="l02387"></a>02387         <span class="keyword">typedef</span> find_B_m&lt;E_, IntM_, MaxS_, B_, m_, stop&gt; Self;
<a name="l02388"></a>02388         <span class="keyword">enum</span> {
<a name="l02389"></a>02389             k = IntM_ / B_, <span class="comment">// number of blocks that fit into M</span>
<a name="l02390"></a>02390             E = E_,
<a name="l02391"></a>02391             IntM = IntM_,
<a name="l02392"></a>02392             B = B_,  <span class="comment">// block size</span>
<a name="l02393"></a>02393             m = m_,  <span class="comment">// ???</span>
<a name="l02394"></a>02394             c = k - m_,
<a name="l02395"></a>02395             <span class="comment">// memory occ. by block must be at least 10 times larger than size of ext sequence</span>
<a name="l02396"></a>02396             <span class="comment">// &amp;&amp; satisfy memory req &amp;&amp; if we have two ext mergers their degree must be at least 64=m/2</span>
<a name="l02397"></a>02397             fits = c &gt; 10 &amp;&amp; ((k - m) * (m) * (m * B / (E * 4 * 1024))) &gt;= int_type(MaxS_) &amp;&amp; (MaxS_ &lt; ((k - m) * m / (2 * E)) * 1024 || m &gt;= 128),
<a name="l02398"></a>02398             step = 1
<a name="l02399"></a>02399         };
<a name="l02400"></a>02400 
<a name="l02401"></a>02401         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m &lt; E, IntM, MaxS_, B, m + step, fits || (m &gt;= k - step) &gt; ::result candidate1;
<a name="l02402"></a>02402         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m &lt; E, IntM, MaxS_, B / 2, 1, fits || candidate1::fits &gt; ::result candidate2;
<a name="l02403"></a>02403         <span class="keyword">typedef</span> <span class="keyword">typename</span> IF &lt; fits, Self, typename IF&lt;candidate1::fits, candidate1, candidate2&gt;::result &gt; ::result result;
<a name="l02404"></a>02404     };
<a name="l02405"></a>02405 
<a name="l02406"></a>02406     <span class="comment">// specialization for the case when no valid parameters are found</span>
<a name="l02407"></a>02407     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type E_, <span class="keywordtype">int</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">bool</span> stop&gt;
<a name="l02408"></a>02408     <span class="keyword">struct </span>find_B_m &lt; E_, IntM_, MaxS_, 2048, 1, stop &gt;
<a name="l02409"></a>02409     {
<a name="l02410"></a>02410         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02411"></a>02411         <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
<a name="l02412"></a>02412     };
<a name="l02413"></a>02413 
<a name="l02414"></a>02414     <span class="comment">// to speedup search</span>
<a name="l02415"></a>02415     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type E_, <span class="keywordtype">int</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">int</span>_type B_, <span class="keywordtype">int</span>_type m_&gt;
<a name="l02416"></a>02416     <span class="keyword">struct </span>find_B_m&lt;E_, IntM_, MaxS_, B_, m_, true&gt;
<a name="l02417"></a>02417     {
<a name="l02418"></a>02418         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02419"></a>02419         <span class="keyword">typedef</span> dummy result;
<a name="l02420"></a>02420     };
<a name="l02421"></a>02421 
<a name="l02422"></a>02422     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type E_, <span class="keywordtype">int</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_&gt;
<a name="l02423"></a>02423     <span class="keyword">struct </span>find_settings
<a name="l02424"></a>02424     {
<a name="l02425"></a>02425         <span class="comment">// start from block size (8*1024*1024) bytes</span>
<a name="l02426"></a>02426         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m &lt; E_, IntM_, MaxS_, (8 * 1024 * 1024), 1 &gt; ::result result;
<a name="l02427"></a>02427     };
<a name="l02428"></a>02428 
<a name="l02429"></a>02429     <span class="keyword">struct </span>Parameters_not_found_Try_to_change_the_Tune_parameter
<a name="l02430"></a>02430     {
<a name="l02431"></a>02431         <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_the_Tune_parameter result;
<a name="l02432"></a>02432     };
<a name="l02433"></a>02433 
<a name="l02434"></a>02434 
<a name="l02435"></a>02435     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type AI_, <span class="keywordtype">int</span>_type X_, <span class="keywordtype">int</span>_type CriticalSize_&gt;
<a name="l02436"></a>02436     <span class="keyword">struct </span>compute_N
<a name="l02437"></a>02437     {
<a name="l02438"></a>02438         <span class="keyword">typedef</span> compute_N&lt;AI_, X_, CriticalSize_&gt; Self;
<a name="l02439"></a>02439         <span class="keyword">enum</span>
<a name="l02440"></a>02440         {
<a name="l02441"></a>02441             X = X_,
<a name="l02442"></a>02442             AI = AI_,
<a name="l02443"></a>02443             N = X / (AI * AI)
<a name="l02444"></a>02444         };
<a name="l02445"></a>02445         <span class="keyword">typedef</span> <span class="keyword">typename</span> IF &lt; (N &gt;= CriticalSize_), Self, <span class="keyword">typename</span> compute_N &lt; AI / 2, X, CriticalSize_ &gt; ::result &gt; ::result result;
<a name="l02446"></a>02446     };
<a name="l02447"></a>02447 
<a name="l02448"></a>02448     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span>_type X_, <span class="keywordtype">int</span>_type CriticalSize_&gt;
<a name="l02449"></a>02449     <span class="keyword">struct </span>compute_N &lt; 1, X_, CriticalSize_ &gt;
<a name="l02450"></a>02450     {
<a name="l02451"></a>02451         <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_the_Tune_parameter result;
<a name="l02452"></a>02452     };
<a name="l02453"></a>02453 }
<a name="l02454"></a>02454 
<a name="l02456"></a>02456 
<a name="l02459"></a>02459 
<a name="l02461"></a>02461 
<a name="l02525"></a>02525 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span> MaxS_, <span class="keywordtype">unsigned</span> Tune_ = 6&gt;
<a name="l02526"></a><a class="code" href="classPRIORITY__QUEUE__GENERATOR.html">02526</a> <span class="keyword">class </span><a class="code" href="classPRIORITY__QUEUE__GENERATOR.html" title="Priority queue type generator.">PRIORITY_QUEUE_GENERATOR</a>
<a name="l02527"></a>02527 {
<a name="l02528"></a>02528 <span class="keyword">public</span>:
<a name="l02529"></a>02529     <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::find_settings &lt; sizeof(Tp_), IntM_, MaxS_ &gt; ::result settings;
<a name="l02530"></a>02530     <span class="keyword">enum</span> {
<a name="l02531"></a>02531         B = settings::B,
<a name="l02532"></a>02532         m = settings::m,
<a name="l02533"></a>02533         X = B * (settings::k - m) / settings::E,
<a name="l02534"></a>02534         Buffer1Size = 32
<a name="l02535"></a>02535     };
<a name="l02536"></a>02536     <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::compute_N &lt; (1 &lt;&lt; Tune_), X, 4 * Buffer1Size &gt; ::result ComputeN;
<a name="l02537"></a>02537     <span class="keyword">enum</span>
<a name="l02538"></a>02538     {
<a name="l02539"></a>02539         N = ComputeN::N,
<a name="l02540"></a>02540         AI = ComputeN::AI,
<a name="l02541"></a>02541         AE = (m / 2 &lt; 2) ? 2 : (m / 2)
<a name="l02542"></a>02542     };
<a name="l02543"></a>02543 <span class="keyword">public</span>:
<a name="l02544"></a>02544     <span class="keyword">enum</span> {
<a name="l02545"></a>02545         <span class="comment">// Estimation of maximum internal memory consumption (in bytes)</span>
<a name="l02546"></a>02546         EConsumption = X * settings::E + settings::B * AE + ((MaxS_ / X) / AE) * settings::B * 1024
<a name="l02547"></a>02547     };
<a name="l02548"></a>02548     <span class="comment">/*</span>
<a name="l02549"></a>02549 <span class="comment">        unsigned BufferSize1_ = 32, // equalize procedure call overheads etc.</span>
<a name="l02550"></a>02550 <span class="comment">        unsigned N_ = 512, // bandwidth</span>
<a name="l02551"></a>02551 <span class="comment">        unsigned IntKMAX_ = 64, // maximal arity for internal mergers</span>
<a name="l02552"></a>02552 <span class="comment">        unsigned IntLevels_ = 4,</span>
<a name="l02553"></a>02553 <span class="comment">        unsigned BlockSize_ = (2*1024*1024),</span>
<a name="l02554"></a>02554 <span class="comment">        unsigned ExtKMAX_ = 64, // maximal arity for external mergers</span>
<a name="l02555"></a>02555 <span class="comment">        unsigned ExtLevels_ = 2,</span>
<a name="l02556"></a>02556 <span class="comment">     */</span>
<a name="l02557"></a>02557     <span class="keyword">typedef</span> priority_queue &lt; priority_queue_config &lt; Tp_, Cmp_, Buffer1Size, N, AI, 2, B, AE, 2 &gt; &gt; <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">result</a>;
<a name="l02558"></a>02558 };
<a name="l02559"></a>02559 
<a name="l02561"></a>02561 
<a name="l02562"></a>02562 __STXXL_END_NAMESPACE
<a name="l02563"></a>02563 
<a name="l02564"></a>02564 
<a name="l02565"></a>02565 <span class="keyword">namespace </span>std
<a name="l02566"></a>02566 {
<a name="l02567"></a>02567     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02568"></a>02568     <span class="keywordtype">void</span> swap(stxxl::priority_queue&lt;Config_&gt; &amp;a,
<a name="l02569"></a>02569               stxxl::priority_queue&lt;Config_&gt; &amp;b)
<a name="l02570"></a>02570     {
<a name="l02571"></a>02571         a.swap(b);
<a name="l02572"></a>02572     }
<a name="l02573"></a>02573 }
<a name="l02574"></a>02574 
<a name="l02575"></a>02575 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 21 06:44:35 2010 for Stxxl by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
