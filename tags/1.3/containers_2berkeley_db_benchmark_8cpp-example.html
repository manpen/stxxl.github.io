<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Stxxl: containers/berkeley_db_benchmark.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stxxl
   &#160;<span id="projectnumber">1.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">containers/berkeley_db_benchmark.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>This is a benchmark mentioned in the paper R. Dementiev, L. Kettner, P. Sanders "STXXL: standard template library for XXL data sets" Software: Practice and Experience Volume 38, Issue 6, Pages 589-637, May 2008 DOI: 10.1002/spe.844</p>
<div class="fragment"><div class="line"><span class="comment">/***************************************************************************</span></div>
<div class="line"><span class="comment"> *  containers/berkeley_db_benchmark.cpp</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Copyright (C) 2006 Roman Dementiev &lt;dementiev@ira.uka.de&gt;</span></div>
<div class="line"><span class="comment"> *  Copyright (C) 2009, 2010 Andreas Beckmann &lt;beckmann@cs.uni-frankfurt.de&gt;</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span></div>
<div class="line"><span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> **************************************************************************/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stxxl/vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stxxl/map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stxxl/timer&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stxxl/stream&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;db_cxx.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;app_config.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;portability.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ami_btree.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define BDB_BULK_SCAN</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define KEY_SIZE                8</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DATA_SIZE               32</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define NODE_BLOCK_SIZE         (32 * 1024)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define LEAF_BLOCK_SIZE         (32 * 1024)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define LEAF_BLOCK_SIZE         (32 * 1024)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define TOTAL_CACHE_SIZE        (750 * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">//#define TOTAL_CACHE_SIZE      (150 * 1024 * 1024)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//#define NODE_CACHE_SIZE       (1 * (TOTAL_CACHE_SIZE / 40))</span></div>
<div class="line"><span class="comment">//#define LEAF_CACHE_SIZE       (39 * (TOTAL_CACHE_SIZE / 40))</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define NODE_CACHE_SIZE         (64 * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define LEAF_CACHE_SIZE         (TOTAL_CACHE_SIZE - NODE_CACHE_SIZE)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define SORTER_MEM              (TOTAL_CACHE_SIZE - 1024 * 1024 * 2 * 4)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define SCAN_LIMIT(x)   (x)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">//#define BDB_FILE &quot;/data3/bdb_file&quot;</span></div>
<div class="line"><span class="preprocessor">#define BDB_FILE &quot;/var/tmp/bdb_file&quot;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// BDB settings</span></div>
<div class="line">u_int32_t pagesize = LEAF_BLOCK_SIZE;</div>
<div class="line">u_int bulkbufsize = 4 * 1024 * 1024;</div>
<div class="line">u_int logbufsize = 8 * 1024 * 1024;</div>
<div class="line">u_int cachesize = (TOTAL_CACHE_SIZE &lt; 500 * 1024 * 1024) ? (4 * (TOTAL_CACHE_SIZE / 5)) : (TOTAL_CACHE_SIZE - 100 * 1024 * 1024);</div>
<div class="line">u_int datasize = DATA_SIZE;</div>
<div class="line">u_int keysize = KEY_SIZE;</div>
<div class="line">u_int numitems = 0;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * letters = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxuz&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_key</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> keybuf[KEY_SIZE];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; o, <span class="keyword">const</span> my_key &amp; obj)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)</div>
<div class="line">        o &lt;&lt; obj.keybuf[i];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> o;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) != 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt; 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &gt; 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt;= 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &gt;= 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>my_data</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> databuf[DATA_SIZE];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; o, <span class="keyword">const</span> my_data &amp; obj)</div>
<div class="line">{</div>
<div class="line">    o &lt;&lt; <span class="stringliteral">&quot;DATA(size=&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(obj) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> o;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">my_key min_key, max_key;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>comp_type : std::binary_function&lt;my_key, my_key, bool&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt; 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> my_key max_value()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> max_key;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> my_key min_value()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> min_key;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Key type.</span></div>
<div class="line"><span class="keyword">typedef</span> my_key bkey_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Element type for the btree.</span></div>
<div class="line"><span class="keyword">struct </span>el_t {</div>
<div class="line">    bkey_t key_;</div>
<div class="line">    my_data data_;</div>
<div class="line">    el_t(bkey_t k) : key_(k) { }</div>
<div class="line">    el_t() { }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>key_from_el {</div>
<div class="line">    bkey_t operator () (<span class="keyword">const</span> el_t &amp; v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> v.key_;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Temporary distinction btw UN*X and WIN, since there are some</span></div>
<div class="line"><span class="comment">// problems with the MMAP collection implementation.</span></div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> AMI_btree&lt;bkey_t, el_t, less&lt;bkey_t&gt;, key_from_el, BTE_COLLECTION_UFS&gt; u_btree_t;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> AMI_btree&lt;bkey_t, el_t, less&lt;bkey_t&gt;, key_from_el&gt; u_btree_t;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> init()</div>
<div class="line">{</div>
<div class="line">    memset(max_key.keybuf, (std::numeric_limits&lt;unsigned char&gt;::max)(), KEY_SIZE);</div>
<div class="line">    memset(min_key.keybuf, (std::numeric_limits&lt;unsigned char&gt;::min)(), KEY_SIZE);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> stxxl::map&lt;my_key, my_data, comp_type, NODE_BLOCK_SIZE, LEAF_BLOCK_SIZE&gt; map_type;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define REAL_NODE_BLOCK_SIZE map_type::node_block_type::raw_size</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define REAL_LEAF_BLOCK_SIZE map_type::leaf_block_type::raw_size</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define REAL_NODE_MELEMENTS map_type::node_block_type::size</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define REAL_LEAF_MELEMENTS map_type::leaf_block_type::size</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;std::pair&lt;my_key, my_data&gt;, 1, 1&gt;::result vector_type;</div>
<div class="line"><span class="comment">//typedef stxxl::vector&lt;std::pair&lt;my_key,my_data&gt;,1,stxxl::lru_pager&lt;1&gt;,512*1024&gt;  vector_type;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//#define KEYPOS        (i % KEY_SIZE)</span></div>
<div class="line"><span class="comment">//#define VALUE         (myrand() % 26)</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">unsigned</span> ran32State = 0xdeadbeef;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">unsigned</span> myrand()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (ran32State = 1664525 * ran32State + 1013904223);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> rand_key(stxxl::int64 pos, my_key &amp; Key)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)</div>
<div class="line">        Key.keybuf[i] = letters[myrand() % 26];</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#else // a longer pseudo random sequence</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> ran32State = 0xdeadbeef;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> myrand()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (ran32State = (ran32State * 0x5DEECE66DULL + 0xBULL) &amp; 0xFFFFFFFFFFFFULL);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> rand_key(stxxl::int64 <span class="comment">/*pos*/</span>, my_key &amp; Key)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> r = myrand();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)</div>
<div class="line">    {</div>
<div class="line">        Key.keybuf[i] = letters[r % 26];</div>
<div class="line">        r &gt;&gt;= 5;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keywordtype">void</span> run_bdb_btree(stxxl::int64 ops)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = BDB_FILE;</div>
<div class="line"></div>
<div class="line">    my_key key1_storage;</div>
<div class="line">    my_data data1_storage;</div>
<div class="line"></div>
<div class="line">    unlink(filename);</div>
<div class="line"></div>
<div class="line">    memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(data1_storage.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Db db(NULL, 0);             <span class="comment">// Instantiate the Db object</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        db.set_errfile(stderr);</div>
<div class="line">        db.set_pagesize(pagesize);</div>
<div class="line">        db.set_cachesize(0, cachesize, 1);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Open the database</span></div>
<div class="line">        db.open(NULL,           <span class="comment">// Transaction pointer</span></div>
<div class="line">                filename,       <span class="comment">// Database file name</span></div>
<div class="line">                NULL,           <span class="comment">// Optional logical database name</span></div>
<div class="line">                DB_BTREE,       <span class="comment">// Database access method</span></div>
<div class="line">                DB_CREATE,      <span class="comment">// Open flags</span></div>
<div class="line">                0);             <span class="comment">// File mode (using defaults)</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// here we start with the tests</span></div>
<div class="line">        Dbt key1(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">        Dbt data1(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">        stxxl::timer Timer;</div>
<div class="line">        stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;</div>
<div class="line">        stxxl::int64 i;</div>
<div class="line">        <span class="comment">//comp_type cmp_;</span></div>
<div class="line"></div>
<div class="line">        ran32State = 0xdeadbeef;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        DB_BTREE_STAT * dbstat;</div>
<div class="line"></div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat(NULL, NULL, DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        Dbc * cursorp;</div>
<div class="line">        db.cursor(NULL, &amp;cursorp, 0);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">            Dbt datax(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">            cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line"></div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        stxxl::int64 n_scanned = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            my_key last_key = key1_storage;</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            <span class="keywordflow">if</span> (last_key &lt; key1_storage)</div>
<div class="line">                std::swap(last_key, key1_storage);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">            Dbt datax(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE) == DB_NOTFOUND)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">while</span> (*((my_key *)keyx.get_data()) &lt;= last_key)</div>
<div class="line">            {</div>
<div class="line">                ++n_scanned;</div>
<div class="line">                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT) == DB_NOTFOUND)</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (n_scanned &gt;= 10 * n_range_queries)</div>
<div class="line">            {</div>
<div class="line">                ++i;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        n_range_queries = i;</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        <span class="keywordflow">if</span> (cursorp != NULL)</div>
<div class="line">            cursorp-&gt;close();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);</div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        ran32State = 0xdeadbeef;</div>
<div class="line">        memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">            db.del(NULL, &amp;keyx, 0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        db.close(0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (DbException &amp; e)</div>
<div class="line">    {</div>
<div class="line">        STXXL_ERRMSG(<span class="stringliteral">&quot;DbException happened&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception &amp; e)</div>
<div class="line">    {</div>
<div class="line">        STXXL_ERRMSG(<span class="stringliteral">&quot;std::exception happened&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    unlink(filename);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> run_stxxl_map(stxxl::int64 ops)</div>
<div class="line">{</div>
<div class="line">    map_type Map(NODE_CACHE_SIZE, LEAF_CACHE_SIZE);</div>
<div class="line">    Map.enable_prefetching();</div>
<div class="line">    stxxl::stats * Stats = stxxl::stats::get_instance();</div>
<div class="line"></div>
<div class="line">    std::pair&lt;my_key, my_data&gt; element;</div>
<div class="line"></div>
<div class="line">    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    stxxl::timer Timer;</div>
<div class="line">    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;</div>
<div class="line">    stxxl::int64 i;</div>
<div class="line">    <span class="comment">//comp_type cmp_;</span></div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//stxxl::random_number32 myrand;</span></div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line"></div>
<div class="line">    stxxl::stats_data stats_begin(*Stats);</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        Map.insert(element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> map_type &amp; CMap(Map);     <span class="comment">// const map reference</span></div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        CMap.lower_bound(element.first);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_locates) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        my_key begin_key = element.first;</div>
<div class="line">        map_type::const_iterator begin = CMap.lower_bound(element.first);</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        map_type::const_iterator beyond = CMap.lower_bound(element.first);</div>
<div class="line">        <span class="keywordflow">if</span> (element.first &lt; begin_key)</div>
<div class="line">            std::swap(begin, beyond);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (begin != beyond)</div>
<div class="line">        {</div>
<div class="line">            my_data tmp = begin-&gt;second;</div>
<div class="line">            stxxl::STXXL_UNUSED(tmp);</div>
<div class="line">            ++n_scanned;</div>
<div class="line">            ++begin;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (n_scanned &gt;= 10 * n_range_queries)</div>
<div class="line">        {</div>
<div class="line">            ++i;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    n_range_queries = i;</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line">    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        Map.erase(element.first);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_deletes) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>rand_key_gen</div>
<div class="line">{</div>
<div class="line">    stxxl::int64 counter;</div>
<div class="line">    my_key &amp; current;</div>
<div class="line">    stxxl::random_number32 myrand;</div>
<div class="line">    rand_key_gen();</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> my_key value_type;</div>
<div class="line"></div>
<div class="line">    rand_key_gen(stxxl::int64 el, my_key &amp; cur) :</div>
<div class="line">        counter(el), current(cur)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//const stxxl::int64  &amp; i = counter;</span></div>
<div class="line">        <span class="comment">//current.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(counter, current);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> my_key &amp; operator * () { <span class="keywordflow">return</span> current; }</div>
<div class="line">    <span class="keyword">const</span> my_key * operator -&gt; () { <span class="keywordflow">return</span> &amp;current; }</div>
<div class="line"></div>
<div class="line">    rand_key_gen &amp; operator ++ ()</div>
<div class="line">    {</div>
<div class="line">        --counter;</div>
<div class="line">        <span class="comment">//const stxxl::int64  &amp; i = counter;</span></div>
<div class="line">        <span class="comment">//current.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(counter, current);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> counter == 0; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputType&gt;</div>
<div class="line"><span class="keyword">class </span>key2pair</div>
<div class="line">{</div>
<div class="line">    InputType &amp; in;</div>
<div class="line">    std::pair&lt;my_key, my_data&gt; current;</div>
<div class="line">    key2pair();</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> std::pair&lt;my_key, my_data&gt; value_type;</div>
<div class="line"></div>
<div class="line">    key2pair(InputType &amp; in_) : in(in_)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!in.empty())</div>
<div class="line">            current.first = *in;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> value_type &amp; operator * () { <span class="keywordflow">return</span> current; }</div>
<div class="line">    <span class="keyword">const</span> value_type * operator -&gt; () { <span class="keywordflow">return</span> &amp;current; }</div>
<div class="line"></div>
<div class="line">    key2pair &amp; operator ++ ()</div>
<div class="line">    {</div>
<div class="line">        ++in;</div>
<div class="line">        <span class="keywordflow">if</span> (!empty())</div>
<div class="line">            current.first = *in;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> in.empty(); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> run_stxxl_map_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)</div>
<div class="line">{</div>
<div class="line">    stxxl::stats * Stats = stxxl::stats::get_instance();</div>
<div class="line"></div>
<div class="line">    std::pair&lt;my_key, my_data&gt; element;</div>
<div class="line"></div>
<div class="line">    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">    stxxl::timer Timer;</div>
<div class="line">    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;</div>
<div class="line">    stxxl::int64 i;</div>
<div class="line">    <span class="comment">//comp_type cmp_;</span></div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//stxxl::random_number32 myrand;</span></div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    vector_type SortedSeq(n);</div>
<div class="line">    <span class="keyword">const</span> vector_type &amp; CSortedSeq(SortedSeq);</div>
<div class="line">    {</div>
<div class="line">        rand_key_gen Gen(n, element.first);</div>
<div class="line">        <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;</div>
<div class="line">        sorter_type Sorter(Gen, comp_type(), SORTER_MEM);</div>
<div class="line">        <span class="keyword">typedef</span> key2pair&lt;sorter_type&gt; key2pair_type;</div>
<div class="line">        key2pair_type Key2Pair(Sorter);</div>
<div class="line">        <a name="a0"></a><a class="code" href="group__streampack.html#gad1bb58f5d03ae440c43cdedbb293372c">stxxl::stream::materialize</a>(Key2Pair, SortedSeq.begin());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt;</div>
<div class="line">              (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    stxxl::stats_data stats_begin(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// bulk construction</span></div>
<div class="line">    map_type Map(CSortedSeq.begin(),</div>
<div class="line">                 CSortedSeq.end(),</div>
<div class="line">                 NODE_CACHE_SIZE, LEAF_CACHE_SIZE, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Map.print_statistics(cout);</div>
<div class="line">    Map.reset_statistics();</div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Map.disable_prefetching();</div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        Map.insert(element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Map.print_statistics(cout);</div>
<div class="line">    Map.reset_statistics();</div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> map_type &amp; CMap(Map);     <span class="comment">// const map reference</span></div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        CMap.lower_bound(element.first);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Map.print_statistics(cout);</div>
<div class="line">    Map.reset_statistics();</div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Map.enable_prefetching();</div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        my_key begin_key = element.first;</div>
<div class="line">        map_type::const_iterator begin = CMap.lower_bound(element.first);</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        map_type::const_iterator beyond = CMap.lower_bound(element.first);</div>
<div class="line">        <span class="keywordflow">if</span> (element.first &lt; begin_key)</div>
<div class="line">            std::swap(begin, beyond);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">           STXXL_MSG(&quot;Looking     &quot;&lt;&lt;element.first&lt;&lt;&quot; scanned: &quot;&lt;&lt;n_scanned);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">           if(beyond==CMap.end())</span></div>
<div class="line"><span class="comment">           {</span></div>
<div class="line"><span class="comment">                STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;&quot;END&quot;);</span></div>
<div class="line"><span class="comment">           }</span></div>
<div class="line"><span class="comment">           else</span></div>
<div class="line"><span class="comment">           {</span></div>
<div class="line"><span class="comment">                STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;((element.first&gt;begin_key)?element.first:begin_key));</span></div>
<div class="line"><span class="comment">           }*/</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (begin != beyond)</div>
<div class="line">        {</div>
<div class="line">            ++n_scanned;</div>
<div class="line">            ++begin;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))</div>
<div class="line">        {</div>
<div class="line">            ++i;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    n_range_queries = i;</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);</div>
<div class="line"></div>
<div class="line">    Map.print_statistics(cout);</div>
<div class="line">    Map.reset_statistics();</div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line">    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">    Map.disable_prefetching();</div>
<div class="line"></div>
<div class="line">    stats_begin = stxxl::stats_data(*Stats);</div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = n_deletes; i &gt; 0; --i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.first);</div>
<div class="line">        Map.erase(element.first);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Map.print_statistics(cout);</div>
<div class="line">    Map.reset_statistics();</div>
<div class="line">    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> AMI_STREAM&lt;el_t&gt; stream_t;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">char</span> dummy;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MyFilter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> el_t &amp; v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        dummy += v.key_.keybuf[0];         <span class="comment">// touch element</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> run_tpie_btree_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)</div>
<div class="line">{</div>
<div class="line">    el_t element;</div>
<div class="line"></div>
<div class="line">    memset(element.key_.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.data_.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Log debugging info from the application, but not from the library.</span></div>
<div class="line">    tpie_log_init(TPIE_LOG_APP_DEBUG);</div>
<div class="line">    MM_manager.set_memory_limit(TOTAL_CACHE_SIZE);</div>
<div class="line">    MM_manager.enforce_memory_limit();</div>
<div class="line"></div>
<div class="line">    stream_t * is = <span class="keyword">new</span> stream_t;</div>
<div class="line"></div>
<div class="line">    stxxl::timer Timer;</div>
<div class="line">    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;</div>
<div class="line">    stxxl::int64 i;</div>
<div class="line">    <span class="comment">//comp_type cmp_;</span></div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//stxxl::random_number32 myrand;</span></div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        rand_key_gen Gen(n, element.key_);</div>
<div class="line">        <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;</div>
<div class="line">        sorter_type Sorter(Gen, comp_type(), SORTER_MEM);</div>
<div class="line">        <span class="comment">//typedef key2pair&lt;sorter_type&gt; key2pair_type;</span></div>
<div class="line">        <span class="comment">//key2pair_type Key2Pair(Sorter);</span></div>
<div class="line">        <span class="keywordflow">while</span> (!Sorter.empty())</div>
<div class="line">        {</div>
<div class="line">            is-&gt;write_item(*Sorter);</div>
<div class="line">            ++Sorter;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt;</div>
<div class="line">              (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// bulk construction</span></div>
<div class="line">    u_btree_t * u_btree;</div>
<div class="line">    AMI_btree_params params;</div>
<div class="line">    params.node_block_factor = NODE_BLOCK_SIZE / 4096;</div>
<div class="line">    params.leaf_block_factor = LEAF_BLOCK_SIZE / 4096;</div>
<div class="line">    params.leaf_cache_size = LEAF_CACHE_SIZE / LEAF_BLOCK_SIZE;</div>
<div class="line">    params.node_cache_size = NODE_CACHE_SIZE / NODE_BLOCK_SIZE;</div>
<div class="line"></div>
<div class="line">    u_btree = <span class="keyword">new</span> u_btree_t(params);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> std::cout;</div>
<div class="line">    <span class="keyword">using</span> std::cerr;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!u_btree-&gt;is_valid()) {</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;Error initializing btree. Aborting.\n&quot;</span>;</div>
<div class="line">        <span class="keyword">delete</span> u_btree;</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (u_btree-&gt;load_sorted(is, 1.0, 1.0) != AMI_ERROR_NO_ERROR)</div>
<div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;Error during bulk loading.\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.key_);</div>
<div class="line">        u_btree-&gt;insert(element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    el_t result;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.key_);</div>
<div class="line">        u_btree-&gt;succ(element.key_, result);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span></div>
<div class="line">    MyFilter filter;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)</div>
<div class="line">    {</div>
<div class="line">        rand_key(i, element.key_);</div>
<div class="line">        my_key begin_key = element.key_;</div>
<div class="line">        rand_key(i, element.key_);</div>
<div class="line">        <span class="keywordflow">if</span> (element.key_ &lt; begin_key)</div>
<div class="line">            n_scanned += u_btree-&gt;range_query(element.key_, begin_key, NULL, filter);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            n_scanned += u_btree-&gt;range_query(begin_key, element.key_, NULL, filter);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))</div>
<div class="line">        {</div>
<div class="line">            ++i;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    n_range_queries = i;</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    ran32State = 0xdeadbeef;</div>
<div class="line">    memset(element.key_.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(element.data_.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">    Timer.reset();</div>
<div class="line"></div>
<div class="line">    Timer.start();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = n_deletes; i &gt; 0; --i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">        rand_key(i, element.key_);</div>
<div class="line">        u_btree-&gt;erase(element.key_);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Timer.stop();</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line">    <span class="keyword">delete</span> u_btree;</div>
<div class="line">    <span class="keyword">delete</span> is;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> run_bdb_btree_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = BDB_FILE;</div>
<div class="line"></div>
<div class="line">    my_key key1_storage;</div>
<div class="line">    my_data data1_storage;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef BDB_BULK_SCAN</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordtype">int</span> * bulk_buffer = <span class="keyword">new</span> <span class="keywordtype">int</span>[logbufsize / <span class="keyword">sizeof</span>(int)];</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    unlink(filename);</div>
<div class="line"></div>
<div class="line">    memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line">    memset(data1_storage.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Db db(NULL, 0);                   <span class="comment">// Instantiate the Db object</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// here we start with the tests</span></div>
<div class="line">        Dbt key1(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">        Dbt data1(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">        stxxl::timer Timer;</div>
<div class="line">        stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;</div>
<div class="line">        stxxl::int64 i;</div>
<div class="line">        <span class="comment">//comp_type cmp_;</span></div>
<div class="line"></div>
<div class="line">        ran32State = 0xdeadbeef;</div>
<div class="line"></div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        vector_type SortedSeq(n);</div>
<div class="line">        <span class="comment">//const vector_type &amp; CSortedSeq(SortedSeq);</span></div>
<div class="line">        {</div>
<div class="line">            rand_key_gen Gen(n, key1_storage);</div>
<div class="line">            <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;</div>
<div class="line">            sorter_type Sorter(Gen, comp_type(), SORTER_MEM);</div>
<div class="line">            <span class="keyword">typedef</span> key2pair&lt;sorter_type&gt; key2pair_type;</div>
<div class="line">            key2pair_type Key2Pair(Sorter);</div>
<div class="line">            <a class="code" href="group__streampack.html#gad1bb58f5d03ae440c43cdedbb293372c">stxxl::stream::materialize</a>(Key2Pair, SortedSeq.begin());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line"></div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.set_errfile(stderr);</div>
<div class="line">        db.set_pagesize(pagesize);</div>
<div class="line">        db.set_cachesize(0, cachesize, 10);</div>
<div class="line"></div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;BDB cache size set.&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Open the database</span></div>
<div class="line">        db.open(NULL,           <span class="comment">// Transaction pointer</span></div>
<div class="line">                filename,       <span class="comment">// Database file name</span></div>
<div class="line">                NULL,           <span class="comment">// Optional logical database name</span></div>
<div class="line">                DB_BTREE,       <span class="comment">// Database access method</span></div>
<div class="line">                DB_CREATE,      <span class="comment">// Open flags</span></div>
<div class="line">                0);             <span class="comment">// File mode (using defaults)</span></div>
<div class="line"></div>
<div class="line">        db.get_env()-&gt;memp_stat(NULL, NULL, DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// DBD does not have bulk construction</span></div>
<div class="line">        <span class="comment">// however inserting in sorted order might help</span></div>
<div class="line">        <span class="comment">// to improve performance</span></div>
<div class="line">        vector_type::const_iterator cit = SortedSeq.begin();</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i, ++cit)</div>
<div class="line">        {</div>
<div class="line">            key1_storage = cit-&gt;first;</div>
<div class="line">            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line"></div>
<div class="line">        DB_BTREE_STAT * dbstat;</div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.stat_print(0);</div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.stat_print(0);</div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        Dbc * cursorp;</div>
<div class="line">        db.cursor(NULL, &amp;cursorp, 0);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">            Dbt datax(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"></div>
<div class="line">            cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.stat_print(0);</div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line"></div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        stxxl::int64 n_scanned = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            my_key last_key = key1_storage;</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            <span class="keywordflow">if</span> (last_key &lt; key1_storage)</div>
<div class="line">                std::swap(last_key, key1_storage);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="comment">//STXXL_MSG(&quot;Looking     &quot;&lt;&lt;key1_storage&lt;&lt;&quot; scanned: &quot;&lt;&lt;n_scanned);</span></div>
<div class="line">            <span class="comment">//STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;last_key);</span></div>
<div class="line"></div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line"><span class="preprocessor">#ifdef BDB_BULK_SCAN</span></div>
<div class="line"><span class="preprocessor"></span>            Dbt datax(bulk_buffer, DATA_SIZE);</div>
<div class="line">            datax.set_ulen(logbufsize);</div>
<div class="line">            datax.set_flags(DB_DBT_USERMEM);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>            Dbt datax(data1_storage.databuf, DATA_SIZE);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef BDB_BULK_SCAN</span></div>
<div class="line"><span class="preprocessor"></span>            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE | DB_MULTIPLE_KEY) == DB_NOTFOUND)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">do</span></div>
<div class="line">            {</div>
<div class="line">                DbMultipleKeyDataIterator BulkIterator(datax);</div>
<div class="line">                Dbt key1, data1;</div>
<div class="line">                <span class="keywordflow">while</span> (BulkIterator.next(key1, data1) &amp;&amp;</div>
<div class="line">                       *((my_key *)key1.get_data()) &lt;= last_key)</div>
<div class="line">                {</div>
<div class="line">                    ++n_scanned;</div>
<div class="line">                    <span class="comment">//STXXL_MSG(&quot;Result      &quot;&lt;&lt;*((my_key *)key1.get_data()));</span></div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT | DB_MULTIPLE_KEY) == DB_NOTFOUND)</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (*((my_key *)keyx.get_data()) &gt; last_key)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">while</span> (1);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE) == DB_NOTFOUND)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">while</span> (*((my_key *)keyx.get_data()) &lt;= last_key)</div>
<div class="line">            {</div>
<div class="line">                ++n_scanned;</div>
<div class="line">                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT) == DB_NOTFOUND)</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))</div>
<div class="line">            {</div>
<div class="line">                ++i;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        n_range_queries = i;</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        <span class="keywordflow">if</span> (cursorp != NULL)</div>
<div class="line">            cursorp-&gt;close();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);</div>
<div class="line"></div>
<div class="line">        db.stat_print(0);</div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        ran32State = 0xdeadbeef;</div>
<div class="line">        memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);</div>
<div class="line"></div>
<div class="line">        Timer.reset();</div>
<div class="line">        Timer.start();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span></div>
<div class="line">            rand_key(i, key1_storage);</div>
<div class="line">            Dbt keyx(key1_storage.keybuf, KEY_SIZE);</div>
<div class="line">            db.del(NULL, &amp;keyx, 0);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        Timer.stop();</div>
<div class="line">        db.stat(NULL, &amp;dbstat, 0);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;</div>
<div class="line">                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);</div>
<div class="line"></div>
<div class="line">        db.stat_print(0);</div>
<div class="line">        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);</div>
<div class="line"></div>
<div class="line">        db.close(0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (DbException &amp; e)</div>
<div class="line">    {</div>
<div class="line">        STXXL_ERRMSG(<span class="stringliteral">&quot;DbException happened&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception &amp; e)</div>
<div class="line">    {</div>
<div class="line">        STXXL_ERRMSG(<span class="stringliteral">&quot;std::exception happened&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    unlink(filename);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef BDB_BULK_SCAN</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">delete</span>[]  bulk_buffer;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])</div>
<div class="line">{</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Real Node block size: &quot;</span> &lt;&lt; REAL_NODE_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Real Leaf block size: &quot;</span> &lt;&lt; REAL_LEAF_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Node max elements   : &quot;</span> &lt;&lt; REAL_NODE_MELEMENTS);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Leaf max elements   : &quot;</span> &lt;&lt; REAL_LEAF_MELEMENTS);</div>
<div class="line"><span class="preprocessor">#ifdef STXXL_DIRECT_IO_OFF</span></div>
<div class="line"><span class="preprocessor"></span>    STXXL_MSG(<span class="stringliteral">&quot;STXXL_DIRECT_IO_OFF is defined&quot;</span>);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    STXXL_MSG(<span class="stringliteral">&quot;STXXL_DIRECT_IO_OFF is NOT defined&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt; 3)</div>
<div class="line">    {</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; version #ops&quot;</span>);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;\t version = 1: test stxxl map&quot;</span>);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;\t version = 2: test Berkeley DB btree&quot;</span>);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;\t version = 3: big test stxxl map&quot;</span>);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;\t version = 4: big test Berkeley DB btree&quot;</span>);</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;\t version = 5: big test TPIE btree&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    init();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> version = atoi(argv[1]);</div>
<div class="line">    stxxl::int64 ops = stxxl::atoint64(argv[2]);</div>
<div class="line"></div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Running version      : &quot;</span> &lt;&lt; version);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Operations to perform: &quot;</span> &lt;&lt; ops);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Btree cache size     : &quot;</span> &lt;&lt; TOTAL_CACHE_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);</div>
<div class="line">    STXXL_MSG(<span class="stringliteral">&quot;Leaf block size      : &quot;</span> &lt;&lt; LEAF_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (version)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> 1:</div>
<div class="line">        run_stxxl_map(ops);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 2:</div>
<div class="line">        run_bdb_btree(ops);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 3:</div>
<div class="line">        run_stxxl_map_big(ops, 100000);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 4:</div>
<div class="line">        run_bdb_btree_big(ops, 100000);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 5:</div>
<div class="line">        run_tpie_btree_big(ops, 100000);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        STXXL_MSG(<span class="stringliteral">&quot;Unsupported version &quot;</span> &lt;&lt; version);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
