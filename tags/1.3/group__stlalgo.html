<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Stxxl: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stxxl
   &#160;<span id="projectnumber">1.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms<div class="ingroups"><a class="el" href="group__stllayer.html">STL-user layer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Algorithms:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__stlalgo.png" border="0" alt="" usemap="#group____stlalgo"/>
<map name="group____stlalgo" id="group____stlalgo">
<area shape="rect" id="node2" href="group__stllayer.html" title="STL&#45;user layer" alt="" coords="7,5,116,35"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceksort__local"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceksort__local.html">ksort_local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesort__local"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesort__local.html">sort_local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestable__ksort__local"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestable__ksort__local.html">stable_ksort_local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga52e9a8e286d32541e1750ff9afdb4246"><td class="memTemplParams" colspan="2">template&lt;typename ExtIterator_ , typename KeyExtractor_ &gt; </td></tr>
<tr class="memitem:ga52e9a8e286d32541e1750ff9afdb4246"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga52e9a8e286d32541e1750ff9afdb4246">ksort</a> (ExtIterator_ first_, ExtIterator_ last_, KeyExtractor_ keyobj, unsigned_type M__)</td></tr>
<tr class="memdesc:ga52e9a8e286d32541e1750ff9afdb4246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort records with integer keys.  <a href="#ga52e9a8e286d32541e1750ff9afdb4246">More...</a><br/></td></tr>
<tr class="separator:ga52e9a8e286d32541e1750ff9afdb4246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f47f3c4b53ac79d14db7376ff7a4b5d"><td class="memTemplParams" colspan="2">template&lt;typename ExtIterator_ &gt; </td></tr>
<tr class="memitem:ga8f47f3c4b53ac79d14db7376ff7a4b5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga8f47f3c4b53ac79d14db7376ff7a4b5d">ksort</a> (ExtIterator_ first_, ExtIterator_ last_, unsigned_type M__)</td></tr>
<tr class="memdesc:ga8f47f3c4b53ac79d14db7376ff7a4b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort records with integer keys.  <a href="#ga8f47f3c4b53ac79d14db7376ff7a4b5d">More...</a><br/></td></tr>
<tr class="separator:ga8f47f3c4b53ac79d14db7376ff7a4b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0cd5561969d4a03e3abe9850cf1ffe"><td class="memTemplParams" colspan="2">template&lt;typename ExtIterator_ , typename RandomNumberGenerator_ , unsigned BlockSize_, unsigned PageSize_, typename AllocStrategy_ &gt; </td></tr>
<tr class="memitem:ga8b0cd5561969d4a03e3abe9850cf1ffe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga8b0cd5561969d4a03e3abe9850cf1ffe">random_shuffle</a> (ExtIterator_ first, ExtIterator_ last, RandomNumberGenerator_ &amp;rand, unsigned_type M, AllocStrategy_ AS=STXXL_DEFAULT_ALLOC_STRATEGY())</td></tr>
<tr class="memdesc:ga8b0cd5561969d4a03e3abe9850cf1ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::random_shuffle.  <a href="#ga8b0cd5561969d4a03e3abe9850cf1ffe">More...</a><br/></td></tr>
<tr class="separator:ga8b0cd5561969d4a03e3abe9850cf1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a1a8026c234253601c17f90b5e734d"><td class="memTemplParams" colspan="2">template&lt;typename Tp_ , typename AllocStrategy_ , typename SzTp_ , typename DiffTp_ , unsigned BlockSize_, typename PgTp_ , unsigned PageSize_, typename RandomNumberGenerator_ &gt; </td></tr>
<tr class="memitem:ga36a1a8026c234253601c17f90b5e734d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga36a1a8026c234253601c17f90b5e734d">random_shuffle</a> (stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt; first, stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt; last, RandomNumberGenerator_ &amp;rand, unsigned_type M)</td></tr>
<tr class="memdesc:ga36a1a8026c234253601c17f90b5e734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::random_shuffle (specialization for stxxl::vector)  <a href="#ga36a1a8026c234253601c17f90b5e734d">More...</a><br/></td></tr>
<tr class="separator:ga36a1a8026c234253601c17f90b5e734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a60ca547212cf012f2afbb410ddd98"><td class="memTemplParams" colspan="2">template&lt;typename Tp_ , typename AllocStrategy_ , typename SzTp_ , typename DiffTp_ , unsigned BlockSize_, typename PgTp_ , unsigned PageSize_&gt; </td></tr>
<tr class="memitem:gab0a60ca547212cf012f2afbb410ddd98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#gab0a60ca547212cf012f2afbb410ddd98">random_shuffle</a> (stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt; first, stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt; last, unsigned_type M)</td></tr>
<tr class="memdesc:gab0a60ca547212cf012f2afbb410ddd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::random_shuffle (specialization for stxxl::vector)  <a href="#gab0a60ca547212cf012f2afbb410ddd98">More...</a><br/></td></tr>
<tr class="separator:gab0a60ca547212cf012f2afbb410ddd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f420d5b43552d88c61f0fd484e8b64"><td class="memTemplParams" colspan="2">template&lt;typename _ExtIterator , typename _UnaryFunction &gt; </td></tr>
<tr class="memitem:ga80f420d5b43552d88c61f0fd484e8b64"><td class="memTemplItemLeft" align="right" valign="top">_UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga80f420d5b43552d88c61f0fd484e8b64">for_each</a> (_ExtIterator _begin, _ExtIterator _end, _UnaryFunction _functor, int_type nbuffers)</td></tr>
<tr class="memdesc:ga80f420d5b43552d88c61f0fd484e8b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::for_each.  <a href="#ga80f420d5b43552d88c61f0fd484e8b64">More...</a><br/></td></tr>
<tr class="separator:ga80f420d5b43552d88c61f0fd484e8b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcc151f0963c99b7b034d1dacf9eb59"><td class="memTemplParams" colspan="2">template&lt;typename _ExtIterator , typename _UnaryFunction &gt; </td></tr>
<tr class="memitem:ga5dcc151f0963c99b7b034d1dacf9eb59"><td class="memTemplItemLeft" align="right" valign="top">_UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga5dcc151f0963c99b7b034d1dacf9eb59">for_each_m</a> (_ExtIterator _begin, _ExtIterator _end, _UnaryFunction _functor, int_type nbuffers)</td></tr>
<tr class="memdesc:ga5dcc151f0963c99b7b034d1dacf9eb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::for_each (mutating)  <a href="#ga5dcc151f0963c99b7b034d1dacf9eb59">More...</a><br/></td></tr>
<tr class="separator:ga5dcc151f0963c99b7b034d1dacf9eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4d2f3d9692e5a44a02eae632656ec9"><td class="memTemplParams" colspan="2">template&lt;typename _ExtIterator , typename _Generator &gt; </td></tr>
<tr class="memitem:ga3b4d2f3d9692e5a44a02eae632656ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga3b4d2f3d9692e5a44a02eae632656ec9">generate</a> (_ExtIterator _begin, _ExtIterator _end, _Generator _generator, int_type nbuffers)</td></tr>
<tr class="memdesc:ga3b4d2f3d9692e5a44a02eae632656ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::generate.  <a href="#ga3b4d2f3d9692e5a44a02eae632656ec9">More...</a><br/></td></tr>
<tr class="separator:ga3b4d2f3d9692e5a44a02eae632656ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63333d8362fa9e6394d1d77683f6dcc"><td class="memTemplParams" colspan="2">template&lt;typename _ExtIterator , typename _EqualityComparable &gt; </td></tr>
<tr class="memitem:gab63333d8362fa9e6394d1d77683f6dcc"><td class="memTemplItemLeft" align="right" valign="top">_ExtIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#gab63333d8362fa9e6394d1d77683f6dcc">find</a> (_ExtIterator _begin, _ExtIterator _end, const _EqualityComparable &amp;_value, int_type nbuffers)</td></tr>
<tr class="memdesc:gab63333d8362fa9e6394d1d77683f6dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">External equivalent of std::find.  <a href="#gab63333d8362fa9e6394d1d77683f6dcc">More...</a><br/></td></tr>
<tr class="separator:gab63333d8362fa9e6394d1d77683f6dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34dabf842078576e6704450dcbc8b080"><td class="memTemplParams" colspan="2">template&lt;typename ExtIterator_ , typename StrictWeakOrdering_ &gt; </td></tr>
<tr class="memitem:ga34dabf842078576e6704450dcbc8b080"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga34dabf842078576e6704450dcbc8b080">sort</a> (ExtIterator_ first, ExtIterator_ last, StrictWeakOrdering_ cmp, unsigned_type M)</td></tr>
<tr class="memdesc:ga34dabf842078576e6704450dcbc8b080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort records comparison-based.  <a href="#ga34dabf842078576e6704450dcbc8b080">More...</a><br/></td></tr>
<tr class="separator:ga34dabf842078576e6704450dcbc8b080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23907e7b3da81fa3fb7327eeb774459a"><td class="memTemplParams" colspan="2">template&lt;typename ExtIterator_ &gt; </td></tr>
<tr class="memitem:ga23907e7b3da81fa3fb7327eeb774459a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#ga23907e7b3da81fa3fb7327eeb774459a">stable_ksort</a> (ExtIterator_ first, ExtIterator_ last, unsigned_type M)</td></tr>
<tr class="memdesc:ga23907e7b3da81fa3fb7327eeb774459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort records with integer keys.  <a href="#ga23907e7b3da81fa3fb7327eeb774459a">More...</a><br/></td></tr>
<tr class="separator:ga23907e7b3da81fa3fb7327eeb774459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44d0e3975086cc2ad0bee1eaba0d9cf"><td class="memTemplParams" colspan="2">template&lt;unsigned BlockSize, class RandomAccessIterator , class CmpType , class AllocStr &gt; </td></tr>
<tr class="memitem:gab44d0e3975086cc2ad0bee1eaba0d9cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stlalgo.html#gab44d0e3975086cc2ad0bee1eaba0d9cf">sort</a> (RandomAccessIterator begin, RandomAccessIterator end, CmpType cmp, unsigned_type MemSize, AllocStr AS)</td></tr>
<tr class="memdesc:gab44d0e3975086cc2ad0bee1eaba0d9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts range of any random access iterators externally.  <a href="#gab44d0e3975086cc2ad0bee1eaba0d9cf">More...</a><br/></td></tr>
<tr class="separator:gab44d0e3975086cc2ad0bee1eaba0d9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms with STL-compatible interface </p>


<h3><a class="anchor" id="key_extractor"></a>Key extractor concept</h3><div class="textblock">Model of <b>Key</b> <b>extractor</b> concept must:</p>
<ul>
<li>define type <b>key_type</b> ,</li>
<li>provide <b>operator()</b> that returns key value of an object of user type</li>
<li>provide <b>max_value</b> method that returns a value that is <b>strictly</b> <b>greater</b> than all other objects of user type in respect to the key obtained by this key extractor ,</li>
<li>provide <b>min_value</b> method that returns a value that is <b>strictly</b> <b>less</b> than all other objects of user type in respect to the key obtained by this key extractor ,</li>
<li>operator &gt; , operator &lt;, operator == and operator != on type <b>key_type</b> must be defined.</li>
<li><b>Note:</b> when using unsigned integral types as key, the value 0 cannot be used as a key value because it would conflict with the sentinel value returned by <b>min_value</b> </li>
</ul>
Example: extractor class <b>GetWeight</b>, that extracts weight from an <b>Edge</b> </p>
<pre class="fragment">  struct Edge
  {
    unsigned src,dest,weight;
    Edge(unsigned s,unsigned d,unsigned w):src(s),dest(d),weight(w){}
  };

  struct GetWeight
  {
   typedef unsigned key_type;
   key_type operator() (const Edge &amp; e) const
   {
       return e.weight;
   }
   Edge min_value() const { return Edge(0,0,(std::numeric_limits&lt;key_type&gt;::min)()); };
   Edge max_value() const { return Edge(0,0,(std::numeric_limits&lt;key_type&gt;::max)()); };
  };
</pre> </div>

<h3><a class="anchor" id="comparison"></a>Comparison concept</h3><div class="textblock">Model of <b>Comparison</b> concept must:</p>
<ul>
<li>provide <b>operator(a,b)</b> that returns comparison result of two user types, must define strict weak ordering</li>
<li>provide <b>max_value</b> method that returns a value that is <b>strictly</b> <b>greater</b> than all other objects of user type,</li>
<li>provide <b>min_value</b> method that returns a value that is <b>strictly</b> <b>less</b> than all other objects of user type,</li>
<li><b>Note:</b> when using unsigned integral types as key in user types, the value 0 cannot be used as a key value of the data to be sorted because it would conflict with the sentinel value returned by <b>min_value</b> </li>
</ul>
Example: comparator class <b>my_less_int</b> </p>
<pre class="fragment">  struct my_less_int
  {
   bool operator() (int a, int b) const
   {
       return a &lt; b;
   }
   int min_value() const { return std::numeric_limits&lt;int&gt;::min(); };
   int max_value() const { return std::numeric_limits&lt;int&gt;::max(); };
  };
</pre>Example: comparator class <b>my_less</b>, could be instantiated as e.g. <b>my_less&lt;int&gt;</b> , <b>my_less&lt;unsigned long&gt;</b> , ... </p>
<pre class="fragment">  template &lt;typename Tp&gt;
  struct my_less
  {
   typedef Tp value_type;
   bool operator() (const value_type &amp; a, const value_type &amp; b) const
   {
       return a &lt; b;
   }
   value_type min_value() const { return std::numeric_limits&lt;value_type&gt;::min(); };
   value_type max_value() const { return std::numeric_limits&lt;value_type&gt;::max(); };
  };
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab63333d8362fa9e6394d1d77683f6dcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ExtIterator , typename _EqualityComparable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ExtIterator find </td>
          <td>(</td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _EqualityComparable &amp;&#160;</td>
          <td class="paramname"><em>_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>nbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::find. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The implementation exploits <code>&lt;stxxl&gt;</code> buffered streams (computation and I/O overlapped) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_begin</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_end</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_value</td><td>value that is equality comparable to the _ExtIterator's value type </td></tr>
    <tr><td class="paramname">nbuffers</td><td>number of buffers (blocks) for internal use (should be at least 2*D ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first iterator <code>i</code> in the range [_begin,_end) such that *( <code>i</code> ) == <code>_value</code>, if no such exists then <code>_end</code> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2test_scan_8cpp-example.html#a2">algo/test_scan.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga80f420d5b43552d88c61f0fd484e8b64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ExtIterator , typename _UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_UnaryFunction for_each </td>
          <td>(</td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_UnaryFunction&#160;</td>
          <td class="paramname"><em>_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>nbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::for_each. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The implementation exploits <code>&lt;stxxl&gt;</code> buffered streams (computation and I/O overlapped) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_begin</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_end</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_functor</td><td>function object of model of <code>std::UnaryFunction</code> concept </td></tr>
    <tr><td class="paramname">nbuffers</td><td>number of buffers (blocks) for internal use (should be at least 2*D ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>function object <code>_functor</code> after it has been applied to the each element of the given range</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>nested stxxl::for_each are not supported </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcc151f0963c99b7b034d1dacf9eb59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ExtIterator , typename _UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_UnaryFunction for_each_m </td>
          <td>(</td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_UnaryFunction&#160;</td>
          <td class="paramname"><em>_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>nbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::for_each (mutating) </p>
<dl class="section remark"><dt>Remarks</dt><dd>The implementation exploits <code>&lt;stxxl&gt;</code> buffered streams (computation and I/O overlapped) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_begin</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_end</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_functor</td><td></td></tr>
    <tr><td class="paramname">nbuffers</td><td>number of buffers (blocks) for internal use (should be at least 2*D ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>function object <code>_functor</code> after it has been applied to the each element of the given range</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>nested stxxl::for_each_m are not supported </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2test_scan_8cpp-example.html#a1">algo/test_scan.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3b4d2f3d9692e5a44a02eae632656ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ExtIterator , typename _Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void generate </td>
          <td>(</td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ExtIterator&#160;</td>
          <td class="paramname"><em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Generator&#160;</td>
          <td class="paramname"><em>_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>nbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::generate. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The implementation exploits <code>&lt;stxxl&gt;</code> buffered streams (computation and I/O overlapped) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_begin</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_end</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">_generator</td><td>function object of model of <code>std::Generator</code> concept </td></tr>
    <tr><td class="paramname">nbuffers</td><td>number of buffers (blocks) for internal use (should be at least 2*D ) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2test_parallel_sort_8cpp-example.html#a4">algo/test_parallel_sort.cpp</a>, <a class="el" href="algo_2test_random_shuffle_8cpp-example.html#a0">algo/test_random_shuffle.cpp</a>, <a class="el" href="algo_2test_scan_8cpp-example.html#a0">algo/test_scan.cpp</a>, <a class="el" href="containers_2test_vector_8cpp-example.html#a0">containers/test_vector.cpp</a>, and <a class="el" href="stream_2test_sorted_runs_8cpp-example.html#a0">stream/test_sorted_runs.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga52e9a8e286d32541e1750ff9afdb4246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtIterator_ , typename KeyExtractor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ksort </td>
          <td>(</td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>last_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyExtractor_&#160;</td>
          <td class="paramname"><em>keyobj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M__</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort records with integer keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">last_</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">keyobj</td><td><a class="el" href="group__stlalgo.html#key_extractor">key extractor </a> object </td></tr>
    <tr><td class="paramname">M__</td><td>amount of memory for internal use (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Order in the result is non-stable </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2sort_file_8cpp-example.html#a1">algo/sort_file.cpp</a>, and <a class="el" href="algo_2test_ksort_8cpp-example.html#a0">algo/test_ksort.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="group__mnglayer.html#ga91b9174b06295f5e3035caf004df3d52">block_manager::delete_block()</a>, <a class="el" href="classblock__manager.html#aeb0ff49742df01ec1b83ffbbbc6ae69f">block_manager::new_block()</a>, <a class="el" href="classrequest__interface.html#a77f8ce33cba4957e580a9da2354eb1ed">request_interface::wait()</a>, and <a class="el" href="group__iolayer.html#gaa691abeb3c2d9e4cf8118b29aaed58ef">wait_all()</a>.</p>

<p>Referenced by <a class="el" href="group__stlalgo.html#ga8f47f3c4b53ac79d14db7376ff7a4b5d">ksort()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f47f3c4b53ac79d14db7376ff7a4b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtIterator_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ksort </td>
          <td>(</td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>last_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M__</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort records with integer keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">last_</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">M__</td><td>amount of buffers for internal use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Order in the result is non-stable</dd></dl>
<p>Record's type must:</p>
<ul>
<li>provide <b>max_value</b> method that returns an object that is <b>greater</b> than all other objects of user type ,</li>
<li>provide <b>min_value</b> method that returns an object that is <b>less</b> than all other objects of user type ,</li>
<li><b>operator</b> <b>&lt;</b> that must define strict weak ordering on record's values (<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">see what it is</a>). </li>
</ul>

<p>References <a class="el" href="group__stlalgo.html#ga52e9a8e286d32541e1750ff9afdb4246">ksort()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b0cd5561969d4a03e3abe9850cf1ffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtIterator_ , typename RandomNumberGenerator_ , unsigned BlockSize_, unsigned PageSize_, typename AllocStrategy_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void random_shuffle </td>
          <td>(</td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator_ &amp;&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocStrategy_&#160;</td>
          <td class="paramname"><em>AS</em> = <code>STXXL_DEFAULT_ALLOC_STRATEGY()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::random_shuffle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of the range to shuffle </td></tr>
    <tr><td class="paramname">last</td><td>end of the range to shuffle </td></tr>
    <tr><td class="paramname">rand</td><td>random number generator object (functor) </td></tr>
    <tr><td class="paramname">M</td><td>number of bytes for internal use </td></tr>
    <tr><td class="paramname">AS</td><td>parallel disk allocation strategy</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>BlockSize_ size of the block to use for external memory data structures</li>
<li>PageSize_ page size in blocks to use for external memory data structures </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2test_random_shuffle_8cpp-example.html#a1">algo/test_random_shuffle.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="group__streampack.html#gabeaef04a9f562f354a89b52cb0c55bf2">stream::streamify()</a>.</p>

<p>Referenced by <a class="el" href="group__stlalgo.html#ga36a1a8026c234253601c17f90b5e734d">random_shuffle()</a>.</p>

</div>
</div>
<a class="anchor" id="ga36a1a8026c234253601c17f90b5e734d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp_ , typename AllocStrategy_ , typename SzTp_ , typename DiffTp_ , unsigned BlockSize_, typename PgTp_ , unsigned PageSize_, typename RandomNumberGenerator_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void random_shuffle </td>
          <td>(</td>
          <td class="paramtype">stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator_ &amp;&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External equivalent of std::random_shuffle (specialization for stxxl::vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of the range to shuffle </td></tr>
    <tr><td class="paramname">last</td><td>end of the range to shuffle </td></tr>
    <tr><td class="paramname">rand</td><td>random number generator object (functor) </td></tr>
    <tr><td class="paramname">M</td><td>number of bytes for internal use </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__stlalgo.html#ga8b0cd5561969d4a03e3abe9850cf1ffe">random_shuffle()</a>.</p>

</div>
</div>
<a class="anchor" id="gab0a60ca547212cf012f2afbb410ddd98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp_ , typename AllocStrategy_ , typename SzTp_ , typename DiffTp_ , unsigned BlockSize_, typename PgTp_ , unsigned PageSize_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void random_shuffle </td>
          <td>(</td>
          <td class="paramtype">stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stxxl::vector_iterator&lt; Tp_, AllocStrategy_, SzTp_, DiffTp_, BlockSize_, PgTp_, PageSize_ &gt;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>External equivalent of std::random_shuffle (specialization for stxxl::vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of the range to shuffle </td></tr>
    <tr><td class="paramname">last</td><td>end of the range to shuffle </td></tr>
    <tr><td class="paramname">M</td><td>number of bytes for internal use </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__stlalgo.html#ga8b0cd5561969d4a03e3abe9850cf1ffe">random_shuffle()</a>.</p>

</div>
</div>
<a class="anchor" id="ga34dabf842078576e6704450dcbc8b080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtIterator_ , typename StrictWeakOrdering_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering_&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort records comparison-based. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">last</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison object </td></tr>
    <tr><td class="paramname">M</td><td>amount of memory for internal use (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Implements external merge sort described in [Dementiev &amp; Sanders'03] </dd>
<dd>
non-stable </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2sort_file_8cpp-example.html#a0">algo/sort_file.cpp</a>, <a class="el" href="algo_2test_bad_cmp_8cpp-example.html#a0">algo/test_bad_cmp.cpp</a>, <a class="el" href="algo_2test_parallel_sort_8cpp-example.html#a0">algo/test_parallel_sort.cpp</a>, <a class="el" href="algo_2test_sort_8cpp-example.html#a0">algo/test_sort.cpp</a>, <a class="el" href="stream_2test_sorted_runs_8cpp-example.html#a1">stream/test_sorted_runs.cpp</a>, and <a class="el" href="stream_2test_stream_8cpp-example.html#a2">stream/test_stream.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="group__mnglayer.html#ga91b9174b06295f5e3035caf004df3d52">block_manager::delete_block()</a>, <a class="el" href="classblock__manager.html#aeb0ff49742df01ec1b83ffbbbc6ae69f">block_manager::new_block()</a>, and <a class="el" href="classrequest__interface.html#a77f8ce33cba4957e580a9da2354eb1ed">request_interface::wait()</a>.</p>

<p>Referenced by <a class="el" href="classpriority__queue__local_1_1internal__priority__queue.html#a91872f7fcdd79a9f0bbb0fbc5d921b41">priority_queue_local::internal_priority_queue&lt; value_type, std::vector&lt; value_type &gt;, comparator_type &gt;::sort_to()</a>.</p>

</div>
</div>
<a class="anchor" id="gab44d0e3975086cc2ad0bee1eaba0d9cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned BlockSize, class RandomAccessIterator , class CmpType , class AllocStr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmpType&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>MemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocStr&#160;</td>
          <td class="paramname"><em>AS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts range of any random access iterators externally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first element of the range </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing to the last+1 element of the range </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison object </td></tr>
    <tr><td class="paramname">MemSize</td><td>memory to use for sorting (in bytes) </td></tr>
    <tr><td class="paramname">AS</td><td>allocation strategy</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>BlockSize</code> template parameter defines the block size to use (in bytes) </p>
<dl class="section warning"><dt>Warning</dt><dd>Slower than External Iterator Sort </dd></dl>

<p>References <a class="el" href="group__streampack.html#gad1bb58f5d03ae440c43cdedbb293372c">stream::materialize()</a>, and <a class="el" href="group__streampack.html#gabeaef04a9f562f354a89b52cb0c55bf2">stream::streamify()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23907e7b3da81fa3fb7327eeb774459a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtIterator_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stable_ksort </td>
          <td>(</td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtIterator_&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort records with integer keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">last</td><td>object of model of <code>ext_random_access_iterator</code> concept </td></tr>
    <tr><td class="paramname">M</td><td>amount of memory for internal use (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Elements must provide a method key() which returns the integer key. </dd>
<dd>
Not yet fully implemented, it assumes that the keys are uniformly distributed between [0,(std::numeric_limits&lt;key_type&gt;::max)(). </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algo_2sort_file_8cpp-example.html#a2">algo/sort_file.cpp</a>, and <a class="el" href="algo_2test_stable_ksort_8cpp-example.html#a0">algo/test_stable_ksort.cpp</a>.</dd>
</dl>
<p>References <a class="el" href="classconfig.html#a7504010a38b6df3c96facaefd9970b52">config::disks_number()</a>, and <a class="el" href="classrequest__interface.html#a77f8ce33cba4957e580a9da2354eb1ed">request_interface::wait()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
