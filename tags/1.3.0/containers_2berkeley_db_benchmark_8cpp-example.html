<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Stxxl: containers/berkeley_db_benchmark.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>containers/berkeley_db_benchmark.cpp</h1>  </div>
</div>
<div class="contents">
<p>This is a benchmark mentioned in the paper R. Dementiev, L. Kettner, P. Sanders "STXXL: standard template library for XXL data sets" Software: Practice and Experience Volume 38, Issue 6, Pages 589-637, May 2008 DOI: 10.1002/spe.844</p>
<div class="fragment"><pre class="fragment"><span class="comment">/***************************************************************************</span>
<span class="comment"> *  containers/berkeley_db_benchmark.cpp</span>
<span class="comment"> *</span>
<span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2006 Roman Dementiev &lt;dementiev@ira.uka.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="comment"> **************************************************************************/</span>



<span class="preprocessor">#include &lt;stxxl/vector&gt;</span>
<span class="preprocessor">#include &lt;stxxl/map&gt;</span>
<span class="preprocessor">#include &lt;stxxl/timer&gt;</span>
<span class="preprocessor">#include &lt;stxxl/stream&gt;</span>


<span class="preprocessor">#include &lt;db_cxx.h&gt;</span>

<span class="preprocessor">#include &quot;app_config.h&quot;</span>
<span class="preprocessor">#include &lt;portability.h&gt;</span>
<span class="preprocessor">#include &lt;ami_btree.h&gt;</span>

<span class="preprocessor">#define BDB_BULK_SCAN</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define KEY_SIZE                8</span>
<span class="preprocessor"></span><span class="preprocessor">#define DATA_SIZE               32</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define NODE_BLOCK_SIZE         (32 * 1024)</span>
<span class="preprocessor"></span><span class="preprocessor">#define LEAF_BLOCK_SIZE         (32 * 1024)</span>
<span class="preprocessor"></span>

<span class="preprocessor">#define LEAF_BLOCK_SIZE         (32 * 1024)</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define TOTAL_CACHE_SIZE        (750 * 1024 * 1024)</span>
<span class="preprocessor"></span><span class="comment">//#define TOTAL_CACHE_SIZE      (150 * 1024 * 1024)</span>

<span class="comment">//#define NODE_CACHE_SIZE       (1 * (TOTAL_CACHE_SIZE / 40))</span>
<span class="comment">//#define LEAF_CACHE_SIZE       (39 * (TOTAL_CACHE_SIZE / 40))</span>

<span class="preprocessor">#define NODE_CACHE_SIZE         (64 * 1024 * 1024)</span>
<span class="preprocessor"></span><span class="preprocessor">#define LEAF_CACHE_SIZE         (TOTAL_CACHE_SIZE - NODE_CACHE_SIZE)</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define SORTER_MEM              (TOTAL_CACHE_SIZE - 1024 * 1024 * 2 * 4)</span>
<span class="preprocessor"></span>

<span class="preprocessor">#define SCAN_LIMIT(x)   (x)</span>
<span class="preprocessor"></span>
<span class="comment">//#define BDB_FILE &quot;/data3/bdb_file&quot;</span>
<span class="preprocessor">#define BDB_FILE &quot;/var/tmp/bdb_file&quot;</span>
<span class="preprocessor"></span>

<span class="comment">// BDB settings</span>
u_int32_t pagesize = LEAF_BLOCK_SIZE;
u_int bulkbufsize = 4 * 1024 * 1024;
u_int logbufsize = 8 * 1024 * 1024;
u_int cachesize = (TOTAL_CACHE_SIZE &lt; 500 * 1024 * 1024) ? (4 * (TOTAL_CACHE_SIZE / 5)) : (TOTAL_CACHE_SIZE - 100 * 1024 * 1024);
u_int datasize = DATA_SIZE;
u_int keysize = KEY_SIZE;
u_int numitems = 0;

<span class="keyword">const</span> <span class="keywordtype">char</span> * letters = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxuz&quot;</span>;

<span class="keyword">struct </span>my_key
{
    <span class="keywordtype">char</span> keybuf[KEY_SIZE];
};


std::ostream &amp; operator &lt;&lt; (std::ostream &amp; o, <span class="keyword">const</span> my_key &amp; obj)
{
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)
        o &lt;&lt; obj.keybuf[i];

    <span class="keywordflow">return</span> o;
}

<span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) == 0;
}

<span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) != 0;
}

<span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt; 0;
}

<span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &gt; 0;
}

<span class="keywordtype">bool</span> operator &lt;= (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt;= 0;
}

<span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)
{
    <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &gt;= 0;
}


<span class="keyword">struct </span>my_data
{
    <span class="keywordtype">char</span> databuf[DATA_SIZE];
};

std::ostream &amp; operator &lt;&lt; (std::ostream &amp; o, <span class="keyword">const</span> my_data &amp; obj)
{
    o &lt;&lt; <span class="stringliteral">&quot;DATA(size=&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(obj) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;

    <span class="keywordflow">return</span> o;
}

my_key min_key, max_key;

<span class="keyword">struct </span>comp_type : std::binary_function&lt;my_key, my_key, bool&gt;
{
    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> my_key &amp; a, <span class="keyword">const</span> my_key &amp; b)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> strncmp(a.keybuf, b.keybuf, KEY_SIZE) &lt; 0;
    }
    <span class="keyword">static</span> my_key max_value()
    {
        <span class="keywordflow">return</span> max_key;
    }
    <span class="keyword">static</span> my_key min_value()
    {
        <span class="keywordflow">return</span> min_key;
    }
};


<span class="comment">// Key type.</span>
<span class="keyword">typedef</span> my_key bkey_t;

<span class="comment">// Element type for the btree.</span>
<span class="keyword">struct </span>el_t {
    bkey_t key_;
    my_data data_;
    el_t(bkey_t k) : key_(k) { }
    el_t() { }
};
<span class="keyword">struct </span>key_from_el {
    bkey_t operator () (<span class="keyword">const</span> el_t &amp; v)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> v.key_;
    }
};


<span class="comment">// Temporary distinction btw UN*X and WIN, since there are some</span>
<span class="comment">// problems with the MMAP collection implementation.</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="keyword">typedef</span> AMI_btree&lt;bkey_t, el_t, less&lt;bkey_t&gt;, key_from_el, BTE_COLLECTION_UFS&gt; u_btree_t;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="keyword">typedef</span> AMI_btree&lt;bkey_t, el_t, less&lt;bkey_t&gt;, key_from_el&gt; u_btree_t;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="keywordtype">void</span> init()
{
    memset(max_key.keybuf, (std::numeric_limits&lt;unsigned char&gt;::max)(), KEY_SIZE);
    memset(min_key.keybuf, (std::numeric_limits&lt;unsigned char&gt;::min)(), KEY_SIZE);
}

<span class="keyword">typedef</span> stxxl::map&lt;my_key, my_data, comp_type, NODE_BLOCK_SIZE, LEAF_BLOCK_SIZE&gt; map_type;

<span class="preprocessor">#define REAL_NODE_BLOCK_SIZE map_type::node_block_type::raw_size</span>
<span class="preprocessor"></span><span class="preprocessor">#define REAL_LEAF_BLOCK_SIZE map_type::leaf_block_type::raw_size</span>
<span class="preprocessor"></span><span class="preprocessor">#define REAL_NODE_MELEMENTS map_type::node_block_type::size</span>
<span class="preprocessor"></span><span class="preprocessor">#define REAL_LEAF_MELEMENTS map_type::leaf_block_type::size</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;std::pair&lt;my_key, my_data&gt;, 1, 1&gt;::result vector_type;
<span class="comment">//typedef stxxl::vector&lt;std::pair&lt;my_key,my_data&gt;,1,stxxl::lru_pager&lt;1&gt;,512*1024&gt;  vector_type;</span>


<span class="comment">//#define KEYPOS        (i % KEY_SIZE)</span>
<span class="comment">//#define VALUE         (myrand() % 26)</span>


<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span><span class="keywordtype">unsigned</span> ran32State = 0xdeadbeef;
<span class="keyword">inline</span> <span class="keywordtype">unsigned</span> myrand()
{
    <span class="keywordflow">return</span> (ran32State = 1664525 * ran32State + 1013904223);
}
<span class="keyword">inline</span> <span class="keywordtype">void</span> rand_key(stxxl::int64 pos, my_key &amp; Key)
{
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)
        Key.keybuf[i] = letters[myrand() % 26];
}
<span class="preprocessor">#else // a longer pseudo random sequence</span>
<span class="preprocessor"></span><span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> ran32State = 0xdeadbeef;
<span class="keyword">inline</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> myrand()
{
    <span class="keywordflow">return</span> (ran32State = (ran32State * 0x5DEECE66DULL + 0xBULL) &amp; 0xFFFFFFFFFFFFULL);
}
<span class="keyword">inline</span> <span class="keywordtype">void</span> rand_key(stxxl::int64 <span class="comment">/*pos*/</span>, my_key &amp; Key)
{
    <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> r = myrand();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; KEY_SIZE; ++i)
    {
        Key.keybuf[i] = letters[r % 26];
        r &gt;&gt;= 5;
    }
}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> run_bdb_btree(stxxl::int64 ops)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = BDB_FILE;

    my_key key1_storage;
    my_data data1_storage;

    unlink(filename);

    memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(data1_storage.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);


    Db db(NULL, 0);             <span class="comment">// Instantiate the Db object</span>

    <span class="keywordflow">try</span> {
        db.set_errfile(stderr);
        db.set_pagesize(pagesize);
        db.set_cachesize(0, cachesize, 1);

        <span class="comment">// Open the database</span>
        db.open(NULL,           <span class="comment">// Transaction pointer</span>
                filename,       <span class="comment">// Database file name</span>
                NULL,           <span class="comment">// Optional logical database name</span>
                DB_BTREE,       <span class="comment">// Database access method</span>
                DB_CREATE,      <span class="comment">// Open flags</span>
                0);             <span class="comment">// File mode (using defaults)</span>


        <span class="comment">// here we start with the tests</span>
        Dbt key1(key1_storage.keybuf, KEY_SIZE);
        Dbt data1(data1_storage.databuf, DATA_SIZE);

        stxxl::timer Timer;
        stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;
        stxxl::int64 i;
        <span class="comment">//comp_type cmp_;</span>

        ran32State = 0xdeadbeef;


        DB_BTREE_STAT * dbstat;

        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);

        db.get_env()-&gt;memp_stat(NULL, NULL, DB_STAT_CLEAR);

        Timer.start();

        <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);
        }

        Timer.stop();
        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);
        STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        Timer.reset();
        Timer.start();


        Dbc * cursorp;
        db.cursor(NULL, &amp;cursorp, 0);

        <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
            Dbt datax(data1_storage.databuf, DATA_SIZE);

            cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE);
        }

        Timer.stop();
        STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        Timer.reset();

        Timer.start();

        stxxl::int64 n_scanned = 0;

        <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            my_key last_key = key1_storage;
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            <span class="keywordflow">if</span> (last_key &lt; key1_storage)
                std::swap(last_key, key1_storage);


            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
            Dbt datax(data1_storage.databuf, DATA_SIZE);

            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE) == DB_NOTFOUND)
                <span class="keywordflow">continue</span>;


            <span class="keywordflow">while</span> (*((my_key *)keyx.get_data()) &lt;= last_key)
            {
                ++n_scanned;
                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT) == DB_NOTFOUND)
                    <span class="keywordflow">break</span>;
            }

            <span class="keywordflow">if</span> (n_scanned &gt;= 10 * n_range_queries)
            {
                ++i;
                <span class="keywordflow">break</span>;
            }
        }

        n_range_queries = i;

        Timer.stop();
        <span class="keywordflow">if</span> (cursorp != NULL)
            cursorp-&gt;close();


        STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;
                  <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);

        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);


        ran32State = 0xdeadbeef;
        memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);

        Timer.reset();
        Timer.start();

        <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
            db.del(NULL, &amp;keyx, 0);
        }

        Timer.stop();
        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);
        STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        db.close(0);
    }
    <span class="keywordflow">catch</span> (DbException &amp; e)
    {
        STXXL_ERRMSG(<span class="stringliteral">&quot;DbException happened&quot;</span>);
    }
    <span class="keywordflow">catch</span> (std::exception &amp; e)
    {
        STXXL_ERRMSG(<span class="stringliteral">&quot;std::exception happened&quot;</span>);
    }

    unlink(filename);
}

<span class="keywordtype">void</span> run_stxxl_map(stxxl::int64 ops)
{
    map_type Map(NODE_CACHE_SIZE, LEAF_CACHE_SIZE);
    Map.enable_prefetching();
    stxxl::stats * Stats = stxxl::stats::get_instance();

    std::pair&lt;my_key, my_data&gt; element;

    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);


    stxxl::timer Timer;
    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;
    stxxl::int64 i;
    <span class="comment">//comp_type cmp_;</span>

    ran32State = 0xdeadbeef;

    <span class="comment">//stxxl::random_number32 myrand;</span>

    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());

    stxxl::stats_data stats_begin(*Stats);
    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        Map.insert(element);
    }

    Timer.stop();

    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());
    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    <span class="keyword">const</span> map_type &amp; CMap(Map);     <span class="comment">// const map reference</span>

    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        CMap.lower_bound(element.first);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_locates) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span>

    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        my_key begin_key = element.first;
        map_type::const_iterator begin = CMap.lower_bound(element.first);
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        map_type::const_iterator beyond = CMap.lower_bound(element.first);
        <span class="keywordflow">if</span> (element.first &lt; begin_key)
            std::swap(begin, beyond);

        <span class="keywordflow">while</span> (begin != beyond)
        {
            my_data tmp = begin-&gt;second;
            stxxl::STXXL_UNUSED(tmp);
            ++n_scanned;
            ++begin;
        }
        <span class="keywordflow">if</span> (n_scanned &gt;= 10 * n_range_queries)
        {
            ++i;
            <span class="keywordflow">break</span>;
        }
    }

    n_range_queries = i;

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;
              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);

    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);

    ran32State = 0xdeadbeef;
    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);

    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        Map.erase(element.first);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());
    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_deletes) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);
}

<span class="keyword">class </span>rand_key_gen
{
    stxxl::int64 counter;
    my_key &amp; current;
    stxxl::random_number32 myrand;
    rand_key_gen();

<span class="keyword">public</span>:
    <span class="keyword">typedef</span> my_key value_type;

    rand_key_gen(stxxl::int64 el, my_key &amp; cur) :
        counter(el), current(cur)
    {
        <span class="comment">//const stxxl::int64  &amp; i = counter;</span>
        <span class="comment">//current.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(counter, current);
    }
    <span class="keyword">const</span> my_key &amp; operator * () { <span class="keywordflow">return</span> current; }
    <span class="keyword">const</span> my_key * operator -&gt; () { <span class="keywordflow">return</span> &amp;current; }

    rand_key_gen &amp; operator ++ ()
    {
        --counter;
        <span class="comment">//const stxxl::int64  &amp; i = counter;</span>
        <span class="comment">//current.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(counter, current);
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> counter == 0; }
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> InputType&gt;
<span class="keyword">class </span>key2pair
{
    InputType &amp; in;
    std::pair&lt;my_key, my_data&gt; current;
    key2pair();

<span class="keyword">public</span>:
    <span class="keyword">typedef</span> std::pair&lt;my_key, my_data&gt; value_type;

    key2pair(InputType &amp; in_) : in(in_)
    {
        <span class="keywordflow">if</span> (!in.empty())
            current.first = *in;
    }
    <span class="keyword">const</span> value_type &amp; operator * () { <span class="keywordflow">return</span> current; }
    <span class="keyword">const</span> value_type * operator -&gt; () { <span class="keywordflow">return</span> &amp;current; }

    key2pair &amp; operator ++ ()
    {
        ++in;
        <span class="keywordflow">if</span> (!empty())
            current.first = *in;


        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> in.empty(); }
};

<span class="keywordtype">void</span> run_stxxl_map_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)
{
    stxxl::stats * Stats = stxxl::stats::get_instance();

    std::pair&lt;my_key, my_data&gt; element;

    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);

    stxxl::timer Timer;
    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;
    stxxl::int64 i;
    <span class="comment">//comp_type cmp_;</span>

    ran32State = 0xdeadbeef;

    <span class="comment">//stxxl::random_number32 myrand;</span>

    Timer.start();

    vector_type SortedSeq(n);
    <span class="keyword">const</span> vector_type &amp; CSortedSeq(SortedSeq);
    {
        rand_key_gen Gen(n, element.first);
        <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;
        sorter_type Sorter(Gen, comp_type(), SORTER_MEM);
        <span class="keyword">typedef</span> key2pair&lt;sorter_type&gt; key2pair_type;
        key2pair_type Key2Pair(Sorter);
        <a name="a0"></a><a class="code" href="group__streampack.html#gaad176c09a25788f4c27102efd738c3fc" title="Stores consecutively stream content to an output iterator.">stxxl::stream::materialize</a>(Key2Pair, SortedSeq.begin());
    }


    Timer.stop();

    STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt;
              (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);

    stxxl::stats_data stats_begin(*Stats);
    Timer.reset();
    Timer.start();

    <span class="comment">// bulk construction</span>
    map_type Map(CSortedSeq.begin(),
                 CSortedSeq.end(),
                 NODE_CACHE_SIZE, LEAF_CACHE_SIZE, <span class="keyword">true</span>);

    Timer.stop();


    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());
    STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    Map.print_statistics(cout);
    Map.reset_statistics();
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    Map.disable_prefetching();

    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        Map.insert(element);
    }

    Timer.stop();

    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());
    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    Map.print_statistics(cout);
    Map.reset_statistics();
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    <span class="keyword">const</span> map_type &amp; CMap(Map);     <span class="comment">// const map reference</span>

    Timer.reset();
    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        CMap.lower_bound(element.first);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    Map.print_statistics(cout);
    Map.reset_statistics();
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    Map.enable_prefetching();

    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span>

    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        my_key begin_key = element.first;
        map_type::const_iterator begin = CMap.lower_bound(element.first);
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        map_type::const_iterator beyond = CMap.lower_bound(element.first);
        <span class="keywordflow">if</span> (element.first &lt; begin_key)
            std::swap(begin, beyond);

        <span class="comment">/*</span>
<span class="comment">           STXXL_MSG(&quot;Looking     &quot;&lt;&lt;element.first&lt;&lt;&quot; scanned: &quot;&lt;&lt;n_scanned);</span>
<span class="comment"></span>
<span class="comment">           if(beyond==CMap.end())</span>
<span class="comment">           {</span>
<span class="comment">                STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;&quot;END&quot;);</span>
<span class="comment">           }</span>
<span class="comment">           else</span>
<span class="comment">           {</span>
<span class="comment">                STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;((element.first&gt;begin_key)?element.first:begin_key));</span>
<span class="comment">           }*/</span>

        <span class="keywordflow">while</span> (begin != beyond)
        {
            ++n_scanned;
            ++begin;
        }

        <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))
        {
            ++i;
            <span class="keywordflow">break</span>;
        }
    }

    n_range_queries = i;

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;
              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);

    Map.print_statistics(cout);
    Map.reset_statistics();
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);


    ran32State = 0xdeadbeef;
    memset(element.first.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.second.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);

    Map.disable_prefetching();

    stats_begin = stxxl::stats_data(*Stats);
    Timer.reset();
    Timer.start();

    <span class="keywordflow">for</span> (i = n_deletes; i &gt; 0; --i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.first);
        Map.erase(element.first);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; Map.size());
    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

    Map.print_statistics(cout);
    Map.reset_statistics();
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin);
}


<span class="keyword">typedef</span> AMI_STREAM&lt;el_t&gt; stream_t;

<span class="keywordtype">char</span> dummy;

<span class="keyword">class </span>MyFilter {
<span class="keyword">public</span>:
    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> el_t &amp; v)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        dummy += v.key_.keybuf[0];         <span class="comment">// touch element</span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
};


<span class="keywordtype">void</span> run_tpie_btree_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)
{
    el_t element;

    memset(element.key_.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.data_.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);

    <span class="comment">// Log debugging info from the application, but not from the library.</span>
    tpie_log_init(TPIE_LOG_APP_DEBUG);
    MM_manager.set_memory_limit(TOTAL_CACHE_SIZE);
    MM_manager.enforce_memory_limit();

    stream_t * is = <span class="keyword">new</span> stream_t;

    stxxl::timer Timer;
    stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;
    stxxl::int64 i;
    <span class="comment">//comp_type cmp_;</span>

    ran32State = 0xdeadbeef;

    <span class="comment">//stxxl::random_number32 myrand;</span>

    Timer.start();


    {
        rand_key_gen Gen(n, element.key_);
        <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;
        sorter_type Sorter(Gen, comp_type(), SORTER_MEM);
        <span class="comment">//typedef key2pair&lt;sorter_type&gt; key2pair_type;</span>
        <span class="comment">//key2pair_type Key2Pair(Sorter);</span>
        <span class="keywordflow">while</span> (!Sorter.empty())
        {
            is-&gt;write_item(*Sorter);
            ++Sorter;
        }
    }

    Timer.stop();


    STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt;
              (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);


    Timer.reset();
    Timer.start();

    <span class="comment">// bulk construction</span>
    u_btree_t * u_btree;
    AMI_btree_params params;
    params.node_block_factor = NODE_BLOCK_SIZE / 4096;
    params.leaf_block_factor = LEAF_BLOCK_SIZE / 4096;
    params.leaf_cache_size = LEAF_CACHE_SIZE / LEAF_BLOCK_SIZE;
    params.node_cache_size = NODE_CACHE_SIZE / NODE_BLOCK_SIZE;

    u_btree = <span class="keyword">new</span> u_btree_t(params);

    <span class="keyword">using</span> std::cout;
    <span class="keyword">using</span> std::cerr;

    <span class="keywordflow">if</span> (!u_btree-&gt;is_valid()) {
        cerr &lt;&lt; <span class="stringliteral">&quot;Error initializing btree. Aborting.\n&quot;</span>;
        <span class="keyword">delete</span> u_btree;
        exit(1);
    }

    <span class="keywordflow">if</span> (u_btree-&gt;load_sorted(is, 1.0, 1.0) != AMI_ERROR_NO_ERROR)
        cerr &lt;&lt; <span class="stringliteral">&quot;Error during bulk loading.\n&quot;</span>;


    Timer.stop();

    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());
    STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);


    Timer.reset();


    Timer.start();

    <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.key_);
        u_btree-&gt;insert(element);
    }

    Timer.stop();

    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());
    STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);


    Timer.reset();


    Timer.start();


    el_t result;
    <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.key_);
        u_btree-&gt;succ(element.key_, result);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);


    Timer.reset();


    Timer.start();

    stxxl::int64 n_scanned = 0; <span class="comment">//, skipped_qieries = 0;</span>
    MyFilter filter;

    <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)
    {
        rand_key(i, element.key_);
        my_key begin_key = element.key_;
        rand_key(i, element.key_);
        <span class="keywordflow">if</span> (element.key_ &lt; begin_key)
            n_scanned += u_btree-&gt;range_query(element.key_, begin_key, NULL, filter);

        <span class="keywordflow">else</span>
            n_scanned += u_btree-&gt;range_query(begin_key, element.key_, NULL, filter);


        <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))
        {
            ++i;
            <span class="keywordflow">break</span>;
        }
    }

    n_range_queries = i;

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;
              <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);


    ran32State = 0xdeadbeef;
    memset(element.key_.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(element.data_.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);

    Timer.reset();

    Timer.start();

    <span class="keywordflow">for</span> (i = n_deletes; i &gt; 0; --i)
    {
        <span class="comment">//element.first.keybuf[KEYPOS] = letters[VALUE];</span>
        rand_key(i, element.key_);
        u_btree-&gt;erase(element.key_);
    }

    Timer.stop();
    STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; u_btree-&gt;size());
    STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
              <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);
    <span class="keyword">delete</span> u_btree;
    <span class="keyword">delete</span> is;
}

<span class="keywordtype">void</span> run_bdb_btree_big(stxxl::int64 n, <span class="keywordtype">unsigned</span> ops)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * filename = BDB_FILE;

    my_key key1_storage;
    my_data data1_storage;

<span class="preprocessor">#ifdef BDB_BULK_SCAN</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> * bulk_buffer = <span class="keyword">new</span> <span class="keywordtype">int</span>[logbufsize / <span class="keyword">sizeof</span>(int)];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    unlink(filename);

    memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);
    memset(data1_storage.databuf, <span class="charliteral">&#39;b&#39;</span>, DATA_SIZE);


    Db db(NULL, 0);                   <span class="comment">// Instantiate the Db object</span>

    <span class="keywordflow">try</span> {
        <span class="comment">// here we start with the tests</span>
        Dbt key1(key1_storage.keybuf, KEY_SIZE);
        Dbt data1(data1_storage.databuf, DATA_SIZE);

        stxxl::timer Timer;
        stxxl::int64 n_inserts = ops, n_locates = ops, n_range_queries = ops, n_deletes = ops;
        stxxl::int64 i;
        <span class="comment">//comp_type cmp_;</span>

        ran32State = 0xdeadbeef;

        Timer.start();

        vector_type SortedSeq(n);
        <span class="comment">//const vector_type &amp; CSortedSeq(SortedSeq);</span>
        {
            rand_key_gen Gen(n, key1_storage);
            <span class="keyword">typedef</span> stxxl::stream::sort&lt;rand_key_gen, comp_type&gt; sorter_type;
            sorter_type Sorter(Gen, comp_type(), SORTER_MEM);
            <span class="keyword">typedef</span> key2pair&lt;sorter_type&gt; key2pair_type;
            key2pair_type Key2Pair(Sorter);
            <a class="code" href="group__streampack.html#gaad176c09a25788f4c27102efd738c3fc" title="Stores consecutively stream content to an output iterator.">stxxl::stream::materialize</a>(Key2Pair, SortedSeq.begin());
        }

        Timer.stop();

        STXXL_MSG(<span class="stringliteral">&quot;Finished sorting input. Elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span>);

        db.set_errfile(stderr);
        db.set_pagesize(pagesize);
        db.set_cachesize(0, cachesize, 10);

        STXXL_MSG(<span class="stringliteral">&quot;BDB cache size set.&quot;</span>);

        <span class="comment">// Open the database</span>
        db.open(NULL,           <span class="comment">// Transaction pointer</span>
                filename,       <span class="comment">// Database file name</span>
                NULL,           <span class="comment">// Optional logical database name</span>
                DB_BTREE,       <span class="comment">// Database access method</span>
                DB_CREATE,      <span class="comment">// Open flags</span>
                0);             <span class="comment">// File mode (using defaults)</span>

        db.get_env()-&gt;memp_stat(NULL, NULL, DB_STAT_CLEAR);

        Timer.reset();
        Timer.start();

        <span class="comment">// DBD does not have bulk construction</span>
        <span class="comment">// however inserting in sorted order might help</span>
        <span class="comment">// to improve performance</span>
        vector_type::const_iterator cit = SortedSeq.begin();
        <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i, ++cit)
        {
            key1_storage = cit-&gt;first;
            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);
        }

        Timer.stop();

        DB_BTREE_STAT * dbstat;
        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);
        STXXL_MSG(<span class="stringliteral">&quot;Construction elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.stat_print(0);
        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);


        Timer.reset();
        Timer.start();

        <span class="keywordflow">for</span> (i = 0; i &lt; n_inserts; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            db.put(NULL, &amp;key1, &amp;data1, DB_NOOVERWRITE);
        }

        Timer.stop();
        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);
        STXXL_MSG(<span class="stringliteral">&quot;Insertions elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_inserts) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.stat_print(0);
        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        Timer.reset();
        Timer.start();


        Dbc * cursorp;
        db.cursor(NULL, &amp;cursorp, 0);

        <span class="keywordflow">for</span> (i = 0; i &lt; n_locates; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
            Dbt datax(data1_storage.databuf, DATA_SIZE);

            cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE);
        }

        Timer.stop();
        STXXL_MSG(<span class="stringliteral">&quot;Locates elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.stat_print(0);
        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        Timer.reset();

        Timer.start();

        stxxl::int64 n_scanned = 0;

        <span class="keywordflow">for</span> (i = 0; i &lt; n_range_queries; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            my_key last_key = key1_storage;
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            <span class="keywordflow">if</span> (last_key &lt; key1_storage)
                std::swap(last_key, key1_storage);


            <span class="comment">//STXXL_MSG(&quot;Looking     &quot;&lt;&lt;key1_storage&lt;&lt;&quot; scanned: &quot;&lt;&lt;n_scanned);</span>
            <span class="comment">//STXXL_MSG(&quot;Upper bound &quot;&lt;&lt;last_key);</span>

            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
<span class="preprocessor">#ifdef BDB_BULK_SCAN</span>
<span class="preprocessor"></span>            Dbt datax(bulk_buffer, DATA_SIZE);
            datax.set_ulen(logbufsize);
            datax.set_flags(DB_DBT_USERMEM);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            Dbt datax(data1_storage.databuf, DATA_SIZE);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="preprocessor">#ifdef BDB_BULK_SCAN</span>
<span class="preprocessor"></span>            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE | DB_MULTIPLE_KEY) == DB_NOTFOUND)
                <span class="keywordflow">continue</span>;


            <span class="keywordflow">do</span>
            {
                DbMultipleKeyDataIterator BulkIterator(datax);
                Dbt key1, data1;
                <span class="keywordflow">while</span> (BulkIterator.next(key1, data1) &amp;&amp;
                       *((my_key *)key1.get_data()) &lt;= last_key)
                {
                    ++n_scanned;
                    <span class="comment">//STXXL_MSG(&quot;Result      &quot;&lt;&lt;*((my_key *)key1.get_data()));</span>
                }
                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT | DB_MULTIPLE_KEY) == DB_NOTFOUND)
                    <span class="keywordflow">break</span>;


                <span class="keywordflow">if</span> (*((my_key *)keyx.get_data()) &gt; last_key)
                {
                    <span class="keywordflow">break</span>;
                }
            } <span class="keywordflow">while</span> (1);

<span class="preprocessor">#else</span>
<span class="preprocessor"></span>            <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_SET_RANGE) == DB_NOTFOUND)
                <span class="keywordflow">continue</span>;

            <span class="keywordflow">while</span> (*((my_key *)keyx.get_data()) &lt;= last_key)
            {
                ++n_scanned;
                <span class="keywordflow">if</span> (cursorp-&gt;get(&amp;keyx, &amp;datax, DB_NEXT) == DB_NOTFOUND)
                    <span class="keywordflow">break</span>;
            }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

            <span class="keywordflow">if</span> (n_scanned &gt;= SCAN_LIMIT(n))
            {
                ++i;
                <span class="keywordflow">break</span>;
            }
        }

        n_range_queries = i;

        Timer.stop();
        <span class="keywordflow">if</span> (cursorp != NULL)
            cursorp-&gt;close();


        STXXL_MSG(<span class="stringliteral">&quot;Range query elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(n_scanned) / (Timer.mseconds() / 1000.)) &lt;&lt;
                  <span class="stringliteral">&quot; key/data pairs per sec, #queries &quot;</span> &lt;&lt; n_range_queries &lt;&lt; <span class="stringliteral">&quot; #scanned elements: &quot;</span> &lt;&lt; n_scanned);

        db.stat_print(0);
        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);


        ran32State = 0xdeadbeef;
        memset(key1_storage.keybuf, <span class="charliteral">&#39;a&#39;</span>, KEY_SIZE);

        Timer.reset();
        Timer.start();

        <span class="keywordflow">for</span> (i = 0; i &lt; n_deletes; ++i)
        {
            <span class="comment">//key1_storage.keybuf[KEYPOS] = letters[VALUE];</span>
            rand_key(i, key1_storage);
            Dbt keyx(key1_storage.keybuf, KEY_SIZE);
            db.del(NULL, &amp;keyx, 0);
        }

        Timer.stop();
        db.stat(NULL, &amp;dbstat, 0);
        STXXL_MSG(<span class="stringliteral">&quot;Records in map: &quot;</span> &lt;&lt; dbstat-&gt;bt_ndata);
        STXXL_MSG(<span class="stringliteral">&quot;Erase elapsed time: &quot;</span> &lt;&lt; (Timer.mseconds() / 1000.) &lt;&lt;
                  <span class="stringliteral">&quot; seconds : &quot;</span> &lt;&lt; (double(ops) / (Timer.mseconds() / 1000.)) &lt;&lt; <span class="stringliteral">&quot; key/data pairs per sec&quot;</span>);

        db.stat_print(0);
        db.get_env()-&gt;memp_stat_print(DB_STAT_CLEAR);

        db.close(0);
    }
    <span class="keywordflow">catch</span> (DbException &amp; e)
    {
        STXXL_ERRMSG(<span class="stringliteral">&quot;DbException happened&quot;</span>);
    }
    <span class="keywordflow">catch</span> (std::exception &amp; e)
    {
        STXXL_ERRMSG(<span class="stringliteral">&quot;std::exception happened&quot;</span>);
    }

    unlink(filename);

<span class="preprocessor">#ifdef BDB_BULK_SCAN</span>
<span class="preprocessor"></span>    <span class="keyword">delete</span>[]  bulk_buffer;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Real Node block size: &quot;</span> &lt;&lt; REAL_NODE_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);
    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Real Leaf block size: &quot;</span> &lt;&lt; REAL_LEAF_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);
    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Node max elements   : &quot;</span> &lt;&lt; REAL_NODE_MELEMENTS);
    STXXL_MSG(<span class="stringliteral">&quot;stxxl::map Leaf max elements   : &quot;</span> &lt;&lt; REAL_LEAF_MELEMENTS);
<span class="preprocessor">#ifdef STXXL_DIRECT_IO_OFF</span>
<span class="preprocessor"></span>    STXXL_MSG(<span class="stringliteral">&quot;STXXL_DIRECT_IO_OFF is defined&quot;</span>);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    STXXL_MSG(<span class="stringliteral">&quot;STXXL_DIRECT_IO_OFF is NOT defined&quot;</span>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordflow">if</span> (argc &lt; 3)
    {
        STXXL_MSG(<span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; version #ops&quot;</span>);
        STXXL_MSG(<span class="stringliteral">&quot;\t version = 1: test stxxl map&quot;</span>);
        STXXL_MSG(<span class="stringliteral">&quot;\t version = 2: test Berkeley DB btree&quot;</span>);
        STXXL_MSG(<span class="stringliteral">&quot;\t version = 3: big test stxxl map&quot;</span>);
        STXXL_MSG(<span class="stringliteral">&quot;\t version = 4: big test Berkeley DB btree&quot;</span>);
        STXXL_MSG(<span class="stringliteral">&quot;\t version = 5: big test TPIE btree&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    init();

    <span class="keywordtype">int</span> version = atoi(argv[1]);
    stxxl::int64 ops = stxxl::atoint64(argv[2]);

    STXXL_MSG(<span class="stringliteral">&quot;Running version      : &quot;</span> &lt;&lt; version);
    STXXL_MSG(<span class="stringliteral">&quot;Operations to perform: &quot;</span> &lt;&lt; ops);
    STXXL_MSG(<span class="stringliteral">&quot;Btree cache size     : &quot;</span> &lt;&lt; TOTAL_CACHE_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);
    STXXL_MSG(<span class="stringliteral">&quot;Leaf block size      : &quot;</span> &lt;&lt; LEAF_BLOCK_SIZE &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>);


    <span class="keywordflow">switch</span> (version)
    {
    <span class="keywordflow">case</span> 1:
        run_stxxl_map(ops);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
        run_bdb_btree(ops);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 3:
        run_stxxl_map_big(ops, 100000);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 4:
        run_bdb_btree_big(ops, 100000);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 5:
        run_tpie_btree_big(ops, 100000);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        STXXL_MSG(<span class="stringliteral">&quot;Unsupported version &quot;</span> &lt;&lt; version);
    }
}
</pre></div> </div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
