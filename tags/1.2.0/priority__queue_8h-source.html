<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Stxxl: priority_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
<h1>priority_queue.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *  include/stxxl/bits/containers/priority_queue.h</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *  Copyright (C) 1999 Peter Sanders &lt;sanders@mpi-sb.mpg.de&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *  Copyright (C) 2003, 2004, 2007 Roman Dementiev &lt;dementiev@mpi-sb.mpg.de&gt;</span>
<a name="l00008"></a>00008 <span class="comment"> *  Copyright (C) 2007 Johannes Singler &lt;singler@ira.uka.de&gt;</span>
<a name="l00009"></a>00009 <span class="comment"> *  Copyright (C) 2007, 2008 Andreas Beckmann &lt;beckmann@cs.uni-frankfurt.de&gt;</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00012"></a>00012 <span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00013"></a>00013 <span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00014"></a>00014 <span class="comment"> **************************************************************************/</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef STXXL_PRIORITY_QUEUE_HEADER</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_PRIORITY_QUEUE_HEADER</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;stxxl/bits/mng/mng.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;stxxl/bits/mng/prefetch_pool.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;stxxl/bits/mng/write_pool.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;stxxl/bits/common/tmeta.h&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 __STXXL_BEGIN_NAMESPACE
<a name="l00030"></a>00030 
<a name="l00034"></a>00034 
<a name="l00037"></a><a class="code" href="namespacepriority__queue__local.html">00037</a> <span class="keyword">namespace </span>priority_queue_local
<a name="l00038"></a>00038 {
<a name="l00045"></a>00045     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = std::vector&lt;_Tp&gt;,
<a name="l00046"></a>00046               <span class="keyword">typename</span> _Compare = std::less&lt;<span class="keyword">typename</span> _Sequence::value_type&gt; &gt;
<a name="l00047"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html">00047</a>     <span class="keyword">class </span><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html" title="Similar to std::priority_queue, with the following differences:Maximum size is fixed...">internal_priority_queue</a>
<a name="l00048"></a>00048     {
<a name="l00049"></a>00049         <span class="comment">// concept requirements</span>
<a name="l00050"></a>00050         <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::value_type _Sequence_value_type;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="keyword">public</span>:
<a name="l00053"></a>00053         <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::value_type value_type;
<a name="l00054"></a>00054         <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::reference reference;
<a name="l00055"></a>00055         <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::const_reference const_reference;
<a name="l00056"></a>00056         <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::size_type size_type;
<a name="l00057"></a>00057         <span class="keyword">typedef</span>          _Sequence container_type;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     <span class="keyword">protected</span>:
<a name="l00060"></a>00060         <span class="comment">//  See queue::c for notes on these names.</span>
<a name="l00061"></a>00061         _Sequence c;
<a name="l00062"></a>00062         _Compare comp;
<a name="l00063"></a>00063         size_type N;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="keyword">public</span>:
<a name="l00069"></a>00069         <span class="keyword">explicit</span>
<a name="l00070"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#cf86b27cbed53af1116e6187c59a428d">00070</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#cf86b27cbed53af1116e6187c59a428d" title="Default constructor creates no elements.">internal_priority_queue</a>(size_type capacity)
<a name="l00071"></a>00071             : c(capacity), N(0)
<a name="l00072"></a>00072         { }
<a name="l00073"></a>00073 
<a name="l00077"></a>00077         <span class="keywordtype">bool</span>
<a name="l00078"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#fa98d8acda86564ca76f14e31ae8240a">00078</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#fa98d8acda86564ca76f14e31ae8240a">empty</a>()<span class="keyword"> const</span>
<a name="l00079"></a>00079 <span class="keyword">        </span>{ <span class="keywordflow">return</span> N == 0; }
<a name="l00080"></a>00080 
<a name="l00082"></a>00082         size_type
<a name="l00083"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">00083</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">size</a>()<span class="keyword"> const</span>
<a name="l00084"></a>00084 <span class="keyword">        </span>{ <span class="keywordflow">return</span> N; }
<a name="l00085"></a>00085 
<a name="l00090"></a>00090         const_reference
<a name="l00091"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#b1f0a9ef161bdcaa4e623458946f8057">00091</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#b1f0a9ef161bdcaa4e623458946f8057">top</a>()<span class="keyword"> const</span>
<a name="l00092"></a>00092 <span class="keyword">        </span>{
<a name="l00093"></a>00093             <span class="keywordflow">return</span> c.front();
<a name="l00094"></a>00094         }
<a name="l00095"></a>00095 
<a name="l00104"></a>00104         <span class="keywordtype">void</span>
<a name="l00105"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55">00105</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55" title="Add data to the queue.">push</a>(<span class="keyword">const</span> value_type &amp; __x)
<a name="l00106"></a>00106         {
<a name="l00107"></a>00107             c[N] = __x;
<a name="l00108"></a>00108             ++N;
<a name="l00109"></a>00109             std::push_heap(c.begin(), c.begin() + N, comp);
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111 
<a name="l00123"></a>00123         <span class="keywordtype">void</span>
<a name="l00124"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#c10e71fe3141a39239c42693aa4ebadd">00124</a>         <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#c10e71fe3141a39239c42693aa4ebadd" title="Removes first element.">pop</a>()
<a name="l00125"></a>00125         {
<a name="l00126"></a>00126             std::pop_heap(c.begin(), c.begin() + N, comp);
<a name="l00127"></a>00127             --N;
<a name="l00128"></a>00128         }
<a name="l00129"></a>00129 
<a name="l00133"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#91872f7fcdd79a9f0bbb0fbc5d921b41">00133</a>         <span class="keywordtype">void</span> <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#91872f7fcdd79a9f0bbb0fbc5d921b41" title="Sort all contained elements, write result to target.">sort_to</a>(value_type * target)
<a name="l00134"></a>00134         {
<a name="l00135"></a>00135             <a class="code" href="group__stlalgo.html#g6037597e33eafc47a6a90cb971a11c82" title="External sorting routine for records that allow only comparisons.">std::sort</a>(c.begin(), c.begin() + N, comp);
<a name="l00136"></a>00136             std::reverse_copy(c.begin(), c.begin() + N, target);
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00142"></a><a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#3d09713e5d6dfdd0356879d875361a49">00142</a>         <span class="keywordtype">void</span> <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#3d09713e5d6dfdd0356879d875361a49" title="Remove all contained elements.">clear</a>()
<a name="l00143"></a>00143         {
<a name="l00144"></a>00144             N = 0;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146     };
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00150"></a>00150 <span class="comment">// auxiliary functions</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">// merge sz element from the two sentinel terminated input</span>
<a name="l00153"></a>00153 <span class="comment">// sequences from0 and from1 to "to"</span>
<a name="l00154"></a>00154 <span class="comment">// advance from0 and from1 accordingly</span>
<a name="l00155"></a>00155 <span class="comment">// require: at least sz nonsentinel elements available in from0, from1</span>
<a name="l00156"></a>00156 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00157"></a>00157 <span class="comment">//   *(fromx + sz) is before the end of fromx</span>
<a name="l00158"></a>00158     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Cmp_&gt;
<a name="l00159"></a>00159     <span class="keywordtype">void</span> merge_iterator(
<a name="l00160"></a>00160         InputIterator &amp; from0,
<a name="l00161"></a>00161         InputIterator &amp; from1,
<a name="l00162"></a>00162         OutputIterator to, unsigned_type sz, Cmp_ cmp)
<a name="l00163"></a>00163     {
<a name="l00164"></a>00164         OutputIterator done = to + sz;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="keywordflow">while</span> (to != done)
<a name="l00167"></a>00167         {
<a name="l00168"></a>00168             <span class="keywordflow">if</span> (cmp(*from0, *from1))
<a name="l00169"></a>00169             {
<a name="l00170"></a>00170                 *to = *from1;
<a name="l00171"></a>00171                 ++from1;
<a name="l00172"></a>00172             }
<a name="l00173"></a>00173             <span class="keywordflow">else</span>
<a name="l00174"></a>00174             {
<a name="l00175"></a>00175                 *to = *from0;
<a name="l00176"></a>00176                 ++from0;
<a name="l00177"></a>00177             }
<a name="l00178"></a>00178             ++to;
<a name="l00179"></a>00179         }
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">// merge sz element from the three sentinel terminated input</span>
<a name="l00183"></a>00183 <span class="comment">// sequences from0, from1 and from2 to "to"</span>
<a name="l00184"></a>00184 <span class="comment">// advance from0, from1 and from2 accordingly</span>
<a name="l00185"></a>00185 <span class="comment">// require: at least sz nonsentinel elements available in from0, from1 and from2</span>
<a name="l00186"></a>00186 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00187"></a>00187 <span class="comment">//   *(fromx + sz) is before the end of fromx</span>
<a name="l00188"></a>00188     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Cmp_&gt;
<a name="l00189"></a>00189     <span class="keywordtype">void</span> merge3_iterator(
<a name="l00190"></a>00190         InputIterator &amp; from0,
<a name="l00191"></a>00191         InputIterator &amp; from1,
<a name="l00192"></a>00192         InputIterator &amp; from2,
<a name="l00193"></a>00193         OutputIterator to, unsigned_type sz, Cmp_ cmp)
<a name="l00194"></a>00194     {
<a name="l00195"></a>00195         OutputIterator done = to + sz;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         <span class="keywordflow">if</span> (cmp(*from1, *from0)) {
<a name="l00198"></a>00198             <span class="keywordflow">if</span> (cmp(*from2, *from1)) {
<a name="l00199"></a>00199                 <span class="keywordflow">goto</span> s012;
<a name="l00200"></a>00200             }
<a name="l00201"></a>00201             <span class="keywordflow">else</span> {
<a name="l00202"></a>00202                 <span class="keywordflow">if</span> (cmp(*from0, *from2)) {
<a name="l00203"></a>00203                     <span class="keywordflow">goto</span> s201;
<a name="l00204"></a>00204                 }
<a name="l00205"></a>00205                 <span class="keywordflow">else</span> {
<a name="l00206"></a>00206                     <span class="keywordflow">goto</span> s021;
<a name="l00207"></a>00207                 }
<a name="l00208"></a>00208             }
<a name="l00209"></a>00209         } <span class="keywordflow">else</span> {
<a name="l00210"></a>00210             <span class="keywordflow">if</span> (cmp(*from2, *from1)) {
<a name="l00211"></a>00211                 <span class="keywordflow">if</span> (cmp(*from2, *from0)) {
<a name="l00212"></a>00212                     <span class="keywordflow">goto</span> s102;
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214                 <span class="keywordflow">else</span> {
<a name="l00215"></a>00215                     <span class="keywordflow">goto</span> s120;
<a name="l00216"></a>00216                 }
<a name="l00217"></a>00217             } <span class="keywordflow">else</span> {
<a name="l00218"></a>00218                 <span class="keywordflow">goto</span> s210;
<a name="l00219"></a>00219             }
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="preprocessor">#define Merge3Case(a, b, c) \</span>
<a name="l00223"></a>00223 <span class="preprocessor">    s ## a ## b ## c : \</span>
<a name="l00224"></a>00224 <span class="preprocessor">    if (to == done) \</span>
<a name="l00225"></a>00225 <span class="preprocessor">        return;\</span>
<a name="l00226"></a>00226 <span class="preprocessor">    *to = *from ## a; \</span>
<a name="l00227"></a>00227 <span class="preprocessor">    ++to; \</span>
<a name="l00228"></a>00228 <span class="preprocessor">    ++from ## a; \</span>
<a name="l00229"></a>00229 <span class="preprocessor">    if (cmp(*from ## b, *from ## a)) \</span>
<a name="l00230"></a>00230 <span class="preprocessor">        goto s ## a ## b ## c;\</span>
<a name="l00231"></a>00231 <span class="preprocessor">    if (cmp(*from ## c, *from ## a)) \</span>
<a name="l00232"></a>00232 <span class="preprocessor">        goto s ## b ## a ## c;\</span>
<a name="l00233"></a>00233 <span class="preprocessor">    goto s ## b ## c ## a;</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>
<a name="l00235"></a>00235         <span class="comment">// the order is chosen in such a way that</span>
<a name="l00236"></a>00236         <span class="comment">// four of the trailing gotos can be eliminated by the optimizer</span>
<a name="l00237"></a>00237         Merge3Case(0, 1, 2);
<a name="l00238"></a>00238         Merge3Case(1, 2, 0);
<a name="l00239"></a>00239         Merge3Case(2, 0, 1);
<a name="l00240"></a>00240         Merge3Case(1, 0, 2);
<a name="l00241"></a>00241         Merge3Case(0, 2, 1);
<a name="l00242"></a>00242         Merge3Case(2, 1, 0);
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="preprocessor">#undef Merge3Case</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span>    }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">// merge sz element from the four sentinel terminated input</span>
<a name="l00249"></a>00249 <span class="comment">// sequences from0, from1, from2 and from3 to "to"</span>
<a name="l00250"></a>00250 <span class="comment">// advance from0, from1, from2 and from3 accordingly</span>
<a name="l00251"></a>00251 <span class="comment">// require: at least sz nonsentinel elements available in from0, from1, from2 and from3</span>
<a name="l00252"></a>00252 <span class="comment">// require: to may overwrite one of the sources as long as</span>
<a name="l00253"></a>00253 <span class="comment">//   *(fromx + sz) is before the end of fromx</span>
<a name="l00254"></a>00254     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> Cmp_&gt;
<a name="l00255"></a>00255     <span class="keywordtype">void</span> merge4_iterator(
<a name="l00256"></a>00256         InputIterator &amp; from0,
<a name="l00257"></a>00257         InputIterator &amp; from1,
<a name="l00258"></a>00258         InputIterator &amp; from2,
<a name="l00259"></a>00259         InputIterator &amp; from3,
<a name="l00260"></a>00260         OutputIterator to, unsigned_type sz, Cmp_ cmp)
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262         OutputIterator done = to + sz;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="preprocessor">#define StartMerge4(a, b, c, d) \</span>
<a name="l00265"></a>00265 <span class="preprocessor">    if ((!cmp(*from ## a, *from ## b)) &amp;&amp; (!cmp(*from ## b, *from ## c)) &amp;&amp; (!cmp(*from ## c, *from ## d))) \</span>
<a name="l00266"></a>00266 <span class="preprocessor">        goto s ## a ## b ## c ## d;</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>
<a name="l00268"></a>00268         <span class="comment">// b&gt;a c&gt;b d&gt;c</span>
<a name="l00269"></a>00269         <span class="comment">// a&lt;b b&lt;c c&lt;d</span>
<a name="l00270"></a>00270         <span class="comment">// a&lt;=b b&lt;=c c&lt;=d</span>
<a name="l00271"></a>00271         <span class="comment">// !(a&gt;b) !(b&gt;c) !(c&gt;d)</span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         StartMerge4(0, 1, 2, 3);
<a name="l00274"></a>00274         StartMerge4(1, 2, 3, 0);
<a name="l00275"></a>00275         StartMerge4(2, 3, 0, 1);
<a name="l00276"></a>00276         StartMerge4(3, 0, 1, 2);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         StartMerge4(0, 3, 1, 2);
<a name="l00279"></a>00279         StartMerge4(3, 1, 2, 0);
<a name="l00280"></a>00280         StartMerge4(1, 2, 0, 3);
<a name="l00281"></a>00281         StartMerge4(2, 0, 3, 1);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283         StartMerge4(0, 2, 3, 1);
<a name="l00284"></a>00284         StartMerge4(2, 3, 1, 0);
<a name="l00285"></a>00285         StartMerge4(3, 1, 0, 2);
<a name="l00286"></a>00286         StartMerge4(1, 0, 2, 3);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         StartMerge4(2, 0, 1, 3);
<a name="l00289"></a>00289         StartMerge4(0, 1, 3, 2);
<a name="l00290"></a>00290         StartMerge4(1, 3, 2, 0);
<a name="l00291"></a>00291         StartMerge4(3, 2, 0, 1);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         StartMerge4(3, 0, 2, 1);
<a name="l00294"></a>00294         StartMerge4(0, 2, 1, 3);
<a name="l00295"></a>00295         StartMerge4(2, 1, 3, 0);
<a name="l00296"></a>00296         StartMerge4(1, 3, 0, 2);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         StartMerge4(1, 0, 3, 2);
<a name="l00299"></a>00299         StartMerge4(0, 3, 2, 1);
<a name="l00300"></a>00300         StartMerge4(3, 2, 1, 0);
<a name="l00301"></a>00301         StartMerge4(2, 1, 0, 3);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="preprocessor">#define Merge4Case(a, b, c, d) \</span>
<a name="l00304"></a>00304 <span class="preprocessor">    s ## a ## b ## c ## d : \</span>
<a name="l00305"></a>00305 <span class="preprocessor">    if (to == done) \</span>
<a name="l00306"></a>00306 <span class="preprocessor">        return;\</span>
<a name="l00307"></a>00307 <span class="preprocessor">    *to = *from ## a; \</span>
<a name="l00308"></a>00308 <span class="preprocessor">    ++to; \</span>
<a name="l00309"></a>00309 <span class="preprocessor">    ++from ## a; \</span>
<a name="l00310"></a>00310 <span class="preprocessor">    if (cmp(*from ## c, *from ## a)) \</span>
<a name="l00311"></a>00311 <span class="preprocessor">    { \</span>
<a name="l00312"></a>00312 <span class="preprocessor">        if (cmp(*from ## b, *from ## a)) \</span>
<a name="l00313"></a>00313 <span class="preprocessor">            goto s ## a ## b ## c ## d;\</span>
<a name="l00314"></a>00314 <span class="preprocessor">        else \</span>
<a name="l00315"></a>00315 <span class="preprocessor">            goto s ## b ## a ## c ## d;\</span>
<a name="l00316"></a>00316 <span class="preprocessor">    } \</span>
<a name="l00317"></a>00317 <span class="preprocessor">    else \</span>
<a name="l00318"></a>00318 <span class="preprocessor">    { \</span>
<a name="l00319"></a>00319 <span class="preprocessor">        if (cmp(*from ## d, *from ## a)) \</span>
<a name="l00320"></a>00320 <span class="preprocessor">            goto s ## b ## c ## a ## d;\</span>
<a name="l00321"></a>00321 <span class="preprocessor">        else \</span>
<a name="l00322"></a>00322 <span class="preprocessor">            goto s ## b ## c ## d ## a;\</span>
<a name="l00323"></a>00323 <span class="preprocessor">    }</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span>
<a name="l00325"></a>00325         Merge4Case(0, 1, 2, 3);
<a name="l00326"></a>00326         Merge4Case(1, 2, 3, 0);
<a name="l00327"></a>00327         Merge4Case(2, 3, 0, 1);
<a name="l00328"></a>00328         Merge4Case(3, 0, 1, 2);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330         Merge4Case(0, 3, 1, 2);
<a name="l00331"></a>00331         Merge4Case(3, 1, 2, 0);
<a name="l00332"></a>00332         Merge4Case(1, 2, 0, 3);
<a name="l00333"></a>00333         Merge4Case(2, 0, 3, 1);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         Merge4Case(0, 2, 3, 1);
<a name="l00336"></a>00336         Merge4Case(2, 3, 1, 0);
<a name="l00337"></a>00337         Merge4Case(3, 1, 0, 2);
<a name="l00338"></a>00338         Merge4Case(1, 0, 2, 3);
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         Merge4Case(2, 0, 1, 3);
<a name="l00341"></a>00341         Merge4Case(0, 1, 3, 2);
<a name="l00342"></a>00342         Merge4Case(1, 3, 2, 0);
<a name="l00343"></a>00343         Merge4Case(3, 2, 0, 1);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345         Merge4Case(3, 0, 2, 1);
<a name="l00346"></a>00346         Merge4Case(0, 2, 1, 3);
<a name="l00347"></a>00347         Merge4Case(2, 1, 3, 0);
<a name="l00348"></a>00348         Merge4Case(1, 3, 0, 2);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         Merge4Case(1, 0, 3, 2);
<a name="l00351"></a>00351         Merge4Case(0, 3, 2, 1);
<a name="l00352"></a>00352         Merge4Case(3, 2, 1, 0);
<a name="l00353"></a>00353         Merge4Case(2, 1, 0, 3);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="preprocessor">#undef StartMerge4</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span><span class="preprocessor">#undef Merge4Case</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>    }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 
<a name="l00365"></a>00365     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tp_, <span class="keywordtype">unsigned</span>_type max_size_&gt;
<a name="l00366"></a><a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html">00366</a>     <span class="keyword">class </span><a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html" title="Similar to std::stack, with the following differences:Maximum size is fixed at compilation...">internal_bounded_stack</a>
<a name="l00367"></a>00367     {
<a name="l00368"></a>00368         <span class="keyword">typedef</span> Tp_ value_type;
<a name="l00369"></a>00369         <span class="keyword">typedef</span> unsigned_type size_type;
<a name="l00370"></a>00370         <span class="keyword">enum</span> { max_size = max_size_ };
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         size_type size_;
<a name="l00373"></a>00373         value_type array[max_size];
<a name="l00374"></a>00374 
<a name="l00375"></a>00375     <span class="keyword">public</span>:
<a name="l00376"></a>00376         <a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html" title="Similar to std::stack, with the following differences:Maximum size is fixed at compilation...">internal_bounded_stack</a>() : size_(0) { }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; x)
<a name="l00379"></a>00379         {
<a name="l00380"></a>00380             assert(size_ &lt; max_size);
<a name="l00381"></a>00381             array[size_++] = x;
<a name="l00382"></a>00382         }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
<a name="l00385"></a>00385 <span class="keyword">        </span>{
<a name="l00386"></a>00386             assert(size_ &gt; 0);
<a name="l00387"></a>00387             <span class="keywordflow">return</span> array[size_ - 1];
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="keywordtype">void</span> pop()
<a name="l00391"></a>00391         {
<a name="l00392"></a>00392             assert(size_ &gt; 0);
<a name="l00393"></a>00393             --size_;
<a name="l00394"></a>00394         }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordtype">void</span> clear()
<a name="l00397"></a>00397         {
<a name="l00398"></a>00398             size_ = 0;
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         size_type size()<span class="keyword"> const</span>
<a name="l00402"></a>00402 <span class="keyword">        </span>{
<a name="l00403"></a>00403             <span class="keywordflow">return</span> size_;
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<a name="l00407"></a>00407 <span class="keyword">        </span>{
<a name="l00408"></a>00408             <span class="keywordflow">return</span> size_ == 0;
<a name="l00409"></a>00409         }
<a name="l00410"></a>00410     };
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00417"></a>00417     <span class="keyword">template</span> &lt;<span class="keyword">class </span>BlockType_,
<a name="l00418"></a>00418               <span class="keyword">class </span>Cmp_,
<a name="l00419"></a>00419               <span class="keywordtype">unsigned</span> Arity_,
<a name="l00420"></a>00420               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00421"></a><a class="code" href="classpriority__queue__local_1_1ext__merger.html">00421</a>     <span class="keyword">class </span><a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a> : <span class="keyword">private</span> noncopyable
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423     <span class="keyword">public</span>:
<a name="l00424"></a>00424         <span class="keyword">typedef</span> stxxl::uint64 size_type;
<a name="l00425"></a>00425         <span class="keyword">typedef</span> BlockType_ block_type;
<a name="l00426"></a>00426         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
<a name="l00427"></a>00427         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
<a name="l00428"></a>00428         <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l00429"></a>00429         <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
<a name="l00430"></a>00430         <span class="keyword">typedef</span> value_type Element;
<a name="l00431"></a>00431         <span class="keyword">typedef</span> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">typed_block&lt;sizeof(value_type), value_type&gt;</a> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">sentinel_block_type</a>;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="comment">// KNKMAX / 2  &lt;  arity  &lt;=  KNKMAX</span>
<a name="l00434"></a>00434         <span class="keyword">enum</span> { arity = Arity_, KNKMAX = 1UL &lt;&lt; (LOG2&lt;Arity_&gt;::ceil) };
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         block_type * convert_block_pointer(<a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">sentinel_block_type</a> * arg)
<a name="l00437"></a>00437         {
<a name="l00438"></a>00438             <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>block_type *<span class="keyword">&gt;</span>(arg);
<a name="l00439"></a>00439         }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     <span class="keyword">protected</span>:
<a name="l00442"></a>00442         comparator_type cmp;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00445"></a>00445 <span class="keyword">        </span>{
<a name="l00446"></a>00446             <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a)); <span class="comment">// a &lt;= cmp.min_value()</span>
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00450"></a>00450 <span class="keyword">        </span>{
<a name="l00451"></a>00451             <span class="keywordflow">return</span> cmp(cmp.min_value(), a); <span class="comment">// a &gt; cmp.min_value()</span>
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454         <span class="keyword">struct </span>sequence_state : <span class="keyword">private</span> noncopyable
<a name="l00455"></a>00455         {
<a name="l00456"></a>00456             unsigned_type current;      <span class="comment">//current index</span>
<a name="l00457"></a>00457             block_type * block;         <span class="comment">//current block</span>
<a name="l00458"></a>00458             std::list&lt;bid_type&gt; * bids; <span class="comment">//list of blocks forming this sequence</span>
<a name="l00459"></a>00459             comparator_type cmp;
<a name="l00460"></a>00460             <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a> * merger;
<a name="l00461"></a>00461             <span class="keywordtype">bool</span> allocated;
<a name="l00462"></a>00462 
<a name="l00464"></a>00464             <span class="keyword">const</span> value_type &amp; operator * ()<span class="keyword"> const</span>
<a name="l00465"></a>00465 <span class="keyword">            </span>{
<a name="l00466"></a>00466                 <span class="keywordflow">return</span> (*block)[current];
<a name="l00467"></a>00467             }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469             sequence_state() : bids(NULL), allocated(<span class="keyword">false</span>)
<a name="l00470"></a>00470             { }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472             ~sequence_state()
<a name="l00473"></a>00473             {
<a name="l00474"></a>00474                 STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_state::~sequence_state()"</span>);
<a name="l00475"></a>00475                 <span class="keywordflow">if</span> (bids != NULL)
<a name="l00476"></a>00476                 {
<a name="l00477"></a>00477                     <a class="code" href="classblock__manager.html" title="Block manager class.">block_manager</a> * bm = <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>();
<a name="l00478"></a>00478                     bm-&gt;<a class="code" href="group__mnglayer.html#g0a41492a2faef107fb3c5a7c1ce5ee2d" title="Deallocates blocks.">delete_blocks</a>(bids-&gt;begin(), bids-&gt;end());
<a name="l00479"></a>00479                     <span class="keyword">delete</span> bids;
<a name="l00480"></a>00480                 }
<a name="l00481"></a>00481             }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483             <span class="keywordtype">void</span> make_inf()
<a name="l00484"></a>00484             {
<a name="l00485"></a>00485                 current = 0;
<a name="l00486"></a>00486                 (*block)[0] = cmp.min_value();
<a name="l00487"></a>00487             }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489             <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00490"></a>00490 <span class="keyword">            </span>{
<a name="l00491"></a>00491                 <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a));
<a name="l00492"></a>00492             }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494             <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)<span class="keyword"> const</span>
<a name="l00495"></a>00495 <span class="keyword">            </span>{
<a name="l00496"></a>00496                 <span class="keywordflow">return</span> cmp(cmp.min_value(), a);
<a name="l00497"></a>00497             }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499             <span class="keywordtype">void</span> swap(sequence_state &amp; obj)
<a name="l00500"></a>00500             {
<a name="l00501"></a>00501                 <span class="keywordflow">if</span> (&amp;obj != <span class="keyword">this</span>)
<a name="l00502"></a>00502                 {
<a name="l00503"></a>00503                     std::swap(current, obj.current);
<a name="l00504"></a>00504                     std::swap(block, obj.block);
<a name="l00505"></a>00505                     std::swap(bids, obj.bids);
<a name="l00506"></a>00506                     assert(merger == obj.merger);
<a name="l00507"></a>00507                     std::swap(allocated, obj.allocated);
<a name="l00508"></a>00508                 }
<a name="l00509"></a>00509             }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511             sequence_state &amp; operator ++ ()
<a name="l00512"></a>00512             {
<a name="l00513"></a>00513                 assert(not_sentinel((*block)[current]));
<a name="l00514"></a>00514                 assert(current &lt; block-&gt;size);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                 ++current;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518                 <span class="keywordflow">if</span> (current == block-&gt;size)
<a name="l00519"></a>00519                 {
<a name="l00520"></a>00520                     STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_state operator++ crossing block border "</span>);
<a name="l00521"></a>00521                     <span class="comment">// go to the next block</span>
<a name="l00522"></a>00522                     assert(bids != NULL);
<a name="l00523"></a>00523                     <span class="keywordflow">if</span> (bids-&gt;empty()) <span class="comment">// if there is no next block</span>
<a name="l00524"></a>00524                     {
<a name="l00525"></a>00525                         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_state operator++ it was the last block in the sequence "</span>);
<a name="l00526"></a>00526                         <span class="keyword">delete</span> bids;
<a name="l00527"></a>00527                         bids = NULL;
<a name="l00528"></a>00528                         make_inf();
<a name="l00529"></a>00529                     }
<a name="l00530"></a>00530                     <span class="keywordflow">else</span>
<a name="l00531"></a>00531                     {
<a name="l00532"></a>00532                         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_state operator++ there is another block "</span>);
<a name="l00533"></a>00533                         bid_type bid = bids-&gt;front();
<a name="l00534"></a>00534                         bids-&gt;pop_front();
<a name="l00535"></a>00535                         <span class="keywordflow">if</span> (!(bids-&gt;empty()))
<a name="l00536"></a>00536                         {
<a name="l00537"></a>00537                             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger sequence_state operator++ one more block exists in a sequence: "</span> &lt;&lt;
<a name="l00538"></a>00538                                            <span class="stringliteral">"flushing this block in write cache (if not written yet) and giving hint to prefetcher"</span>);
<a name="l00539"></a>00539                             bid_type next_bid = bids-&gt;front();
<a name="l00540"></a>00540                             <span class="comment">//Hint next block of sequence.</span>
<a name="l00541"></a>00541                             <span class="comment">//This is mandatory to ensure proper synchronization between prefetch pool and write pool.</span>
<a name="l00542"></a>00542                             merger-&gt;p_pool-&gt;hint(next_bid, *(merger-&gt;w_pool));
<a name="l00543"></a>00543                         }
<a name="l00544"></a>00544                         merger-&gt;p_pool-&gt;read(block, bid)-&gt;wait();
<a name="l00545"></a>00545                         STXXL_VERBOSE2(<span class="stringliteral">"first element of read block "</span> &lt;&lt; bid &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; *(block-&gt;begin()) &lt;&lt; <span class="stringliteral">" cached in "</span> &lt;&lt; block);
<a name="l00546"></a>00546                         <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>()-&gt;<a class="code" href="group__mnglayer.html#g021e2ef7f3d56eb6dda56958ff5e0739" title="Deallocates a block.">delete_block</a>(bid);
<a name="l00547"></a>00547                         current = 0;
<a name="l00548"></a>00548                     }
<a name="l00549"></a>00549                 }
<a name="l00550"></a>00550                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00551"></a>00551             }
<a name="l00552"></a>00552         };
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <span class="comment">//a pair consisting a value</span>
<a name="l00556"></a>00556         <span class="keyword">struct </span>Entry
<a name="l00557"></a>00557         {
<a name="l00558"></a>00558             value_type key;      <span class="comment">// Key of Loser element (winner for 0)</span>
<a name="l00559"></a>00559             unsigned_type index; <span class="comment">// the number of losing segment</span>
<a name="l00560"></a>00560         };
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         size_type size_;         <span class="comment">// total number of elements stored</span>
<a name="l00563"></a>00563         unsigned_type logK;      <span class="comment">// log of current tree size</span>
<a name="l00564"></a>00564         unsigned_type k;         <span class="comment">// invariant (k == 1 &lt;&lt; logK), always a power of two</span>
<a name="l00565"></a>00565         <span class="comment">// only entries 0 .. arity-1 may hold actual sequences, the other</span>
<a name="l00566"></a>00566         <span class="comment">// entries arity .. KNKMAX-1 are sentinels to make the size of the tree</span>
<a name="l00567"></a>00567         <span class="comment">// a power of two always</span>
<a name="l00568"></a>00568 
<a name="l00569"></a>00569         <span class="comment">// stack of empty segment indices</span>
<a name="l00570"></a>00570         <a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html" title="Similar to std::stack, with the following differences:Maximum size is fixed at compilation...">internal_bounded_stack&lt;unsigned_type, arity&gt;</a> free_segments;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="comment">// upper levels of loser trees</span>
<a name="l00573"></a>00573         <span class="comment">// entry[0] contains the winner info</span>
<a name="l00574"></a>00574         Entry entry[KNKMAX];
<a name="l00575"></a>00575 
<a name="l00576"></a>00576         <span class="comment">// leaf information</span>
<a name="l00577"></a>00577         <span class="comment">// note that Knuth uses indices k..k-1</span>
<a name="l00578"></a>00578         <span class="comment">// while we use 0..k-1</span>
<a name="l00579"></a>00579         sequence_state states[KNKMAX]; <span class="comment">// sequence including current position, dereference gives current element</span>
<a name="l00580"></a>00580 
<a name="l00581"></a>00581         <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> * p_pool;
<a name="l00582"></a>00582         <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> * w_pool;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584         <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">sentinel_block_type</a> sentinel_block;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="keyword">public</span>:
<a name="l00587"></a>00587         <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a>() :
<a name="l00588"></a>00588             size_(0), logK(0), k(1), p_pool(0), w_pool(0)
<a name="l00589"></a>00589         {
<a name="l00590"></a>00590             init();
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a>(<a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> * p_pool_,
<a name="l00594"></a>00594                    <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> * w_pool_) :
<a name="l00595"></a>00595             size_(0), logK(0), k(1),
<a name="l00596"></a>00596             p_pool(p_pool_),
<a name="l00597"></a>00597             w_pool(w_pool_)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599             init();
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         <span class="keyword">virtual</span> ~<a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a>()
<a name="l00603"></a>00603         {
<a name="l00604"></a>00604             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::~ext_merger()"</span>);
<a name="l00605"></a>00605             <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; arity; ++i)
<a name="l00606"></a>00606             {
<a name="l00607"></a>00607                 <span class="keyword">delete</span> states[i].block;
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="keywordtype">void</span> set_pools(<a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> * p_pool_,
<a name="l00612"></a>00612                        <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> * w_pool_)
<a name="l00613"></a>00613         {
<a name="l00614"></a>00614             p_pool = p_pool_;
<a name="l00615"></a>00615             w_pool = w_pool_;
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <span class="keyword">private</span>:
<a name="l00619"></a>00619         <span class="keywordtype">void</span> init()
<a name="l00620"></a>00620         {
<a name="l00621"></a>00621             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::init()"</span>);
<a name="l00622"></a>00622             assert(!cmp(cmp.min_value(), cmp.min_value())); <span class="comment">// verify strict weak ordering</span>
<a name="l00623"></a>00623 
<a name="l00624"></a>00624             sentinel_block[0] = cmp.min_value();
<a name="l00625"></a>00625 
<a name="l00626"></a>00626             <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; KNKMAX; ++i)
<a name="l00627"></a>00627             {
<a name="l00628"></a>00628                 states[i].merger = <span class="keyword">this</span>;
<a name="l00629"></a>00629                 <span class="keywordflow">if</span> (i &lt; arity)
<a name="l00630"></a>00630                     states[i].block = <span class="keyword">new</span> block_type;
<a name="l00631"></a>00631                 <span class="keywordflow">else</span>
<a name="l00632"></a>00632                     states[i].block = convert_block_pointer(&amp;(sentinel_block));
<a name="l00633"></a>00633 
<a name="l00634"></a>00634                 states[i].make_inf();
<a name="l00635"></a>00635             }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637             assert(k == 1);
<a name="l00638"></a>00638             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(0); <span class="comment">//total state: one free sequence</span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640             rebuildLoserTree();
<a name="l00641"></a>00641             assert(is_sentinel(*states[entry[0].index]));
<a name="l00642"></a>00642         }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="comment">// rebuild loser tree information from the values in current</span>
<a name="l00645"></a>00645         <span class="keywordtype">void</span> rebuildLoserTree()
<a name="l00646"></a>00646         {
<a name="l00647"></a>00647             unsigned_type winner = initWinner(1);
<a name="l00648"></a>00648             entry[0].index = winner;
<a name="l00649"></a>00649             entry[0].key = *(states[winner]);
<a name="l00650"></a>00650         }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="comment">// given any values in the leaves this</span>
<a name="l00654"></a>00654         <span class="comment">// routing recomputes upper levels of the tree</span>
<a name="l00655"></a>00655         <span class="comment">// from scratch in linear time</span>
<a name="l00656"></a>00656         <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
<a name="l00657"></a>00657         <span class="comment">// return winner index</span>
<a name="l00658"></a>00658         unsigned_type initWinner(unsigned_type root)
<a name="l00659"></a>00659         {
<a name="l00660"></a>00660             <span class="keywordflow">if</span> (root &gt;= k) { <span class="comment">// leaf reached</span>
<a name="l00661"></a>00661                 <span class="keywordflow">return</span> root - k;
<a name="l00662"></a>00662             } <span class="keywordflow">else</span> {
<a name="l00663"></a>00663                 unsigned_type left = initWinner(2 * root);
<a name="l00664"></a>00664                 unsigned_type right = initWinner(2 * root + 1);
<a name="l00665"></a>00665                 Element lk = *(states[left]);
<a name="l00666"></a>00666                 Element rk = *(states[right]);
<a name="l00667"></a>00667                 <span class="keywordflow">if</span> (!(cmp(lk, rk))) { <span class="comment">// right subtree looses</span>
<a name="l00668"></a>00668                     entry[root].index = right;
<a name="l00669"></a>00669                     entry[root].key = rk;
<a name="l00670"></a>00670                     <span class="keywordflow">return</span> left;
<a name="l00671"></a>00671                 } <span class="keywordflow">else</span> {
<a name="l00672"></a>00672                     entry[root].index = left;
<a name="l00673"></a>00673                     entry[root].key = lk;
<a name="l00674"></a>00674                     <span class="keywordflow">return</span> right;
<a name="l00675"></a>00675                 }
<a name="l00676"></a>00676             }
<a name="l00677"></a>00677         }
<a name="l00678"></a>00678 
<a name="l00679"></a>00679         <span class="comment">// first go up the tree all the way to the root</span>
<a name="l00680"></a>00680         <span class="comment">// hand down old winner for the respective subtree</span>
<a name="l00681"></a>00681         <span class="comment">// based on new value, and old winner and loser</span>
<a name="l00682"></a>00682         <span class="comment">// update each node on the path to the root top down.</span>
<a name="l00683"></a>00683         <span class="comment">// This is implemented recursively</span>
<a name="l00684"></a>00684         <span class="keywordtype">void</span> update_on_insert(
<a name="l00685"></a>00685             unsigned_type node,
<a name="l00686"></a>00686             <span class="keyword">const</span> Element &amp; newKey,
<a name="l00687"></a>00687             unsigned_type newIndex,
<a name="l00688"></a>00688             Element * winnerKey,
<a name="l00689"></a>00689             unsigned_type * winnerIndex,        <span class="comment">// old winner</span>
<a name="l00690"></a>00690             unsigned_type * mask)               <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
<a name="l00691"></a>00691         {
<a name="l00692"></a>00692             <span class="keywordflow">if</span> (node == 0) {                    <span class="comment">// winner part of root</span>
<a name="l00693"></a>00693                 *mask = 1 &lt;&lt; (logK - 1);
<a name="l00694"></a>00694                 *winnerKey = entry[0].key;
<a name="l00695"></a>00695                 *winnerIndex = entry[0].index;
<a name="l00696"></a>00696                 <span class="keywordflow">if</span> (cmp(entry[node].key, newKey))
<a name="l00697"></a>00697                 {
<a name="l00698"></a>00698                     entry[node].key = newKey;
<a name="l00699"></a>00699                     entry[node].index = newIndex;
<a name="l00700"></a>00700                 }
<a name="l00701"></a>00701             } <span class="keywordflow">else</span> {
<a name="l00702"></a>00702                 update_on_insert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
<a name="l00703"></a>00703                 Element loserKey = entry[node].key;
<a name="l00704"></a>00704                 unsigned_type loserIndex = entry[node].index;
<a name="l00705"></a>00705                 <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
<a name="l00706"></a>00706                     <span class="keywordflow">if</span> (cmp(loserKey, newKey)) {                    <span class="comment">// newKey will have influence here</span>
<a name="l00707"></a>00707                         <span class="keywordflow">if</span> (cmp(*winnerKey, newKey)) {              <span class="comment">// old winner loses here</span>
<a name="l00708"></a>00708                             entry[node].key = *winnerKey;
<a name="l00709"></a>00709                             entry[node].index = *winnerIndex;
<a name="l00710"></a>00710                         } <span class="keywordflow">else</span> {                                    <span class="comment">// new entry looses here</span>
<a name="l00711"></a>00711                             entry[node].key = newKey;
<a name="l00712"></a>00712                             entry[node].index = newIndex;
<a name="l00713"></a>00713                         }
<a name="l00714"></a>00714                     }
<a name="l00715"></a>00715                     *winnerKey = loserKey;
<a name="l00716"></a>00716                     *winnerIndex = loserIndex;
<a name="l00717"></a>00717                 }
<a name="l00718"></a>00718                 <span class="comment">// note that nothing needs to be done if</span>
<a name="l00719"></a>00719                 <span class="comment">// the winner came from the same subtree</span>
<a name="l00720"></a>00720                 <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to loose</span>
<a name="l00721"></a>00721                 <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
<a name="l00722"></a>00722                 <span class="comment">//                           entry further down the tree</span>
<a name="l00723"></a>00723                 <span class="comment">// also the same old winner is handed down the tree</span>
<a name="l00724"></a>00724 
<a name="l00725"></a>00725                 *mask &gt;&gt;= 1; <span class="comment">// next level</span>
<a name="l00726"></a>00726             }
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="comment">// make the tree two times as wide</span>
<a name="l00730"></a>00730         <span class="keywordtype">void</span> doubleK()
<a name="l00731"></a>00731         {
<a name="l00732"></a>00732             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::doubleK (before) k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" KNKMAX="</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">" arity="</span> &lt;&lt; arity &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l00733"></a>00733             assert(k &gt; 0);
<a name="l00734"></a>00734             assert(k &lt; arity);
<a name="l00735"></a>00735             assert(free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());                 <span class="comment">// stack was free (probably not needed)</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737             <span class="comment">// make all new entries free</span>
<a name="l00738"></a>00738             <span class="comment">// and push them on the free stack</span>
<a name="l00739"></a>00739             <span class="keywordflow">for</span> (unsigned_type i = 2 * k - 1; i &gt;= k; i--) <span class="comment">//backwards</span>
<a name="l00740"></a>00740             {
<a name="l00741"></a>00741                 states[i].make_inf();
<a name="l00742"></a>00742                 <span class="keywordflow">if</span> (i &lt; arity)
<a name="l00743"></a>00743                     free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(i);
<a name="l00744"></a>00744             }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746             <span class="comment">// double the size</span>
<a name="l00747"></a>00747             k *= 2;
<a name="l00748"></a>00748             logK++;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::doubleK (after)  k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" KNKMAX="</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">" arity="</span> &lt;&lt; arity &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l00751"></a>00751             assert(!free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l00752"></a>00752 
<a name="l00753"></a>00753             <span class="comment">// recompute loser tree information</span>
<a name="l00754"></a>00754             rebuildLoserTree();
<a name="l00755"></a>00755         }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         <span class="comment">// compact nonempty segments in the left half of the tree</span>
<a name="l00759"></a>00759         <span class="keywordtype">void</span> compactTree()
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::compactTree (before) k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l00762"></a>00762             assert(logK &gt; 0);
<a name="l00763"></a>00763 
<a name="l00764"></a>00764             <span class="comment">// compact all nonempty segments to the left</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766             unsigned_type to = 0;
<a name="l00767"></a>00767             <span class="keywordflow">for</span> (unsigned_type from = 0; from &lt; k; from++)
<a name="l00768"></a>00768             {
<a name="l00769"></a>00769                 <span class="keywordflow">if</span> (!is_segment_empty(from))
<a name="l00770"></a>00770                 {
<a name="l00771"></a>00771                     assert(is_segment_allocated(from));
<a name="l00772"></a>00772                     <span class="keywordflow">if</span> (from != to) {
<a name="l00773"></a>00773                         assert(!is_segment_allocated(to));
<a name="l00774"></a>00774                         states[to].swap(states[from]);
<a name="l00775"></a>00775                     }
<a name="l00776"></a>00776                     ++to;
<a name="l00777"></a>00777                 }
<a name="l00778"></a>00778             }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780             <span class="comment">// half degree as often as possible</span>
<a name="l00781"></a>00781             <span class="keywordflow">while</span> (k &gt; 1 &amp;&amp; to &lt;= (k / 2)) {
<a name="l00782"></a>00782                 k /= 2;
<a name="l00783"></a>00783                 logK--;
<a name="l00784"></a>00784             }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786             <span class="comment">// overwrite garbage and compact the stack of free segment indices</span>
<a name="l00787"></a>00787             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#982682b58cc39ab5315c736dcb45953a">clear</a>(); <span class="comment">// none free</span>
<a name="l00788"></a>00788             <span class="keywordflow">for</span> ( ;  to &lt; k;  to++) {
<a name="l00789"></a>00789                 assert(!is_segment_allocated(to));
<a name="l00790"></a>00790                 states[to].make_inf();
<a name="l00791"></a>00791                 <span class="keywordflow">if</span> (to &lt; arity)
<a name="l00792"></a>00792                     free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(to);
<a name="l00793"></a>00793             }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::compactTree (after)  k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l00796"></a>00796             assert(k &gt; 0);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798             <span class="comment">// recompute loser tree information</span>
<a name="l00799"></a>00799             rebuildLoserTree();
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 <span class="preprocessor">#if 0</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span>        <span class="keywordtype">void</span> swap(<a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger</a> &amp; obj)
<a name="l00805"></a>00805         {
<a name="l00806"></a>00806             std::swap(cmp, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#8bc623d15f71a4fd39d08e2e1f640350">cmp</a>);
<a name="l00807"></a>00807             std::swap(free_segments, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#10deeb9ec23165c269bffbd141634907">free_segments</a>);
<a name="l00808"></a>00808             std::swap(size_, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#3001b0c802cd3e6a830a34f8436a49dc">size_</a>);
<a name="l00809"></a>00809             std::swap(logK, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#80961e740d59efa88a157f911ad0e863">logK</a>);
<a name="l00810"></a>00810             std::swap(k, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#a250ceb8218649893ce1956c8a2ab744">k</a>);
<a name="l00811"></a>00811             swap_1D_arrays(entry, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#28434c379cbacc554682d1c5f31a494f">entry</a>, KNKMAX);
<a name="l00812"></a>00812             swap_1D_arrays(states, obj.<a class="code" href="classpriority__queue__local_1_1ext__merger.html#64eb0debe3660b92b36248e13a56ef00">states</a>, KNKMAX);
<a name="l00813"></a>00813 
<a name="l00814"></a>00814             <span class="comment">// std::swap(p_pool,obj.p_pool);</span>
<a name="l00815"></a>00815             <span class="comment">// std::swap(w_pool,obj.w_pool);</span>
<a name="l00816"></a>00816         }
<a name="l00817"></a>00817 <span class="preprocessor">#endif</span>
<a name="l00818"></a>00818 <span class="preprocessor"></span>
<a name="l00819"></a>00819     <span class="keyword">public</span>:
<a name="l00820"></a>00820         unsigned_type mem_cons() <span class="keyword">const</span> <span class="comment">// only rough estimation</span>
<a name="l00821"></a>00821         {
<a name="l00822"></a>00822             <span class="keywordflow">return</span> (arity * block_type::raw_size);
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="comment">// delete the (length = end-begin) smallest elements and write them to "begin..end"</span>
<a name="l00826"></a>00826         <span class="comment">// empty segments are deallocated</span>
<a name="l00827"></a>00827         <span class="comment">// require:</span>
<a name="l00828"></a>00828         <span class="comment">// - there are at least length elements</span>
<a name="l00829"></a>00829         <span class="comment">// - segments are ended by sentinels</span>
<a name="l00830"></a>00830         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;
<a name="l00831"></a>00831         <span class="keywordtype">void</span> multi_merge(OutputIterator begin, OutputIterator end)
<a name="l00832"></a>00832         {
<a name="l00833"></a>00833             size_type length = end - begin;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::multi_merge from "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" sequence(s), length = "</span> &lt;&lt; length);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837             <span class="keywordflow">if</span> (length == 0)
<a name="l00838"></a>00838                 <span class="keywordflow">return</span>;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840             assert(k &gt; 0);
<a name="l00841"></a>00841             assert(length &lt;= size_);
<a name="l00842"></a>00842 
<a name="l00843"></a>00843             <span class="comment">//Hint first non-internal (actually second) block of each sequence.</span>
<a name="l00844"></a>00844             <span class="comment">//This is mandatory to ensure proper synchronization between prefetch pool and write pool.</span>
<a name="l00845"></a>00845             <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; k; ++i)
<a name="l00846"></a>00846             {
<a name="l00847"></a>00847                 <span class="keywordflow">if</span> (states[i].bids != NULL &amp;&amp; !states[i].bids-&gt;empty())
<a name="l00848"></a>00848                     p_pool-&gt;<a class="code" href="classprefetch__pool.html#338681a9581907004e2e57d43844ff70" title="Gives a hint for prefetching a block.">hint</a>(states[i].bids-&gt;front(), *w_pool);
<a name="l00849"></a>00849             }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851             <span class="keywordflow">switch</span> (logK) {
<a name="l00852"></a>00852             <span class="keywordflow">case</span> 0:
<a name="l00853"></a>00853                 assert(k == 1);
<a name="l00854"></a>00854                 assert(entry[0].index == 0);
<a name="l00855"></a>00855                 assert(free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l00856"></a>00856                 <span class="comment">//memcpy(to, states[0], length * sizeof(Element));</span>
<a name="l00857"></a>00857                 <span class="comment">//std::copy(states[0],states[0]+length,to);</span>
<a name="l00858"></a>00858                 <span class="keywordflow">for</span> (size_type i = 0; i &lt; length; ++i, ++(states[0]), ++begin)
<a name="l00859"></a>00859                     *begin = *(states[0]);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861                 entry[0].key = **states;
<a name="l00862"></a>00862                 <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l00863"></a>00863                     deallocate_segment(0);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865                 <span class="keywordflow">break</span>;
<a name="l00866"></a>00866             <span class="keywordflow">case</span> 1:
<a name="l00867"></a>00867                 assert(k == 2);
<a name="l00868"></a>00868                 merge_iterator(states[0], states[1], begin, length, cmp);
<a name="l00869"></a>00869                 rebuildLoserTree();
<a name="l00870"></a>00870                 <span class="keywordflow">if</span> (is_segment_empty(0) &amp;&amp; is_segment_allocated(0))
<a name="l00871"></a>00871                     deallocate_segment(0);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873                 <span class="keywordflow">if</span> (is_segment_empty(1) &amp;&amp; is_segment_allocated(1))
<a name="l00874"></a>00874                     deallocate_segment(1);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876                 <span class="keywordflow">break</span>;
<a name="l00877"></a>00877             <span class="keywordflow">case</span> 2:
<a name="l00878"></a>00878                 assert(k == 4);
<a name="l00879"></a>00879                 <span class="keywordflow">if</span> (is_segment_empty(3))
<a name="l00880"></a>00880                     merge3_iterator(states[0], states[1], states[2], begin, length, cmp);
<a name="l00881"></a>00881                 <span class="keywordflow">else</span>
<a name="l00882"></a>00882                     merge4_iterator(states[0], states[1], states[2], states[3], begin, length, cmp);
<a name="l00883"></a>00883                 rebuildLoserTree();
<a name="l00884"></a>00884                 <span class="keywordflow">if</span> (is_segment_empty(0) &amp;&amp; is_segment_allocated(0))
<a name="l00885"></a>00885                     deallocate_segment(0);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887                 <span class="keywordflow">if</span> (is_segment_empty(1) &amp;&amp; is_segment_allocated(1))
<a name="l00888"></a>00888                     deallocate_segment(1);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890                 <span class="keywordflow">if</span> (is_segment_empty(2) &amp;&amp; is_segment_allocated(2))
<a name="l00891"></a>00891                     deallocate_segment(2);
<a name="l00892"></a>00892 
<a name="l00893"></a>00893                 <span class="keywordflow">if</span> (is_segment_empty(3) &amp;&amp; is_segment_allocated(3))
<a name="l00894"></a>00894                     deallocate_segment(3);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896                 <span class="keywordflow">break</span>;
<a name="l00897"></a>00897             <span class="keywordflow">case</span>  3: multi_merge_f&lt;OutputIterator, 3&gt;(begin, end);
<a name="l00898"></a>00898                 <span class="keywordflow">break</span>;
<a name="l00899"></a>00899             <span class="keywordflow">case</span>  4: multi_merge_f&lt;OutputIterator, 4&gt;(begin, end);
<a name="l00900"></a>00900                 <span class="keywordflow">break</span>;
<a name="l00901"></a>00901             <span class="keywordflow">case</span>  5: multi_merge_f&lt;OutputIterator, 5&gt;(begin, end);
<a name="l00902"></a>00902                 <span class="keywordflow">break</span>;
<a name="l00903"></a>00903             <span class="keywordflow">case</span>  6: multi_merge_f&lt;OutputIterator, 6&gt;(begin, end);
<a name="l00904"></a>00904                 <span class="keywordflow">break</span>;
<a name="l00905"></a>00905             <span class="keywordflow">case</span>  7: multi_merge_f&lt;OutputIterator, 7&gt;(begin, end);
<a name="l00906"></a>00906                 <span class="keywordflow">break</span>;
<a name="l00907"></a>00907             <span class="keywordflow">case</span>  8: multi_merge_f&lt;OutputIterator, 8&gt;(begin, end);
<a name="l00908"></a>00908                 <span class="keywordflow">break</span>;
<a name="l00909"></a>00909             <span class="keywordflow">case</span>  9: multi_merge_f&lt;OutputIterator, 9&gt;(begin, end);
<a name="l00910"></a>00910                 <span class="keywordflow">break</span>;
<a name="l00911"></a>00911             <span class="keywordflow">case</span> 10: multi_merge_f&lt;OutputIterator, 10&gt;(begin, end);
<a name="l00912"></a>00912                 <span class="keywordflow">break</span>;
<a name="l00913"></a>00913             <span class="keywordflow">default</span>: multi_merge_k(begin, end);
<a name="l00914"></a>00914                 <span class="keywordflow">break</span>;
<a name="l00915"></a>00915             }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 
<a name="l00918"></a>00918             size_ -= length;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920             <span class="comment">// compact tree if it got considerably smaller</span>
<a name="l00921"></a>00921             {
<a name="l00922"></a>00922                 <span class="keyword">const</span> unsigned_type num_segments_used = std::min&lt;unsigned_type&gt;(arity, k) - free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>();
<a name="l00923"></a>00923                 <span class="keyword">const</span> unsigned_type num_segments_trigger = k - (3 * k / 5);
<a name="l00924"></a>00924                 <span class="comment">// using k/2 would be worst case inefficient (for large k)</span>
<a name="l00925"></a>00925                 <span class="comment">// for k \in {2, 4, 8} the trigger is k/2 which is good</span>
<a name="l00926"></a>00926                 <span class="comment">// because we have special mergers for k \in {1, 2, 4}</span>
<a name="l00927"></a>00927                 <span class="comment">// there is also a special 3-way-merger, that will be</span>
<a name="l00928"></a>00928                 <span class="comment">// triggered if k == 4 &amp;&amp; is_segment_empty(3)</span>
<a name="l00929"></a>00929                 STXXL_VERBOSE3(<span class="stringliteral">"ext_merger  compact? k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" #used="</span> &lt;&lt; num_segments_used
<a name="l00930"></a>00930                                                          &lt;&lt; <span class="stringliteral">" &lt;= #trigger="</span> &lt;&lt; num_segments_trigger &lt;&lt; <span class="stringliteral">" ==&gt; "</span>
<a name="l00931"></a>00931                                                          &lt;&lt; ((k &gt; 1 &amp;&amp; num_segments_used &lt;= num_segments_trigger) ? <span class="stringliteral">"yes"</span> : <span class="stringliteral">"no "</span>)
<a name="l00932"></a>00932                                                          &lt;&lt; <span class="stringliteral">" || "</span>
<a name="l00933"></a>00933                                                          &lt;&lt; ((k == 4 &amp;&amp; !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>() &amp;&amp; !is_segment_empty(3)) ? <span class="stringliteral">"yes"</span> : <span class="stringliteral">"no "</span>)
<a name="l00934"></a>00934                                                          &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l00935"></a>00935                 <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; ((num_segments_used &lt;= num_segments_trigger) ||
<a name="l00936"></a>00936                               (k == 4 &amp;&amp; !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>() &amp;&amp; !is_segment_empty(3))))
<a name="l00937"></a>00937                 {
<a name="l00938"></a>00938                     compactTree();
<a name="l00939"></a>00939                 }
<a name="l00940"></a>00940             }
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     <span class="keyword">private</span>:
<a name="l00944"></a>00944         <span class="comment">// multi-merge for arbitrary K</span>
<a name="l00945"></a>00945         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;
<a name="l00946"></a>00946         <span class="keywordtype">void</span> multi_merge_k(OutputIterator begin, OutputIterator end)
<a name="l00947"></a>00947         {
<a name="l00948"></a>00948             Entry * currentPos;
<a name="l00949"></a>00949             Element currentKey;
<a name="l00950"></a>00950             unsigned_type currentIndex; <span class="comment">// leaf pointed to by current entry</span>
<a name="l00951"></a>00951             unsigned_type kReg = k;
<a name="l00952"></a>00952             OutputIterator done = end;
<a name="l00953"></a>00953             OutputIterator to = begin;
<a name="l00954"></a>00954             unsigned_type winnerIndex = entry[0].index;
<a name="l00955"></a>00955             Element winnerKey = entry[0].key;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957             <span class="keywordflow">while</span> (to != done)
<a name="l00958"></a>00958             {
<a name="l00959"></a>00959                 <span class="comment">// write result</span>
<a name="l00960"></a>00960                 *to = *(states[winnerIndex]);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962                 <span class="comment">// advance winner segment</span>
<a name="l00963"></a>00963                 ++(states[winnerIndex]);
<a name="l00964"></a>00964 
<a name="l00965"></a>00965                 winnerKey = *(states[winnerIndex]);
<a name="l00966"></a>00966 
<a name="l00967"></a>00967                 <span class="comment">// remove winner segment if empty now</span>
<a name="l00968"></a>00968                 <span class="keywordflow">if</span> (is_sentinel(winnerKey)) <span class="comment">//</span>
<a name="l00969"></a>00969                     deallocate_segment(winnerIndex);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 
<a name="l00972"></a>00972                 <span class="comment">// go up the entry-tree</span>
<a name="l00973"></a>00973                 <span class="keywordflow">for</span> (unsigned_type i = (winnerIndex + kReg) &gt;&gt; 1;  i &gt; 0;  i &gt;&gt;= 1) {
<a name="l00974"></a>00974                     currentPos = entry + i;
<a name="l00975"></a>00975                     currentKey = currentPos-&gt;key;
<a name="l00976"></a>00976                     <span class="keywordflow">if</span> (cmp(winnerKey, currentKey)) {
<a name="l00977"></a>00977                         currentIndex = currentPos-&gt;index;
<a name="l00978"></a>00978                         currentPos-&gt;key = winnerKey;
<a name="l00979"></a>00979                         currentPos-&gt;index = winnerIndex;
<a name="l00980"></a>00980                         winnerKey = currentKey;
<a name="l00981"></a>00981                         winnerIndex = currentIndex;
<a name="l00982"></a>00982                     }
<a name="l00983"></a>00983                 }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985                 ++to;
<a name="l00986"></a>00986             }
<a name="l00987"></a>00987             entry[0].index = winnerIndex;
<a name="l00988"></a>00988             entry[0].key = winnerKey;
<a name="l00989"></a>00989         }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991         <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator, <span class="keywordtype">unsigned</span> LogK&gt;
<a name="l00992"></a>00992         <span class="keywordtype">void</span> multi_merge_f(OutputIterator begin, OutputIterator end)
<a name="l00993"></a>00993         {
<a name="l00994"></a>00994             OutputIterator done = end;
<a name="l00995"></a>00995             OutputIterator to = begin;
<a name="l00996"></a>00996             unsigned_type winnerIndex = entry[0].index;
<a name="l00997"></a>00997             Entry * regEntry = entry;
<a name="l00998"></a>00998             sequence_state * regStates = states;
<a name="l00999"></a>00999             Element winnerKey = entry[0].key;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001             assert(logK &gt;= LogK);
<a name="l01002"></a>01002             <span class="keywordflow">while</span> (to != done)
<a name="l01003"></a>01003             {
<a name="l01004"></a>01004                 <span class="comment">// write result</span>
<a name="l01005"></a>01005                 *to = *(regStates[winnerIndex]);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007                 <span class="comment">// advance winner segment</span>
<a name="l01008"></a>01008                 ++(regStates[winnerIndex]);
<a name="l01009"></a>01009 
<a name="l01010"></a>01010                 winnerKey = *(regStates[winnerIndex]);
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 
<a name="l01013"></a>01013                 <span class="comment">// remove winner segment if empty now</span>
<a name="l01014"></a>01014                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))
<a name="l01015"></a>01015                     deallocate_segment(winnerIndex);
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018                 ++to;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020                 <span class="comment">// update loser tree</span>
<a name="l01021"></a>01021 <span class="preprocessor">#define TreeStep(L) \</span>
<a name="l01022"></a>01022 <span class="preprocessor">    if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) { \</span>
<a name="l01023"></a>01023 <span class="preprocessor">        Entry * pos ## L = regEntry + ((winnerIndex + (1 &lt;&lt; LogK)) &gt;&gt; (((int(LogK - L) + 1) &gt;= 0) ? ((LogK - L) + 1) : 0)); \</span>
<a name="l01024"></a>01024 <span class="preprocessor">        Element key ## L = pos ## L-&gt;key; \</span>
<a name="l01025"></a>01025 <span class="preprocessor">        if (cmp(winnerKey, key ## L)) { \</span>
<a name="l01026"></a>01026 <span class="preprocessor">            unsigned_type index ## L = pos ## L-&gt;index; \</span>
<a name="l01027"></a>01027 <span class="preprocessor">            pos ## L-&gt;key = winnerKey; \</span>
<a name="l01028"></a>01028 <span class="preprocessor">            pos ## L-&gt;index = winnerIndex; \</span>
<a name="l01029"></a>01029 <span class="preprocessor">            winnerKey = key ## L; \</span>
<a name="l01030"></a>01030 <span class="preprocessor">            winnerIndex = index ## L; \</span>
<a name="l01031"></a>01031 <span class="preprocessor">        } \</span>
<a name="l01032"></a>01032 <span class="preprocessor">    }</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span>                TreeStep(10);
<a name="l01034"></a>01034                 TreeStep(9);
<a name="l01035"></a>01035                 TreeStep(8);
<a name="l01036"></a>01036                 TreeStep(7);
<a name="l01037"></a>01037                 TreeStep(6);
<a name="l01038"></a>01038                 TreeStep(5);
<a name="l01039"></a>01039                 TreeStep(4);
<a name="l01040"></a>01040                 TreeStep(3);
<a name="l01041"></a>01041                 TreeStep(2);
<a name="l01042"></a>01042                 TreeStep(1);
<a name="l01043"></a>01043 <span class="preprocessor">#undef TreeStep</span>
<a name="l01044"></a>01044 <span class="preprocessor"></span>            }
<a name="l01045"></a>01045             regEntry[0].index = winnerIndex;
<a name="l01046"></a>01046             regEntry[0].key = winnerKey;
<a name="l01047"></a>01047         }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     <span class="keyword">public</span>:
<a name="l01050"></a>01050         <span class="keywordtype">bool</span> spaceIsAvailable() <span class="keyword">const</span> <span class="comment">// for new segment</span>
<a name="l01051"></a>01051         {
<a name="l01052"></a>01052             <span class="keywordflow">return</span> k &lt; arity || !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>();
<a name="l01053"></a>01053         }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01056"></a>01056         <span class="comment">// insert segment beginning at to</span>
<a name="l01057"></a>01057         <span class="comment">// require: spaceIsAvailable() == 1</span>
<a name="l01058"></a>01058         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Merger&gt;
<a name="l01059"></a>01059         <span class="keywordtype">void</span> insert_segment(Merger &amp; another_merger, size_type segment_size)
<a name="l01060"></a>01060         {
<a name="l01061"></a>01061             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(merger,...)"</span> &lt;&lt; <span class="keyword">this</span>);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063             <span class="keywordflow">if</span> (segment_size &gt; 0)
<a name="l01064"></a>01064             {
<a name="l01065"></a>01065                 <span class="comment">// get a free slot</span>
<a name="l01066"></a>01066                 <span class="keywordflow">if</span> (free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>()) { <span class="comment">// tree is too small</span>
<a name="l01067"></a>01067                     doubleK();
<a name="l01068"></a>01068                 }
<a name="l01069"></a>01069                 assert(!free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l01070"></a>01070                 unsigned_type free_slot = free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#260aebd0649fa31377d5d9a710be25f1">top</a>();
<a name="l01071"></a>01071                 free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#e37bfa686d3792bcc99bfd555793a5aa">pop</a>();
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 
<a name="l01074"></a>01074                 <span class="comment">// link new segment</span>
<a name="l01075"></a>01075                 assert(segment_size);
<a name="l01076"></a>01076                 unsigned_type nblocks = segment_size / block_type::size;
<a name="l01077"></a>01077                 <span class="comment">//assert(nblocks); // at least one block</span>
<a name="l01078"></a>01078                 STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment nblocks="</span> &lt;&lt; nblocks);
<a name="l01079"></a>01079                 <span class="keywordflow">if</span> (nblocks == 0)
<a name="l01080"></a>01080                 {
<a name="l01081"></a>01081                     STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(merger,...) WARNING: inserting a segment with "</span> &lt;&lt;
<a name="l01082"></a>01082                                    nblocks &lt;&lt; <span class="stringliteral">" blocks"</span>);
<a name="l01083"></a>01083                     STXXL_VERBOSE1(<span class="stringliteral">"THIS IS INEFFICIENT: TRY TO CHANGE PRIORITY QUEUE PARAMETERS"</span>);
<a name="l01084"></a>01084                 }
<a name="l01085"></a>01085                 unsigned_type first_size = segment_size % block_type::size;
<a name="l01086"></a>01086                 <span class="keywordflow">if</span> (first_size == 0)
<a name="l01087"></a>01087                 {
<a name="l01088"></a>01088                     first_size = block_type::size;
<a name="l01089"></a>01089                     --nblocks;
<a name="l01090"></a>01090                 }
<a name="l01091"></a>01091                 <a class="code" href="classblock__manager.html" title="Block manager class.">block_manager</a> * bm = <a class="code" href="classblock__manager.html#864528bc480d0c4617d77261188c5c7d" title="Returns instance of block_manager.">block_manager::get_instance</a>();
<a name="l01092"></a>01092                 std::list&lt;bid_type&gt; * bids = <span class="keyword">new</span> std::list&lt;bid_type&gt;(nblocks);
<a name="l01093"></a>01093                 bm-&gt;<a class="code" href="group__mnglayer.html#g4128bf4658033cc39eeebc21ebe2b93a" title="Allocates new blocks.">new_blocks</a>(alloc_strategy(), bids-&gt;begin(), bids-&gt;end());
<a name="l01094"></a>01094                 block_type * first_block = <span class="keyword">new</span> block_type;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096                 another_merger.multi_merge(
<a name="l01097"></a>01097                     first_block-&gt;begin() + (block_type::size - first_size),
<a name="l01098"></a>01098                     first_block-&gt;end());
<a name="l01099"></a>01099 
<a name="l01100"></a>01100                 STXXL_VERBOSE1(<span class="stringliteral">"last element of first block "</span> &lt;&lt; *(first_block-&gt;end() - 1));
<a name="l01101"></a>01101                 assert(!cmp(*(first_block-&gt;begin() + (block_type::size - first_size)), *(first_block-&gt;end() - 1)));
<a name="l01102"></a>01102 
<a name="l01103"></a>01103                 assert(w_pool-&gt;<a class="code" href="classwrite__pool.html#587aa787257f33fb015ecdb2b64e6aaa" title="Returns number of owned blocks.">size</a>() &gt; 0);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::list&lt;bid_type&gt;::iterator curbid = bids-&gt;begin(); curbid != bids-&gt;end(); ++curbid)
<a name="l01106"></a>01106                 {
<a name="l01107"></a>01107                     block_type * b = w_pool-&gt;<a class="code" href="classwrite__pool.html#c482070824867e4d08d46c9ccfaef04f" title="Take out a block from the pool.">steal</a>();
<a name="l01108"></a>01108                     another_merger.multi_merge(b-&gt;begin(), b-&gt;end());
<a name="l01109"></a>01109                     STXXL_VERBOSE1(<span class="stringliteral">"first element of following block "</span> &lt;&lt; *curbid &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; *(b-&gt;begin()));
<a name="l01110"></a>01110                     STXXL_VERBOSE1(<span class="stringliteral">"last element of following block "</span> &lt;&lt; *curbid &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; *(b-&gt;end() - 1));
<a name="l01111"></a>01111                     assert(!cmp(*(b-&gt;begin()), *(b-&gt;end() - 1)));
<a name="l01112"></a>01112                     w_pool-&gt;<a class="code" href="classwrite__pool.html#4be1e4ab0391051bec733a9060a5404a" title="Passes a block to the pool for writing.">write</a>(b, *curbid); <span class="comment">//-&gt;wait() does not help</span>
<a name="l01113"></a>01113                     STXXL_VERBOSE1(<span class="stringliteral">"written to block "</span> &lt;&lt; *curbid &lt;&lt; <span class="stringliteral">" cached in "</span> &lt;&lt; b);
<a name="l01114"></a>01114                 }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116                 insert_segment(bids, first_block, first_size, free_slot);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118                 size_ += segment_size;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120                 <span class="comment">// propagate new information up the tree</span>
<a name="l01121"></a>01121                 Element dummyKey;
<a name="l01122"></a>01122                 unsigned_type dummyIndex;
<a name="l01123"></a>01123                 unsigned_type dummyMask;
<a name="l01124"></a>01124                 update_on_insert((free_slot + k) &gt;&gt; 1, *(states[free_slot]), free_slot,
<a name="l01125"></a>01125                                  &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
<a name="l01126"></a>01126             } <span class="keywordflow">else</span> {
<a name="l01127"></a>01127                 <span class="comment">// deallocate memory ?</span>
<a name="l01128"></a>01128                 STXXL_VERBOSE1(<span class="stringliteral">"Merged segment with zero size."</span>);
<a name="l01129"></a>01129             }
<a name="l01130"></a>01130         }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132         size_type size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     <span class="keyword">protected</span>:
<a name="l01137"></a><a class="code" href="classpriority__queue__local_1_1ext__merger.html#8aadea817bc58e48163674f35b2ca85a">01137</a>         <span class="keywordtype">void</span> insert_segment(std::list&lt;bid_type&gt; * bidlist, block_type * first_block,
<a name="l01138"></a>01138                             unsigned_type first_size, unsigned_type slot)
<a name="l01139"></a>01139         {
<a name="l01140"></a>01140             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(bidlist,...) "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; bidlist-&gt;size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; slot);
<a name="l01141"></a>01141             assert(!is_segment_allocated(slot));
<a name="l01142"></a>01142             assert(first_size &gt; 0);
<a name="l01143"></a>01143 
<a name="l01144"></a>01144             sequence_state &amp; new_sequence = states[slot];
<a name="l01145"></a>01145             new_sequence.current = block_type::size - first_size;
<a name="l01146"></a>01146             std::swap(new_sequence.block, first_block);
<a name="l01147"></a>01147             <span class="keyword">delete</span> first_block;
<a name="l01148"></a>01148             std::swap(new_sequence.bids, bidlist);
<a name="l01149"></a>01149             <span class="keywordflow">if</span> (bidlist) <span class="comment">// the old list</span>
<a name="l01150"></a>01150             {
<a name="l01151"></a>01151                 assert(bidlist-&gt;empty());
<a name="l01152"></a>01152                 <span class="keyword">delete</span> bidlist;
<a name="l01153"></a>01153             }
<a name="l01154"></a>01154             new_sequence.allocated = <span class="keyword">true</span>;
<a name="l01155"></a>01155             assert(is_segment_allocated(slot));
<a name="l01156"></a>01156         }
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         <span class="comment">// free an empty segment .</span>
<a name="l01159"></a>01159         <span class="keywordtype">void</span> deallocate_segment(unsigned_type slot)
<a name="l01160"></a>01160         {
<a name="l01161"></a>01161             STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::deallocate_segment() deleting segment "</span> &lt;&lt; slot &lt;&lt; <span class="stringliteral">" allocated="</span> &lt;&lt; <span class="keywordtype">int</span>(is_segment_allocated(slot)));
<a name="l01162"></a>01162             assert(is_segment_allocated(slot));
<a name="l01163"></a>01163             states[slot].allocated = <span class="keyword">false</span>;
<a name="l01164"></a>01164             states[slot].make_inf();
<a name="l01165"></a>01165 
<a name="l01166"></a>01166             <span class="comment">// push on the stack of free segment indices</span>
<a name="l01167"></a>01167             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(slot);
<a name="l01168"></a>01168         }
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <span class="comment">// is this segment empty ?</span>
<a name="l01171"></a>01171         <span class="keywordtype">bool</span> is_segment_empty(unsigned_type slot)<span class="keyword"> const</span>
<a name="l01172"></a>01172 <span class="keyword">        </span>{
<a name="l01173"></a>01173             <span class="keywordflow">return</span> is_sentinel(*(states[slot]));
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176         <span class="comment">// Is this segment allocated? Otherwise it's empty,</span>
<a name="l01177"></a>01177         <span class="comment">// already on the stack of free segment indices and can be reused.</span>
<a name="l01178"></a>01178         <span class="keywordtype">bool</span> is_segment_allocated(unsigned_type slot)<span class="keyword"> const</span>
<a name="l01179"></a>01179 <span class="keyword">        </span>{
<a name="l01180"></a>01180             <span class="keywordflow">return</span> states[slot].allocated;
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182     }; <span class="comment">//ext_merger</span>
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 
<a name="l01186"></a>01186 <span class="comment">// The data structure from Knuth, "Sorting and Searching", Section 5.4.1</span>
<a name="l01191"></a>01191 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01192"></a><a class="code" href="classpriority__queue__local_1_1loser__tree.html">01192</a>     <span class="keyword">class </span><a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">loser_tree</a> : <span class="keyword">private</span> noncopyable
<a name="l01193"></a>01193     {
<a name="l01194"></a>01194     <span class="keyword">public</span>:
<a name="l01195"></a>01195         <span class="keyword">typedef</span> ValTp_ value_type;
<a name="l01196"></a>01196         <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l01197"></a>01197         <span class="keyword">typedef</span> value_type Element;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199     <span class="keyword">private</span>:
<a name="l01200"></a>01200         <span class="keyword">struct </span>Entry
<a name="l01201"></a>01201         {
<a name="l01202"></a>01202             value_type key;      <span class="comment">// Key of Loser element (winner for 0)</span>
<a name="l01203"></a>01203             unsigned_type index; <span class="comment">// number of losing segment</span>
<a name="l01204"></a>01204         };
<a name="l01205"></a>01205 
<a name="l01206"></a>01206         comparator_type cmp;
<a name="l01207"></a>01207         <span class="comment">// stack of free segment indices</span>
<a name="l01208"></a>01208         <a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html" title="Similar to std::stack, with the following differences:Maximum size is fixed at compilation...">internal_bounded_stack&lt;unsigned_type, KNKMAX&gt;</a> free_segments;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         unsigned_type size_; <span class="comment">// total number of elements stored</span>
<a name="l01211"></a>01211         unsigned_type logK;  <span class="comment">// log of current tree size</span>
<a name="l01212"></a>01212         unsigned_type k;     <span class="comment">// invariant (k == 1 &lt;&lt; logK), always a power of two</span>
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         Element sentinel;    <span class="comment">// target of free segment pointers</span>
<a name="l01215"></a>01215 
<a name="l01216"></a>01216         <span class="comment">// upper levels of loser trees</span>
<a name="l01217"></a>01217         <span class="comment">// entry[0] contains the winner info</span>
<a name="l01218"></a>01218         Entry entry[KNKMAX];
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <span class="comment">// leaf information</span>
<a name="l01221"></a>01221         <span class="comment">// note that Knuth uses indices k..k-1</span>
<a name="l01222"></a>01222         <span class="comment">// while we use 0..k-1</span>
<a name="l01223"></a>01223         Element * current[KNKMAX];          <span class="comment">// pointer to current element</span>
<a name="l01224"></a>01224         Element * segment[KNKMAX];          <span class="comment">// start of Segments</span>
<a name="l01225"></a>01225         unsigned_type segment_size[KNKMAX]; <span class="comment">// just to count the internal memory consumption</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227         unsigned_type mem_cons_;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         <span class="comment">// private member functions</span>
<a name="l01230"></a>01230         unsigned_type initWinner(unsigned_type root);
<a name="l01231"></a>01231         <span class="keywordtype">void</span> update_on_insert(unsigned_type node, <span class="keyword">const</span> Element &amp; newKey, unsigned_type newIndex,
<a name="l01232"></a>01232                               Element * winnerKey, unsigned_type * winnerIndex, unsigned_type * mask);
<a name="l01233"></a>01233         <span class="keywordtype">void</span> deallocate_segment(unsigned_type slot);
<a name="l01234"></a>01234         <span class="keywordtype">void</span> doubleK();
<a name="l01235"></a>01235         <span class="keywordtype">void</span> compactTree();
<a name="l01236"></a>01236         <span class="keywordtype">void</span> rebuildLoserTree();
<a name="l01237"></a>01237         <span class="keywordtype">bool</span> is_segment_empty(unsigned_type slot);
<a name="l01238"></a>01238         <span class="keywordtype">void</span> multi_merge_k(Element * to, unsigned_type length);
<a name="l01239"></a>01239 
<a name="l01240"></a>01240         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> LogK&gt;
<a name="l01241"></a>01241         <span class="keywordtype">void</span> multi_merge_f(Element * to, unsigned_type length)
<a name="l01242"></a>01242         {
<a name="l01243"></a>01243             <span class="comment">//Entry *currentPos;</span>
<a name="l01244"></a>01244             <span class="comment">//Element currentKey;</span>
<a name="l01245"></a>01245             <span class="comment">//int currentIndex; // leaf pointed to by current entry</span>
<a name="l01246"></a>01246             Element * done = to + length;
<a name="l01247"></a>01247             Entry * regEntry = entry;
<a name="l01248"></a>01248             Element ** regStates = current;
<a name="l01249"></a>01249             unsigned_type winnerIndex = regEntry[0].index;
<a name="l01250"></a>01250             Element winnerKey = regEntry[0].key;
<a name="l01251"></a>01251             Element * winnerPos;
<a name="l01252"></a>01252             <span class="comment">//Element sup = sentinel; // supremum</span>
<a name="l01253"></a>01253 
<a name="l01254"></a>01254             assert(logK &gt;= LogK);
<a name="l01255"></a>01255             <span class="keywordflow">while</span> (to != done)
<a name="l01256"></a>01256             {
<a name="l01257"></a>01257                 winnerPos = regStates[winnerIndex];
<a name="l01258"></a>01258 
<a name="l01259"></a>01259                 <span class="comment">// write result</span>
<a name="l01260"></a>01260                 *to = winnerKey;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262                 <span class="comment">// advance winner segment</span>
<a name="l01263"></a>01263                 ++winnerPos;
<a name="l01264"></a>01264                 regStates[winnerIndex] = winnerPos;
<a name="l01265"></a>01265                 winnerKey = *winnerPos;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267                 <span class="comment">// remove winner segment if empty now</span>
<a name="l01268"></a>01268                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))
<a name="l01269"></a>01269                 {
<a name="l01270"></a>01270                     deallocate_segment(winnerIndex);
<a name="l01271"></a>01271                 }
<a name="l01272"></a>01272                 ++to;
<a name="l01273"></a>01273 
<a name="l01274"></a>01274                 <span class="comment">// update loser tree</span>
<a name="l01275"></a>01275 <span class="preprocessor">#define TreeStep(L) \</span>
<a name="l01276"></a>01276 <span class="preprocessor">    if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) { \</span>
<a name="l01277"></a>01277 <span class="preprocessor">        Entry * pos ## L = regEntry + ((winnerIndex + (1 &lt;&lt; LogK)) &gt;&gt; (((int(LogK - L) + 1) &gt;= 0) ? ((LogK - L) + 1) : 0)); \</span>
<a name="l01278"></a>01278 <span class="preprocessor">        Element key ## L = pos ## L-&gt;key; \</span>
<a name="l01279"></a>01279 <span class="preprocessor">        if (cmp(winnerKey, key ## L)) { \</span>
<a name="l01280"></a>01280 <span class="preprocessor">            unsigned_type index ## L = pos ## L-&gt;index; \</span>
<a name="l01281"></a>01281 <span class="preprocessor">            pos ## L-&gt;key = winnerKey; \</span>
<a name="l01282"></a>01282 <span class="preprocessor">            pos ## L-&gt;index = winnerIndex; \</span>
<a name="l01283"></a>01283 <span class="preprocessor">            winnerKey = key ## L; \</span>
<a name="l01284"></a>01284 <span class="preprocessor">            winnerIndex = index ## L; \</span>
<a name="l01285"></a>01285 <span class="preprocessor">        } \</span>
<a name="l01286"></a>01286 <span class="preprocessor">    }</span>
<a name="l01287"></a>01287 <span class="preprocessor"></span>                TreeStep(10);
<a name="l01288"></a>01288                 TreeStep(9);
<a name="l01289"></a>01289                 TreeStep(8);
<a name="l01290"></a>01290                 TreeStep(7);
<a name="l01291"></a>01291                 TreeStep(6);
<a name="l01292"></a>01292                 TreeStep(5);
<a name="l01293"></a>01293                 TreeStep(4);
<a name="l01294"></a>01294                 TreeStep(3);
<a name="l01295"></a>01295                 TreeStep(2);
<a name="l01296"></a>01296                 TreeStep(1);
<a name="l01297"></a>01297 <span class="preprocessor">#undef TreeStep</span>
<a name="l01298"></a>01298 <span class="preprocessor"></span>            }
<a name="l01299"></a>01299             regEntry[0].index = winnerIndex;
<a name="l01300"></a>01300             regEntry[0].key = winnerKey;
<a name="l01301"></a>01301         }
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="keyword">public</span>:
<a name="l01304"></a>01304         <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l01305"></a>01305         {
<a name="l01306"></a>01306             <span class="keywordflow">return</span> !(cmp(cmp.min_value(), a));
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308         <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l01309"></a>01309         {
<a name="l01310"></a>01310             <span class="keywordflow">return</span> cmp(cmp.min_value(), a);
<a name="l01311"></a>01311         }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313     <span class="keyword">public</span>:
<a name="l01314"></a>01314         <a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">loser_tree</a>();
<a name="l01315"></a>01315         ~<a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">loser_tree</a>();
<a name="l01316"></a>01316         <span class="keywordtype">void</span> init();
<a name="l01317"></a>01317 
<a name="l01318"></a>01318         <span class="keywordtype">void</span> swap(<a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">loser_tree</a> &amp; obj)
<a name="l01319"></a>01319         {
<a name="l01320"></a>01320             std::swap(cmp, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#7715b868e2407c3458adc7c48e66ecc2">cmp</a>);
<a name="l01321"></a>01321             std::swap(free_segments, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#76874234e9ce1547e2f37c0ff5088156">free_segments</a>);
<a name="l01322"></a>01322             std::swap(size_, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#5d4c3f09a26be89c2bfd21b068dc4ba7">size_</a>);
<a name="l01323"></a>01323             std::swap(logK, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#b6d27c71387ca2d049a175aca65e5819">logK</a>);
<a name="l01324"></a>01324             std::swap(k, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#57429deb2336c6327a35a878cb40cef9">k</a>);
<a name="l01325"></a>01325             std::swap(sentinel, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#3a559af02fadc564497e626a606c7488">sentinel</a>);
<a name="l01326"></a>01326             swap_1D_arrays(entry, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#88af5b9ac53c21114eb5c48ab74a9ea3">entry</a>, KNKMAX);
<a name="l01327"></a>01327             swap_1D_arrays(current, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#edfc0c3e2d0a6142f36638bb60b067b0">current</a>, KNKMAX);
<a name="l01328"></a>01328             swap_1D_arrays(segment, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#9e3b01ffd40eedc0b8a0b5be08bda717">segment</a>, KNKMAX);
<a name="l01329"></a>01329             swap_1D_arrays(segment_size, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#fa035495021fffdf24e110c568189146">segment_size</a>, KNKMAX);
<a name="l01330"></a>01330             std::swap(mem_cons_, obj.<a class="code" href="classpriority__queue__local_1_1loser__tree.html#5e53ca61e595bb87ec733a2756bc5d72">mem_cons_</a>);
<a name="l01331"></a>01331         }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         <span class="keywordtype">void</span> multi_merge(Element * begin, Element * end)
<a name="l01334"></a>01334         {
<a name="l01335"></a>01335             multi_merge(begin, end - begin);
<a name="l01336"></a>01336         }
<a name="l01337"></a>01337         <span class="keywordtype">void</span> multi_merge(Element *, unsigned_type length);
<a name="l01338"></a>01338 
<a name="l01339"></a>01339         unsigned_type mem_cons()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mem_cons_; }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341         <span class="keywordtype">bool</span> spaceIsAvailable() <span class="keyword">const</span> <span class="comment">// for new segment</span>
<a name="l01342"></a>01342         {
<a name="l01343"></a>01343             <span class="keywordflow">return</span> k &lt; KNKMAX || !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>();
<a name="l01344"></a>01344         }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346         <span class="keywordtype">void</span> insert_segment(Element * to, unsigned_type sz); <span class="comment">// insert segment beginning at to</span>
<a name="l01347"></a>01347         unsigned_type size() { <span class="keywordflow">return</span> size_; }
<a name="l01348"></a>01348     };
<a name="l01349"></a>01349 
<a name="l01351"></a>01351     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01352"></a>01352     <a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::loser_tree</a>() : size_(0), logK(0), k(1), mem_cons_(0)
<a name="l01353"></a>01353     {
<a name="l01354"></a>01354         free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(0);
<a name="l01355"></a>01355         segment[0] = 0;
<a name="l01356"></a>01356         current[0] = &amp;sentinel;
<a name="l01357"></a>01357         <span class="comment">// entry and sentinel are initialized by init</span>
<a name="l01358"></a>01358         <span class="comment">// since they need the value of supremum</span>
<a name="l01359"></a>01359         init();
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01363"></a>01363     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::init()
<a name="l01364"></a>01364     {
<a name="l01365"></a>01365         assert(!cmp(cmp.min_value(), cmp.min_value())); <span class="comment">// verify strict weak ordering</span>
<a name="l01366"></a>01366         sentinel = cmp.min_value();
<a name="l01367"></a>01367         rebuildLoserTree();
<a name="l01368"></a>01368         assert(current[entry[0].index] == &amp;sentinel);
<a name="l01369"></a>01369     }
<a name="l01370"></a>01370 
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 <span class="comment">// rebuild loser tree information from the values in current</span>
<a name="l01373"></a>01373     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01374"></a>01374     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::rebuildLoserTree()
<a name="l01375"></a>01375     {
<a name="l01376"></a>01376         assert(LOG2&lt;KNKMAX&gt;::floor == LOG2&lt;KNKMAX&gt;::ceil); <span class="comment">// KNKMAX needs to be a power of two</span>
<a name="l01377"></a>01377         unsigned_type winner = initWinner(1);
<a name="l01378"></a>01378         entry[0].index = winner;
<a name="l01379"></a>01379         entry[0].key = *(current[winner]);
<a name="l01380"></a>01380     }
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="comment">// given any values in the leaves this</span>
<a name="l01384"></a>01384 <span class="comment">// routing recomputes upper levels of the tree</span>
<a name="l01385"></a>01385 <span class="comment">// from scratch in linear time</span>
<a name="l01386"></a>01386 <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
<a name="l01387"></a>01387 <span class="comment">// return winner index</span>
<a name="l01388"></a>01388     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01389"></a>01389     unsigned_type loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::initWinner(unsigned_type root)
<a name="l01390"></a>01390     {
<a name="l01391"></a>01391         <span class="keywordflow">if</span> (root &gt;= k) { <span class="comment">// leaf reached</span>
<a name="l01392"></a>01392             <span class="keywordflow">return</span> root - k;
<a name="l01393"></a>01393         } <span class="keywordflow">else</span> {
<a name="l01394"></a>01394             unsigned_type left = initWinner(2 * root);
<a name="l01395"></a>01395             unsigned_type right = initWinner(2 * root + 1);
<a name="l01396"></a>01396             Element lk = *(current[left]);
<a name="l01397"></a>01397             Element rk = *(current[right]);
<a name="l01398"></a>01398             <span class="keywordflow">if</span> (!(cmp(lk, rk))) { <span class="comment">// right subtree looses</span>
<a name="l01399"></a>01399                 entry[root].index = right;
<a name="l01400"></a>01400                 entry[root].key = rk;
<a name="l01401"></a>01401                 <span class="keywordflow">return</span> left;
<a name="l01402"></a>01402             } <span class="keywordflow">else</span> {
<a name="l01403"></a>01403                 entry[root].index = left;
<a name="l01404"></a>01404                 entry[root].key = lk;
<a name="l01405"></a>01405                 <span class="keywordflow">return</span> right;
<a name="l01406"></a>01406             }
<a name="l01407"></a>01407         }
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="comment">// first go up the tree all the way to the root</span>
<a name="l01412"></a>01412 <span class="comment">// hand down old winner for the respective subtree</span>
<a name="l01413"></a>01413 <span class="comment">// based on new value, and old winner and loser</span>
<a name="l01414"></a>01414 <span class="comment">// update each node on the path to the root top down.</span>
<a name="l01415"></a>01415 <span class="comment">// This is implemented recursively</span>
<a name="l01416"></a>01416     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01417"></a>01417     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::update_on_insert(
<a name="l01418"></a>01418         unsigned_type node,
<a name="l01419"></a>01419         <span class="keyword">const</span> Element &amp; newKey,
<a name="l01420"></a>01420         unsigned_type newIndex,
<a name="l01421"></a>01421         Element * winnerKey,
<a name="l01422"></a>01422         unsigned_type * winnerIndex,       <span class="comment">// old winner</span>
<a name="l01423"></a>01423         unsigned_type * mask)              <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
<a name="l01424"></a>01424     {
<a name="l01425"></a>01425         <span class="keywordflow">if</span> (node == 0) {                   <span class="comment">// winner part of root</span>
<a name="l01426"></a>01426             *mask = 1 &lt;&lt; (logK - 1);
<a name="l01427"></a>01427             *winnerKey = entry[0].key;
<a name="l01428"></a>01428             *winnerIndex = entry[0].index;
<a name="l01429"></a>01429             <span class="keywordflow">if</span> (cmp(entry[node].key, newKey))
<a name="l01430"></a>01430             {
<a name="l01431"></a>01431                 entry[node].key = newKey;
<a name="l01432"></a>01432                 entry[node].index = newIndex;
<a name="l01433"></a>01433             }
<a name="l01434"></a>01434         } <span class="keywordflow">else</span> {
<a name="l01435"></a>01435             update_on_insert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
<a name="l01436"></a>01436             Element loserKey = entry[node].key;
<a name="l01437"></a>01437             unsigned_type loserIndex = entry[node].index;
<a name="l01438"></a>01438             <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
<a name="l01439"></a>01439                 <span class="keywordflow">if</span> (cmp(loserKey, newKey)) {                    <span class="comment">// newKey will have influence here</span>
<a name="l01440"></a>01440                     <span class="keywordflow">if</span> (cmp(*winnerKey, newKey)) {              <span class="comment">// old winner loses here</span>
<a name="l01441"></a>01441                         entry[node].key = *winnerKey;
<a name="l01442"></a>01442                         entry[node].index = *winnerIndex;
<a name="l01443"></a>01443                     } <span class="keywordflow">else</span> {                                    <span class="comment">// new entry looses here</span>
<a name="l01444"></a>01444                         entry[node].key = newKey;
<a name="l01445"></a>01445                         entry[node].index = newIndex;
<a name="l01446"></a>01446                     }
<a name="l01447"></a>01447                 }
<a name="l01448"></a>01448                 *winnerKey = loserKey;
<a name="l01449"></a>01449                 *winnerIndex = loserIndex;
<a name="l01450"></a>01450             }
<a name="l01451"></a>01451             <span class="comment">// note that nothing needs to be done if</span>
<a name="l01452"></a>01452             <span class="comment">// the winner came from the same subtree</span>
<a name="l01453"></a>01453             <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to loose</span>
<a name="l01454"></a>01454             <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
<a name="l01455"></a>01455             <span class="comment">//                           entry further down the tree</span>
<a name="l01456"></a>01456             <span class="comment">// also the same old winner is handed down the tree</span>
<a name="l01457"></a>01457 
<a name="l01458"></a>01458             *mask &gt;&gt;= 1; <span class="comment">// next level</span>
<a name="l01459"></a>01459         }
<a name="l01460"></a>01460     }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="comment">// make the tree two times as wide</span>
<a name="l01464"></a>01464     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01465"></a>01465     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::doubleK()
<a name="l01466"></a>01466     {
<a name="l01467"></a>01467         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::doubleK (before) k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" KNKMAX="</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l01468"></a>01468         assert(k &gt; 0);
<a name="l01469"></a>01469         assert(k &lt; KNKMAX);
<a name="l01470"></a>01470         assert(free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());                   <span class="comment">// stack was free (probably not needed)</span>
<a name="l01471"></a>01471 
<a name="l01472"></a>01472         <span class="comment">// make all new entries free</span>
<a name="l01473"></a>01473         <span class="comment">// and push them on the free stack</span>
<a name="l01474"></a>01474         <span class="keywordflow">for</span> (unsigned_type i = 2 * k - 1;  i &gt;= k;  i--) <span class="comment">// backwards</span>
<a name="l01475"></a>01475         {
<a name="l01476"></a>01476             current[i] = &amp;sentinel;
<a name="l01477"></a>01477             segment[i] = NULL;
<a name="l01478"></a>01478             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(i);
<a name="l01479"></a>01479         }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481         <span class="comment">// double the size</span>
<a name="l01482"></a>01482         k *= 2;
<a name="l01483"></a>01483         logK++;
<a name="l01484"></a>01484 
<a name="l01485"></a>01485         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::doubleK (after)  k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" KNKMAX="</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l01486"></a>01486         assert(!free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l01487"></a>01487 
<a name="l01488"></a>01488         <span class="comment">// recompute loser tree information</span>
<a name="l01489"></a>01489         rebuildLoserTree();
<a name="l01490"></a>01490     }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="comment">// compact nonempty segments in the left half of the tree</span>
<a name="l01494"></a>01494     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01495"></a>01495     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::compactTree()
<a name="l01496"></a>01496     {
<a name="l01497"></a>01497         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::compactTree (before) k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l01498"></a>01498         assert(logK &gt; 0);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         <span class="comment">// compact all nonempty segments to the left</span>
<a name="l01501"></a>01501         unsigned_type from = 0;
<a name="l01502"></a>01502         unsigned_type to = 0;
<a name="l01503"></a>01503         <span class="keywordflow">for</span> ( ;  from &lt; k;  from++)
<a name="l01504"></a>01504         {
<a name="l01505"></a>01505             <span class="keywordflow">if</span> (not_sentinel(*(current[from])))
<a name="l01506"></a>01506             {
<a name="l01507"></a>01507                 segment_size[to] = segment_size[from];
<a name="l01508"></a>01508                 current[to] = current[from];
<a name="l01509"></a>01509                 segment[to] = segment[from];
<a name="l01510"></a>01510                 to++;
<a name="l01511"></a>01511             }<span class="comment">/*</span>
<a name="l01512"></a>01512 <span class="comment">                else</span>
<a name="l01513"></a>01513 <span class="comment">                {</span>
<a name="l01514"></a>01514 <span class="comment">                if(segment[from])</span>
<a name="l01515"></a>01515 <span class="comment">                {</span>
<a name="l01516"></a>01516 <span class="comment">                STXXL_VERBOSE2("loser_tree::compactTree() deleting segment "&lt;&lt;from&lt;&lt;</span>
<a name="l01517"></a>01517 <span class="comment">                                        " address: "&lt;&lt;segment[from]&lt;&lt;" size: "&lt;&lt;segment_size[from]);</span>
<a name="l01518"></a>01518 <span class="comment">                delete [] segment[from];</span>
<a name="l01519"></a>01519 <span class="comment">                segment[from] = 0;</span>
<a name="l01520"></a>01520 <span class="comment">                mem_cons_ -= segment_size[from];</span>
<a name="l01521"></a>01521 <span class="comment">                }</span>
<a name="l01522"></a>01522 <span class="comment">                }*/</span>
<a name="l01523"></a>01523         }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525         <span class="comment">// half degree as often as possible</span>
<a name="l01526"></a>01526         <span class="keywordflow">while</span> (k &gt; 1 &amp;&amp; to &lt;= (k / 2)) {
<a name="l01527"></a>01527             k /= 2;
<a name="l01528"></a>01528             logK--;
<a name="l01529"></a>01529         }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531         <span class="comment">// overwrite garbage and compact the stack of free segment indices</span>
<a name="l01532"></a>01532         free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#982682b58cc39ab5315c736dcb45953a">clear</a>(); <span class="comment">// none free</span>
<a name="l01533"></a>01533         <span class="keywordflow">for</span> ( ;  to &lt; k;  to++) {
<a name="l01534"></a>01534             current[to] = &amp;sentinel;
<a name="l01535"></a>01535             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(to);
<a name="l01536"></a>01536         }
<a name="l01537"></a>01537 
<a name="l01538"></a>01538         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::compactTree (after)  k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" logK="</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l01539"></a>01539 
<a name="l01540"></a>01540         <span class="comment">// recompute loser tree information</span>
<a name="l01541"></a>01541         rebuildLoserTree();
<a name="l01542"></a>01542     }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 <span class="comment">// insert segment beginning at to</span>
<a name="l01546"></a>01546 <span class="comment">// require: spaceIsAvailable() == 1</span>
<a name="l01547"></a>01547     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01548"></a>01548     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::insert_segment(Element * to, unsigned_type sz)
<a name="l01549"></a>01549     {
<a name="l01550"></a>01550         STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::insert_segment("</span> &lt;&lt; to &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l01551"></a>01551         <span class="comment">//std::copy(to,to + sz,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
<a name="l01552"></a>01552 
<a name="l01553"></a>01553         <span class="keywordflow">if</span> (sz &gt; 0)
<a name="l01554"></a>01554         {
<a name="l01555"></a>01555             assert(not_sentinel(to[0]));
<a name="l01556"></a>01556             assert(not_sentinel(to[sz - 1]));
<a name="l01557"></a>01557             assert(is_sentinel(to[sz]));
<a name="l01558"></a>01558 
<a name="l01559"></a>01559             <span class="comment">// get a free slot</span>
<a name="l01560"></a>01560             <span class="keywordflow">if</span> (free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>()) { <span class="comment">// tree is too small</span>
<a name="l01561"></a>01561                 doubleK();
<a name="l01562"></a>01562             }
<a name="l01563"></a>01563             assert(!free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l01564"></a>01564             unsigned_type index = free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#260aebd0649fa31377d5d9a710be25f1">top</a>();
<a name="l01565"></a>01565             free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#e37bfa686d3792bcc99bfd555793a5aa">pop</a>();
<a name="l01566"></a>01566 
<a name="l01567"></a>01567 
<a name="l01568"></a>01568             <span class="comment">// link new segment</span>
<a name="l01569"></a>01569             current[index] = segment[index] = to;
<a name="l01570"></a>01570             segment_size[index] = (sz + 1) * <span class="keyword">sizeof</span>(value_type);
<a name="l01571"></a>01571             mem_cons_ += (sz + 1) * <span class="keyword">sizeof</span>(value_type);
<a name="l01572"></a>01572             size_ += sz;
<a name="l01573"></a>01573 
<a name="l01574"></a>01574             <span class="comment">// propagate new information up the tree</span>
<a name="l01575"></a>01575             Element dummyKey;
<a name="l01576"></a>01576             unsigned_type dummyIndex;
<a name="l01577"></a>01577             unsigned_type dummyMask;
<a name="l01578"></a>01578             update_on_insert((index + k) &gt;&gt; 1, *to, index,
<a name="l01579"></a>01579                              &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
<a name="l01580"></a>01580         } <span class="keywordflow">else</span> {
<a name="l01581"></a>01581             <span class="comment">// immediately deallocate</span>
<a name="l01582"></a>01582             <span class="comment">// this is not only an optimization</span>
<a name="l01583"></a>01583             <span class="comment">// but also needed to keep free segments from</span>
<a name="l01584"></a>01584             <span class="comment">// clogging up the tree</span>
<a name="l01585"></a>01585             <span class="keyword">delete</span>[] to;
<a name="l01586"></a>01586         }
<a name="l01587"></a>01587     }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 
<a name="l01590"></a>01590     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01591"></a>01591     loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::~loser_tree()
<a name="l01592"></a>01592     {
<a name="l01593"></a>01593         STXXL_VERBOSE1(<span class="stringliteral">"loser_tree::~loser_tree()"</span>);
<a name="l01594"></a>01594         <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; k; ++i)
<a name="l01595"></a>01595         {
<a name="l01596"></a>01596             <span class="keywordflow">if</span> (segment[i])
<a name="l01597"></a>01597             {
<a name="l01598"></a>01598                 STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::~loser_tree() deleting segment "</span> &lt;&lt; i);
<a name="l01599"></a>01599                 <span class="keyword">delete</span>[] segment[i];
<a name="l01600"></a>01600                 mem_cons_ -= segment_size[i];
<a name="l01601"></a>01601             }
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603         <span class="comment">// check whether we did not loose memory</span>
<a name="l01604"></a>01604         assert(mem_cons_ == 0);
<a name="l01605"></a>01605     }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607 <span class="comment">// free an empty segment .</span>
<a name="l01608"></a>01608     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01609"></a>01609     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::deallocate_segment(unsigned_type slot)
<a name="l01610"></a>01610     {
<a name="l01611"></a>01611         <span class="comment">// reroute current pointer to some empty sentinel segment</span>
<a name="l01612"></a>01612         <span class="comment">// with a sentinel key</span>
<a name="l01613"></a>01613         STXXL_VERBOSE2(<span class="stringliteral">"loser_tree::deallocate_segment() deleting segment "</span> &lt;&lt;
<a name="l01614"></a>01614                        slot &lt;&lt; <span class="stringliteral">" address: "</span> &lt;&lt; segment[slot] &lt;&lt; <span class="stringliteral">" size: "</span> &lt;&lt; segment_size[slot]);
<a name="l01615"></a>01615         current[slot] = &amp;sentinel;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617         <span class="comment">// free memory</span>
<a name="l01618"></a>01618         <span class="keyword">delete</span>[] segment[slot];
<a name="l01619"></a>01619         segment[slot] = NULL;
<a name="l01620"></a>01620         mem_cons_ -= segment_size[slot];
<a name="l01621"></a>01621 
<a name="l01622"></a>01622         <span class="comment">// push on the stack of free segment indices</span>
<a name="l01623"></a>01623         free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#f9482871699db2a401286394b4260fa7">push</a>(slot);
<a name="l01624"></a>01624     }
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="comment">// delete the length smallest elements and write them to "to"</span>
<a name="l01628"></a>01628 <span class="comment">// empty segments are deallocated</span>
<a name="l01629"></a>01629 <span class="comment">// require:</span>
<a name="l01630"></a>01630 <span class="comment">// - there are at least length elements</span>
<a name="l01631"></a>01631 <span class="comment">// - segments are ended by sentinels</span>
<a name="l01632"></a>01632     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01633"></a>01633     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::multi_merge(Element * to, unsigned_type length)
<a name="l01634"></a>01634     {
<a name="l01635"></a>01635         STXXL_VERBOSE3(<span class="stringliteral">"loser_tree::multi_merge(to="</span> &lt;&lt; to &lt;&lt; <span class="stringliteral">", len="</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">") k="</span> &lt;&lt; k);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637         <span class="keywordflow">if</span> (length == 0)
<a name="l01638"></a>01638             <span class="keywordflow">return</span>;
<a name="l01639"></a>01639 
<a name="l01640"></a>01640         assert(k &gt; 0);
<a name="l01641"></a>01641         assert(length &lt;= size_);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643         <span class="comment">//This is the place to make statistics about internal multi_merge calls.</span>
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         <span class="keywordflow">switch</span> (logK) {
<a name="l01646"></a>01646         <span class="keywordflow">case</span> 0:
<a name="l01647"></a>01647             assert(k == 1);
<a name="l01648"></a>01648             assert(entry[0].index == 0);
<a name="l01649"></a>01649             assert(free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>());
<a name="l01650"></a>01650             <span class="comment">//memcpy(to, current[0], length * sizeof(Element));</span>
<a name="l01651"></a>01651             std::copy(current[0], current[0] + length, to);
<a name="l01652"></a>01652             current[0] += length;
<a name="l01653"></a>01653             entry[0].key = **current;
<a name="l01654"></a>01654             <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l01655"></a>01655                 deallocate_segment(0);
<a name="l01656"></a>01656 
<a name="l01657"></a>01657             <span class="keywordflow">break</span>;
<a name="l01658"></a>01658         <span class="keywordflow">case</span> 1:
<a name="l01659"></a>01659             assert(k == 2);
<a name="l01660"></a>01660             merge_iterator(current[0], current[1], to, length, cmp);
<a name="l01661"></a>01661             rebuildLoserTree();
<a name="l01662"></a>01662             <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l01663"></a>01663                 deallocate_segment(0);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665             <span class="keywordflow">if</span> (is_segment_empty(1))
<a name="l01666"></a>01666                 deallocate_segment(1);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668             <span class="keywordflow">break</span>;
<a name="l01669"></a>01669         <span class="keywordflow">case</span> 2:
<a name="l01670"></a>01670             assert(k == 4);
<a name="l01671"></a>01671             <span class="keywordflow">if</span> (is_segment_empty(3))
<a name="l01672"></a>01672                 merge3_iterator(current[0], current[1], current[2], to, length, cmp);
<a name="l01673"></a>01673             <span class="keywordflow">else</span>
<a name="l01674"></a>01674                 merge4_iterator(current[0], current[1], current[2], current[3], to, length, cmp);
<a name="l01675"></a>01675 
<a name="l01676"></a>01676             rebuildLoserTree();
<a name="l01677"></a>01677             <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l01678"></a>01678                 deallocate_segment(0);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680             <span class="keywordflow">if</span> (is_segment_empty(1))
<a name="l01681"></a>01681                 deallocate_segment(1);
<a name="l01682"></a>01682 
<a name="l01683"></a>01683             <span class="keywordflow">if</span> (is_segment_empty(2))
<a name="l01684"></a>01684                 deallocate_segment(2);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686             <span class="keywordflow">if</span> (is_segment_empty(3))
<a name="l01687"></a>01687                 deallocate_segment(3);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689             <span class="keywordflow">break</span>;
<a name="l01690"></a>01690         <span class="keywordflow">case</span>  3: multi_merge_f&lt;3&gt;(to, length);
<a name="l01691"></a>01691             <span class="keywordflow">break</span>;
<a name="l01692"></a>01692         <span class="keywordflow">case</span>  4: multi_merge_f&lt;4&gt;(to, length);
<a name="l01693"></a>01693             <span class="keywordflow">break</span>;
<a name="l01694"></a>01694         <span class="keywordflow">case</span>  5: multi_merge_f&lt;5&gt;(to, length);
<a name="l01695"></a>01695             <span class="keywordflow">break</span>;
<a name="l01696"></a>01696         <span class="keywordflow">case</span>  6: multi_merge_f&lt;6&gt;(to, length);
<a name="l01697"></a>01697             <span class="keywordflow">break</span>;
<a name="l01698"></a>01698         <span class="keywordflow">case</span>  7: multi_merge_f&lt;7&gt;(to, length);
<a name="l01699"></a>01699             <span class="keywordflow">break</span>;
<a name="l01700"></a>01700         <span class="keywordflow">case</span>  8: multi_merge_f&lt;8&gt;(to, length);
<a name="l01701"></a>01701             <span class="keywordflow">break</span>;
<a name="l01702"></a>01702         <span class="keywordflow">case</span>  9: multi_merge_f&lt;9&gt;(to, length);
<a name="l01703"></a>01703             <span class="keywordflow">break</span>;
<a name="l01704"></a>01704         <span class="keywordflow">case</span> 10: multi_merge_f&lt;10&gt;(to, length);
<a name="l01705"></a>01705             <span class="keywordflow">break</span>;
<a name="l01706"></a>01706         <span class="keywordflow">default</span>: multi_merge_k(to, length);
<a name="l01707"></a>01707             <span class="keywordflow">break</span>;
<a name="l01708"></a>01708         }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710 
<a name="l01711"></a>01711         size_ -= length;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713         <span class="comment">// compact tree if it got considerably smaller</span>
<a name="l01714"></a>01714         {
<a name="l01715"></a>01715             <span class="keyword">const</span> unsigned_type num_segments_used = k - free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>();
<a name="l01716"></a>01716             <span class="keyword">const</span> unsigned_type num_segments_trigger = k - (3 * k / 5);
<a name="l01717"></a>01717             <span class="comment">// using k/2 would be worst case inefficient (for large k)</span>
<a name="l01718"></a>01718             <span class="comment">// for k \in {2, 4, 8} the trigger is k/2 which is good</span>
<a name="l01719"></a>01719             <span class="comment">// because we have special mergers for k \in {1, 2, 4}</span>
<a name="l01720"></a>01720             <span class="comment">// there is also a special 3-way-merger, that will be</span>
<a name="l01721"></a>01721             <span class="comment">// triggered if k == 4 &amp;&amp; is_segment_empty(3)</span>
<a name="l01722"></a>01722             STXXL_VERBOSE3(<span class="stringliteral">"loser_tree  compact? k="</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" #used="</span> &lt;&lt; num_segments_used
<a name="l01723"></a>01723                                                      &lt;&lt; <span class="stringliteral">" &lt;= #trigger="</span> &lt;&lt; num_segments_trigger &lt;&lt; <span class="stringliteral">" ==&gt; "</span>
<a name="l01724"></a>01724                                                      &lt;&lt; ((k &gt; 1 &amp;&amp; num_segments_used &lt;= num_segments_trigger) ? <span class="stringliteral">"yes"</span> : <span class="stringliteral">"no "</span>)
<a name="l01725"></a>01725                                                      &lt;&lt; <span class="stringliteral">" || "</span>
<a name="l01726"></a>01726                                                      &lt;&lt; ((k == 4 &amp;&amp; !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>() &amp;&amp; !is_segment_empty(3)) ? <span class="stringliteral">"yes"</span> : <span class="stringliteral">"no "</span>)
<a name="l01727"></a>01727                                                      &lt;&lt; <span class="stringliteral">" #free="</span> &lt;&lt; free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#b44c21916e5596864fbe60e71d5d4cce">size</a>());
<a name="l01728"></a>01728             <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; ((num_segments_used &lt;= num_segments_trigger) ||
<a name="l01729"></a>01729                           (k == 4 &amp;&amp; !free_segments.<a class="code" href="classpriority__queue__local_1_1internal__bounded__stack.html#4a0216ea7605dae89d525119a70d499c">empty</a>() &amp;&amp; !is_segment_empty(3))))
<a name="l01730"></a>01730             {
<a name="l01731"></a>01731                 compactTree();
<a name="l01732"></a>01732             }
<a name="l01733"></a>01733         }
<a name="l01734"></a>01734         <span class="comment">//std::copy(to,to + length,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
<a name="l01735"></a>01735     }
<a name="l01736"></a>01736 
<a name="l01737"></a>01737 
<a name="l01738"></a>01738 <span class="comment">// is this segment empty and does not point to sentinel yet?</span>
<a name="l01739"></a>01739     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01740"></a>01740     <span class="keyword">inline</span> <span class="keywordtype">bool</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::is_segment_empty(unsigned_type slot)
<a name="l01741"></a>01741     {
<a name="l01742"></a>01742         <span class="keywordflow">return</span> (is_sentinel(*(current[slot])) &amp;&amp; (current[slot] != &amp;sentinel));
<a name="l01743"></a>01743     }
<a name="l01744"></a>01744 
<a name="l01745"></a>01745 <span class="comment">// multi-merge for arbitrary K</span>
<a name="l01746"></a>01746     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01747"></a>01747     <span class="keywordtype">void</span> loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::
<a name="l01748"></a>01748     multi_merge_k(Element * to, unsigned_type length)
<a name="l01749"></a>01749     {
<a name="l01750"></a>01750         Entry * currentPos;
<a name="l01751"></a>01751         Element currentKey;
<a name="l01752"></a>01752         unsigned_type currentIndex; <span class="comment">// leaf pointed to by current entry</span>
<a name="l01753"></a>01753         unsigned_type kReg = k;
<a name="l01754"></a>01754         Element * done = to + length;
<a name="l01755"></a>01755         unsigned_type winnerIndex = entry[0].index;
<a name="l01756"></a>01756         Element winnerKey = entry[0].key;
<a name="l01757"></a>01757         Element * winnerPos;
<a name="l01758"></a>01758 
<a name="l01759"></a>01759         <span class="keywordflow">while</span> (to != done)
<a name="l01760"></a>01760         {
<a name="l01761"></a>01761             winnerPos = current[winnerIndex];
<a name="l01762"></a>01762 
<a name="l01763"></a>01763             <span class="comment">// write result</span>
<a name="l01764"></a>01764             *to = winnerKey;
<a name="l01765"></a>01765 
<a name="l01766"></a>01766             <span class="comment">// advance winner segment</span>
<a name="l01767"></a>01767             ++winnerPos;
<a name="l01768"></a>01768             current[winnerIndex] = winnerPos;
<a name="l01769"></a>01769             winnerKey = *winnerPos;
<a name="l01770"></a>01770 
<a name="l01771"></a>01771             <span class="comment">// remove winner segment if empty now</span>
<a name="l01772"></a>01772             <span class="keywordflow">if</span> (is_sentinel(winnerKey)) <span class="comment">//</span>
<a name="l01773"></a>01773                 deallocate_segment(winnerIndex);
<a name="l01774"></a>01774 
<a name="l01775"></a>01775 
<a name="l01776"></a>01776             <span class="comment">// go up the entry-tree</span>
<a name="l01777"></a>01777             <span class="keywordflow">for</span> (unsigned_type i = (winnerIndex + kReg) &gt;&gt; 1;  i &gt; 0;  i &gt;&gt;= 1) {
<a name="l01778"></a>01778                 currentPos = entry + i;
<a name="l01779"></a>01779                 currentKey = currentPos-&gt;key;
<a name="l01780"></a>01780                 <span class="keywordflow">if</span> (cmp(winnerKey, currentKey)) {
<a name="l01781"></a>01781                     currentIndex = currentPos-&gt;index;
<a name="l01782"></a>01782                     currentPos-&gt;key = winnerKey;
<a name="l01783"></a>01783                     currentPos-&gt;index = winnerIndex;
<a name="l01784"></a>01784                     winnerKey = currentKey;
<a name="l01785"></a>01785                     winnerIndex = currentIndex;
<a name="l01786"></a>01786                 }
<a name="l01787"></a>01787             }
<a name="l01788"></a>01788 
<a name="l01789"></a>01789             ++to;
<a name="l01790"></a>01790         }
<a name="l01791"></a>01791         entry[0].index = winnerIndex;
<a name="l01792"></a>01792         entry[0].key = winnerKey;
<a name="l01793"></a>01793     }
<a name="l01794"></a>01794 }
<a name="l01795"></a>01795 
<a name="l01796"></a>01796 <span class="comment">/*</span>
<a name="l01797"></a>01797 <span class="comment"></span>
<a name="l01798"></a>01798 <span class="comment">   KNBufferSize1 = 32;</span>
<a name="l01799"></a>01799 <span class="comment">   KNN = 512; // bandwidth</span>
<a name="l01800"></a>01800 <span class="comment">   KNKMAX = 64;  // maximal arity</span>
<a name="l01801"></a>01801 <span class="comment">   KNLevels = 4; // overall capacity &gt;= KNN*KNKMAX^KNLevels</span>
<a name="l01802"></a>01802 <span class="comment">   LogKNKMAX = 6;  // ceil(log KNK)</span>
<a name="l01803"></a>01803 <span class="comment"> */</span>
<a name="l01804"></a>01804 
<a name="l01805"></a>01805 <span class="comment">// internal memory consumption &gt;= N_*(KMAX_^Levels_) + ext</span>
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 <span class="keyword">template</span> &lt;
<a name="l01808"></a>01808     <span class="keyword">class </span>Tp_,
<a name="l01809"></a>01809     <span class="keyword">class </span>Cmp_,
<a name="l01810"></a>01810     <span class="keywordtype">unsigned</span> BufferSize1_ = 32,       <span class="comment">// equalize procedure call overheads etc.</span>
<a name="l01811"></a>01811     <span class="keywordtype">unsigned</span> N_ = 512,                <span class="comment">// bandwidth</span>
<a name="l01812"></a>01812     <span class="keywordtype">unsigned</span> IntKMAX_ = 64,           <span class="comment">// maximal arity for internal mergers</span>
<a name="l01813"></a>01813     <span class="keywordtype">unsigned</span> IntLevels_ = 4,
<a name="l01814"></a>01814     <span class="keywordtype">unsigned</span> BlockSize_ = (2 * 1024 * 1024),
<a name="l01815"></a>01815     <span class="keywordtype">unsigned</span> ExtKMAX_ = 64,           <span class="comment">// maximal arity for external mergers</span>
<a name="l01816"></a>01816     <span class="keywordtype">unsigned</span> ExtLevels_ = 2,
<a name="l01817"></a>01817     <span class="keyword">class</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY
<a name="l01818"></a>01818     &gt;
<a name="l01819"></a>01819 <span class="keyword">struct</span> priority_queue_config
<a name="l01820"></a>01820 {
<a name="l01821"></a>01821     <span class="keyword">typedef</span> Tp_ value_type;
<a name="l01822"></a>01822     <span class="keyword">typedef</span> Cmp_ comparator_type;
<a name="l01823"></a>01823     <span class="keyword">typedef</span> AllocStr_ alloc_strategy_type;
<a name="l01824"></a>01824     <span class="keyword">enum</span>
<a name="l01825"></a>01825     {
<a name="l01826"></a>01826         BufferSize1 = BufferSize1_,
<a name="l01827"></a>01827         N = N_,
<a name="l01828"></a>01828         IntKMAX = IntKMAX_,
<a name="l01829"></a>01829         IntLevels = IntLevels_,
<a name="l01830"></a>01830         ExtLevels = ExtLevels_,
<a name="l01831"></a>01831         BlockSize = BlockSize_,
<a name="l01832"></a>01832         ExtKMAX = ExtKMAX_,
<a name="l01833"></a>01833         E = <span class="keyword">sizeof</span>(Tp_)
<a name="l01834"></a>01834     };
<a name="l01835"></a>01835 };
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 __STXXL_END_NAMESPACE
<a name="l01838"></a>01838 
<a name="l01839"></a>01839 <span class="keyword">namespace </span>std
<a name="l01840"></a>01840 {
<a name="l01841"></a>01841     <span class="keyword">template</span> &lt;<span class="keyword">class </span>BlockType_,
<a name="l01842"></a>01842               <span class="keyword">class </span>Cmp_,
<a name="l01843"></a>01843               <span class="keywordtype">unsigned</span> Arity_,
<a name="l01844"></a>01844               <span class="keyword">class </span>AllocStr_&gt;
<a name="l01845"></a>01845     <span class="keywordtype">void</span> swap(stxxl::priority_queue_local::ext_merger&lt;BlockType_, Cmp_, Arity_, AllocStr_&gt; &amp; a,
<a name="l01846"></a>01846               stxxl::priority_queue_local::ext_merger&lt;BlockType_, Cmp_, Arity_, AllocStr_&gt; &amp; b)
<a name="l01847"></a>01847     {
<a name="l01848"></a>01848         a.swap(b);
<a name="l01849"></a>01849     }
<a name="l01850"></a>01850     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l01851"></a>01851     <span class="keywordtype">void</span> swap(stxxl::priority_queue_local::loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt; &amp; a,
<a name="l01852"></a>01852               stxxl::priority_queue_local::loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt; &amp; b)
<a name="l01853"></a>01853     {
<a name="l01854"></a>01854         a.swap(b);
<a name="l01855"></a>01855     }
<a name="l01856"></a>01856 }
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 __STXXL_BEGIN_NAMESPACE
<a name="l01859"></a>01859 
<a name="l01861"></a>01861 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01862"></a><a class="code" href="classpriority__queue.html">01862</a> <span class="keyword">class </span><a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> : <span class="keyword">private</span> noncopyable
<a name="l01863"></a>01863 {
<a name="l01864"></a>01864 <span class="keyword">public</span>:
<a name="l01865"></a>01865     <span class="keyword">typedef</span> Config_ Config;
<a name="l01866"></a>01866     <span class="keyword">enum</span>
<a name="l01867"></a>01867     {
<a name="l01868"></a>01868         BufferSize1 = Config::BufferSize1,
<a name="l01869"></a>01869         N = Config::N,
<a name="l01870"></a>01870         IntKMAX = Config::IntKMAX,
<a name="l01871"></a>01871         IntLevels = Config::IntLevels,
<a name="l01872"></a>01872         ExtLevels = Config::ExtLevels,
<a name="l01873"></a>01873         Levels = Config::IntLevels + Config::ExtLevels,
<a name="l01874"></a>01874         BlockSize = Config::BlockSize,
<a name="l01875"></a>01875         ExtKMAX = Config::ExtKMAX
<a name="l01876"></a>01876     };
<a name="l01877"></a>01877 
<a name="l01879"></a><a class="code" href="classpriority__queue.html#66acd9303a98de8031b5767f9a5c9396">01879</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_type value_type;
<a name="l01881"></a><a class="code" href="classpriority__queue.html#aa45436f6af3da8217fbd21502595079">01881</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::comparator_type comparator_type;
<a name="l01882"></a>01882     <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::alloc_strategy_type alloc_strategy_type;
<a name="l01884"></a><a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2">01884</a>     <span class="keyword">typedef</span> stxxl::uint64 size_type;
<a name="l01885"></a>01885     <span class="keyword">typedef</span> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">typed_block&lt;BlockSize, value_type&gt;</a> <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>;
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 <span class="keyword">protected</span>:
<a name="l01888"></a>01888     <span class="keyword">typedef</span> <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html" title="Similar to std::priority_queue, with the following differences:Maximum size is fixed...">priority_queue_local::internal_priority_queue&lt;value_type, std::vector&lt;value_type&gt;</a>, comparator_type&gt;
<a name="l01889"></a>01889     <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html" title="Similar to std::priority_queue, with the following differences:Maximum size is fixed...">insert_heap_type</a>;
<a name="l01890"></a>01890 
<a name="l01891"></a>01891     <span class="keyword">typedef</span> <a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">priority_queue_local::loser_tree</a>&lt;
<a name="l01892"></a>01892         value_type,
<a name="l01893"></a>01893         comparator_type,
<a name="l01894"></a>01894         IntKMAX&gt; <a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">int_merger_type</a>;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896     <span class="keyword">typedef</span> <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">priority_queue_local::ext_merger</a>&lt;
<a name="l01897"></a>01897         <a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>,
<a name="l01898"></a>01898         comparator_type,
<a name="l01899"></a>01899         ExtKMAX,
<a name="l01900"></a>01900         alloc_strategy_type&gt; <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger_type</a>;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     <a class="code" href="classpriority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &amp;quot;Sorting and Searching&amp;quot;, Section 5.4.1 !">int_merger_type</a> itree[IntLevels];
<a name="l01904"></a>01904     <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool;
<a name="l01905"></a>01905     <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> &amp; w_pool;
<a name="l01906"></a>01906     <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger_type</a> * etree;
<a name="l01907"></a>01907 
<a name="l01908"></a>01908     <span class="comment">// one delete buffer for each tree =&gt; group buffer</span>
<a name="l01909"></a>01909     value_type buffer2[Levels][N + 1]; <span class="comment">// tree-&gt;buffer2-&gt;buffer1 (extra space for sentinel)</span>
<a name="l01910"></a>01910     value_type * minBuffer2[Levels];   <span class="comment">// minBuffer2[i] is current start of buffer2[i], end is buffer2[i] + N</span>
<a name="l01911"></a>01911 
<a name="l01912"></a>01912     <span class="comment">// overall delete buffer</span>
<a name="l01913"></a>01913     value_type buffer1[BufferSize1 + 1];
<a name="l01914"></a>01914     value_type * minBuffer1;           <span class="comment">// is current start of buffer1, end is buffer1 + BufferSize1</span>
<a name="l01915"></a>01915 
<a name="l01916"></a>01916     comparator_type cmp;
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <span class="comment">// insert buffer</span>
<a name="l01919"></a>01919     <a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html" title="Similar to std::priority_queue, with the following differences:Maximum size is fixed...">insert_heap_type</a> insertHeap;
<a name="l01920"></a>01920 
<a name="l01921"></a>01921     <span class="comment">// how many levels are active</span>
<a name="l01922"></a>01922     unsigned_type activeLevels;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     <span class="comment">// total size not counting insertBuffer and buffer1</span>
<a name="l01925"></a>01925     size_type size_;
<a name="l01926"></a>01926     <span class="keywordtype">bool</span> deallocate_pools;
<a name="l01927"></a>01927 
<a name="l01928"></a>01928     <span class="comment">// private member functions</span>
<a name="l01929"></a>01929     <span class="keywordtype">void</span> refillBuffer1();
<a name="l01930"></a>01930     unsigned_type refillBuffer2(unsigned_type k);
<a name="l01931"></a>01931 
<a name="l01932"></a>01932     unsigned_type makeSpaceAvailable(unsigned_type level);
<a name="l01933"></a>01933     <span class="keywordtype">void</span> emptyInsertHeap();
<a name="l01934"></a>01934 
<a name="l01935"></a>01935     value_type getSupremum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp.min_value(); } <span class="comment">//{ return buffer2[0][KNN].key; }</span>
<a name="l01936"></a>01936     unsigned_type getSize1()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (buffer1 + BufferSize1) - minBuffer1; }
<a name="l01937"></a>01937     unsigned_type getSize2(unsigned_type i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;(buffer2[i][N]) - minBuffer2[i]; }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="keyword">public</span>:
<a name="l01949"></a>01949     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>(<a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool_, <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> &amp; w_pool_);
<a name="l01950"></a>01950 
<a name="l01960"></a>01960     <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>(unsigned_type p_pool_mem, unsigned_type w_pool_mem);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962     <span class="keywordtype">void</span> swap(<a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a> &amp; obj)
<a name="l01963"></a>01963     {
<a name="l01964"></a>01964         <span class="comment">//swap_1D_arrays(itree,obj.itree,IntLevels); // does not work in g++ 3.4.3 :( bug?</span>
<a name="l01965"></a>01965         <span class="keywordflow">for</span> (unsigned_type i = 0; i &lt; IntLevels; ++i)
<a name="l01966"></a>01966             std::swap(itree[i], obj.<a class="code" href="classpriority__queue.html#d97dfe4af63b29dc3758497364d828a3">itree</a>[i]);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968         <span class="comment">// std::swap(p_pool,obj.p_pool);</span>
<a name="l01969"></a>01969         <span class="comment">// std::swap(w_pool,obj.w_pool);</span>
<a name="l01970"></a>01970         std::swap(etree, obj.<a class="code" href="classpriority__queue.html#e728ae1c7645289323313daafe7af956">etree</a>);
<a name="l01971"></a>01971         <span class="keywordflow">for</span> (unsigned_type i1 = 0; i1 &lt; Levels; ++i1)
<a name="l01972"></a>01972             <span class="keywordflow">for</span> (unsigned_type i2 = 0; i2 &lt; (N + 1); ++i2)
<a name="l01973"></a>01973                 std::swap(buffer2[i1][i2], obj.<a class="code" href="classpriority__queue.html#c9a1c0624cbe18c546b9aec6a0a77e96">buffer2</a>[i1][i2]);
<a name="l01974"></a>01974 
<a name="l01975"></a>01975         swap_1D_arrays(minBuffer2, obj.<a class="code" href="classpriority__queue.html#3ba3ff48e228bd7a444d741fe0b9c19a">minBuffer2</a>, Levels);
<a name="l01976"></a>01976         swap_1D_arrays(buffer1, obj.<a class="code" href="classpriority__queue.html#bcdb3ebc9df2ed1678ae9ff8ec4eb519">buffer1</a>, BufferSize1 + 1);
<a name="l01977"></a>01977         std::swap(minBuffer1, obj.<a class="code" href="classpriority__queue.html#6b12870ed2e5c81d9b97ace56058ef90">minBuffer1</a>);
<a name="l01978"></a>01978         std::swap(cmp, obj.<a class="code" href="classpriority__queue.html#716317784bbe8b3b91f0b8baa1863048">cmp</a>);
<a name="l01979"></a>01979         std::swap(insertHeap, obj.<a class="code" href="classpriority__queue.html#8fa67cb48dca3bbe32b1c42605a9724c">insertHeap</a>);
<a name="l01980"></a>01980         std::swap(activeLevels, obj.<a class="code" href="classpriority__queue.html#a0ba9a550bd71f739a7adbd4fcaf9c8a">activeLevels</a>);
<a name="l01981"></a>01981         std::swap(size_, obj.<a class="code" href="classpriority__queue.html#9d641577ce43f80c1730880df7439439">size_</a>);
<a name="l01982"></a>01982         <span class="comment">//std::swap(deallocate_pools,obj.deallocate_pools);</span>
<a name="l01983"></a>01983     }
<a name="l01984"></a>01984 
<a name="l01985"></a>01985     <span class="keyword">virtual</span> ~<a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue</a>();
<a name="l01986"></a>01986 
<a name="l01989"></a>01989     size_type size() <span class="keyword">const</span>;
<a name="l01990"></a>01990 
<a name="l01993"></a><a class="code" href="classpriority__queue.html#32bfb3d2f08e07fbe4aed7fa58de1f5b">01993</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (size() == 0); }
<a name="l01994"></a>01994 
<a name="l02006"></a>02006     <span class="keyword">const</span> value_type &amp; top() <span class="keyword">const</span>;
<a name="l02007"></a>02007 
<a name="l02014"></a>02014     <span class="keywordtype">void</span> pop();
<a name="l02015"></a>02015 
<a name="l02020"></a>02020     <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; obj);
<a name="l02021"></a>02021 
<a name="l02026"></a><a class="code" href="classpriority__queue.html#4c1e9986ada44fed46b391805c13391b">02026</a>     unsigned_type mem_cons()<span class="keyword"> const</span>
<a name="l02027"></a>02027 <span class="keyword">    </span>{
<a name="l02028"></a>02028         unsigned_type dynam_alloc_mem(0), i(0);
<a name="l02029"></a>02029         <span class="comment">//dynam_alloc_mem += w_pool.mem_cons();</span>
<a name="l02030"></a>02030         <span class="comment">//dynam_alloc_mem += p_pool.mem_cons();</span>
<a name="l02031"></a>02031         <span class="keywordflow">for</span> ( ; i &lt; IntLevels; ++i)
<a name="l02032"></a>02032             dynam_alloc_mem += itree[i].mem_cons();
<a name="l02033"></a>02033 
<a name="l02034"></a>02034         <span class="keywordflow">for</span> (i = 0; i &lt; ExtLevels; ++i)
<a name="l02035"></a>02035             dynam_alloc_mem += etree[i].mem_cons();
<a name="l02036"></a>02036 
<a name="l02037"></a>02037 
<a name="l02038"></a>02038         <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(*<span class="keyword">this</span>) +
<a name="l02039"></a>02039                 <span class="keyword">sizeof</span>(<a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger_type</a>) * ExtLevels +
<a name="l02040"></a>02040                 dynam_alloc_mem);
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042 };
<a name="l02043"></a>02043 
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02046"></a><a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d">02046</a> <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::size_type</a> <a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">priority_queue&lt;Config_&gt;::size</a>()<span class="keyword"> const</span>
<a name="l02047"></a>02047 <span class="keyword"></span>{
<a name="l02048"></a>02048     <span class="keywordflow">return</span>
<a name="l02049"></a>02049            size_ +
<a name="l02050"></a>02050            insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">size</a>() - 1 +
<a name="l02051"></a>02051            ((buffer1 + BufferSize1) - minBuffer1);
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 
<a name="l02055"></a>02055 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02056"></a><a class="code" href="group__stlcontinternals.html#g8475d4ea1887c50fd0e74ba37c47b9a7">02056</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::value_type</a> &amp; <a class="code" href="group__stlcontinternals.html#g8475d4ea1887c50fd0e74ba37c47b9a7" title="Returns &amp;quot;largest&amp;quot; element.">priority_queue&lt;Config_&gt;::top</a>()<span class="keyword"> const</span>
<a name="l02057"></a>02057 <span class="keyword"></span>{
<a name="l02058"></a>02058     assert(!insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#fa98d8acda86564ca76f14e31ae8240a">empty</a>());
<a name="l02059"></a>02059 
<a name="l02060"></a>02060     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::value_type</a> &amp; t = insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#b1f0a9ef161bdcaa4e623458946f8057">top</a>();
<a name="l02061"></a>02061     <span class="keywordflow">if</span> (<span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1, t))
<a name="l02062"></a>02062         <span class="keywordflow">return</span> t;
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 
<a name="l02065"></a>02065     <span class="keywordflow">return</span> *minBuffer1;
<a name="l02066"></a>02066 }
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02069"></a><a class="code" href="group__stlcontinternals.html#gca99f9b9ad7b0c7db4f7a1428fc50aac">02069</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__stlcontinternals.html#gca99f9b9ad7b0c7db4f7a1428fc50aac" title="Removes the element at the top.">priority_queue&lt;Config_&gt;::pop</a>()
<a name="l02070"></a>02070 {
<a name="l02071"></a>02071     <span class="comment">//STXXL_VERBOSE1("priority_queue::pop()");</span>
<a name="l02072"></a>02072     assert(!insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#fa98d8acda86564ca76f14e31ae8240a">empty</a>());
<a name="l02073"></a>02073 
<a name="l02074"></a>02074     <span class="keywordflow">if</span> (<span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1, insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#b1f0a9ef161bdcaa4e623458946f8057">top</a>()))
<a name="l02075"></a>02075     {
<a name="l02076"></a>02076         insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#c10e71fe3141a39239c42693aa4ebadd" title="Removes first element.">pop</a>();
<a name="l02077"></a>02077     }
<a name="l02078"></a>02078     <span class="keywordflow">else</span>
<a name="l02079"></a>02079     {
<a name="l02080"></a>02080         assert(minBuffer1 &lt; buffer1 + BufferSize1);
<a name="l02081"></a>02081         ++minBuffer1;
<a name="l02082"></a>02082         <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1)
<a name="l02083"></a>02083             refillBuffer1();
<a name="l02084"></a>02084     }
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02088"></a><a class="code" href="group__stlcontinternals.html#g45ec8f50b6066c5f741bfdaac852a4b3">02088</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__stlcontinternals.html#g45ec8f50b6066c5f741bfdaac852a4b3" title="Inserts x into the priority_queue.">priority_queue&lt;Config_&gt;::push</a>(<span class="keyword">const</span> value_type &amp; obj)
<a name="l02089"></a>02089 {
<a name="l02090"></a>02090     <span class="comment">//STXXL_VERBOSE3("priority_queue::push("&lt;&lt; obj &lt;&lt;")");</span>
<a name="l02091"></a>02091     assert(itree-&gt;<a class="code" href="classpriority__queue__local_1_1loser__tree.html#1117998301b4ca7d413f200b894fbd25">not_sentinel</a>(obj));
<a name="l02092"></a>02092     <span class="keywordflow">if</span> (insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">size</a>() == N + 1)
<a name="l02093"></a>02093         emptyInsertHeap();
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 
<a name="l02096"></a>02096     assert(!insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#fa98d8acda86564ca76f14e31ae8240a">empty</a>());
<a name="l02097"></a>02097 
<a name="l02098"></a>02098     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55" title="Add data to the queue.">push</a>(obj);
<a name="l02099"></a>02099 }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101 
<a name="l02103"></a>02103 
<a name="l02104"></a>02104 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02105"></a><a class="code" href="group__stlcontinternals.html#g861e6cbb1be531f25664f848c8728846">02105</a> <a class="code" href="group__stlcontinternals.html#g861e6cbb1be531f25664f848c8728846" title="Constructs external priority queue object.">priority_queue&lt;Config_&gt;::priority_queue</a>(<a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool_, <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool&lt;block_type&gt;</a> &amp; w_pool_) :
<a name="l02106"></a>02106     p_pool(p_pool_), w_pool(w_pool_),
<a name="l02107"></a>02107     insertHeap(N + 2),
<a name="l02108"></a>02108     activeLevels(0), size_(0),
<a name="l02109"></a>02109     deallocate_pools(false)
<a name="l02110"></a>02110 {
<a name="l02111"></a>02111     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::priority_queue()"</span>);
<a name="l02112"></a>02112     assert(!cmp(cmp.min_value(), cmp.min_value())); <span class="comment">// verify strict weak ordering</span>
<a name="l02113"></a>02113     <span class="comment">//etree = new ext_merger_type[ExtLevels](p_pool,w_pool);</span>
<a name="l02114"></a>02114     etree = <span class="keyword">new</span> <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger_type</a>[ExtLevels];
<a name="l02115"></a>02115     <span class="keywordflow">for</span> (unsigned_type j = 0; j &lt; ExtLevels; ++j)
<a name="l02116"></a>02116         etree[j].set_pools(&amp;p_pool, &amp;w_pool);
<a name="l02117"></a>02117 
<a name="l02118"></a>02118     value_type sentinel = cmp.min_value();
<a name="l02119"></a>02119     buffer1[BufferSize1] = sentinel;      <span class="comment">// sentinel</span>
<a name="l02120"></a>02120     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55" title="Add data to the queue.">push</a>(sentinel);            <span class="comment">// always keep the sentinel</span>
<a name="l02121"></a>02121     minBuffer1 = buffer1 + BufferSize1;   <span class="comment">// empty</span>
<a name="l02122"></a>02122     <span class="keywordflow">for</span> (unsigned_type i = 0;  i &lt; Levels;  i++)
<a name="l02123"></a>02123     {
<a name="l02124"></a>02124         buffer2[i][N] = sentinel;         <span class="comment">// sentinel</span>
<a name="l02125"></a>02125         minBuffer2[i] = &amp;(buffer2[i][N]); <span class="comment">// empty</span>
<a name="l02126"></a>02126     }
<a name="l02127"></a>02127 }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02130"></a><a class="code" href="group__stlcontinternals.html#g812eb7b157a681dfbabaa19503f8ccab">02130</a> <a class="code" href="group__stlcontinternals.html#g861e6cbb1be531f25664f848c8728846" title="Constructs external priority queue object.">priority_queue&lt;Config_&gt;::priority_queue</a>(unsigned_type p_pool_mem, unsigned_type w_pool_mem) :
<a name="l02131"></a>02131     p_pool(*(new <a class="code" href="classprefetch__pool.html" title="Implements dynamically resizable prefetching pool.">prefetch_pool</a>&lt;<a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>&gt;(p_pool_mem / BlockSize))),
<a name="l02132"></a>02132     w_pool(*(new <a class="code" href="classwrite__pool.html" title="Implements dynamically resizable buffered writing pool.">write_pool</a>&lt;<a class="code" href="classtyped__block.html" title="Block containing elements of fixed length.">block_type</a>&gt;(w_pool_mem / BlockSize))),
<a name="l02133"></a>02133     insertHeap(N + 2),
<a name="l02134"></a>02134     activeLevels(0), size_(0),
<a name="l02135"></a>02135     deallocate_pools(true)
<a name="l02136"></a>02136 {
<a name="l02137"></a>02137     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::priority_queue()"</span>);
<a name="l02138"></a>02138     assert(!cmp(cmp.min_value(), cmp.min_value())); <span class="comment">// verify strict weak ordering</span>
<a name="l02139"></a>02139     etree = <span class="keyword">new</span> <a class="code" href="classpriority__queue__local_1_1ext__merger.html" title="External merger, based on the loser tree data structure. !">ext_merger_type</a>[ExtLevels];
<a name="l02140"></a>02140     <span class="keywordflow">for</span> (unsigned_type j = 0; j &lt; ExtLevels; ++j)
<a name="l02141"></a>02141         etree[j].set_pools(&amp;p_pool, &amp;w_pool);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143     value_type sentinel = cmp.min_value();
<a name="l02144"></a>02144     buffer1[BufferSize1] = sentinel;      <span class="comment">// sentinel</span>
<a name="l02145"></a>02145     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55" title="Add data to the queue.">push</a>(sentinel);            <span class="comment">// always keep the sentinel</span>
<a name="l02146"></a>02146     minBuffer1 = buffer1 + BufferSize1;   <span class="comment">// empty</span>
<a name="l02147"></a>02147     <span class="keywordflow">for</span> (unsigned_type i = 0;  i &lt; Levels;  i++)
<a name="l02148"></a>02148     {
<a name="l02149"></a>02149         buffer2[i][N] = sentinel;         <span class="comment">// sentinel</span>
<a name="l02150"></a>02150         minBuffer2[i] = &amp;(buffer2[i][N]); <span class="comment">// empty</span>
<a name="l02151"></a>02151     }
<a name="l02152"></a>02152 }
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02155"></a>02155 <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::~priority_queue</a>()
<a name="l02156"></a>02156 {
<a name="l02157"></a>02157     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::~priority_queue()"</span>);
<a name="l02158"></a>02158     <span class="keywordflow">if</span> (deallocate_pools)
<a name="l02159"></a>02159     {
<a name="l02160"></a>02160         <span class="keyword">delete</span> &amp;p_pool;
<a name="l02161"></a>02161         <span class="keyword">delete</span> &amp;w_pool;
<a name="l02162"></a>02162     }
<a name="l02163"></a>02163 
<a name="l02164"></a>02164     <span class="keyword">delete</span>[] etree;
<a name="l02165"></a>02165 }
<a name="l02166"></a>02166 
<a name="l02167"></a>02167 <span class="comment">//--------------------- Buffer refilling -------------------------------</span>
<a name="l02168"></a>02168 
<a name="l02169"></a>02169 <span class="comment">// refill buffer2[j] and return number of elements found</span>
<a name="l02170"></a>02170 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02171"></a>02171 unsigned_type <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::refillBuffer2</a>(unsigned_type j)
<a name="l02172"></a>02172 {
<a name="l02173"></a>02173     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer2("</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l02174"></a>02174 
<a name="l02175"></a>02175     value_type * oldTarget;
<a name="l02176"></a>02176     unsigned_type deleteSize;
<a name="l02177"></a>02177     <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a> treeSize = (j &lt; IntLevels) ? itree[j].<a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">size</a>() : etree[j - IntLevels].<a class="code" href="classpriority__queue__local_1_1ext__merger.html#6b028e0192e2da99c14273ca58b10635">size</a>();  <span class="comment">//elements left in segments</span>
<a name="l02178"></a>02178     unsigned_type bufferSize = buffer2[j] + N - minBuffer2[j];                             <span class="comment">//elements left in target buffer</span>
<a name="l02179"></a>02179     <span class="keywordflow">if</span> (treeSize + bufferSize &gt;= <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a>(N))
<a name="l02180"></a>02180     {                                                                                      <span class="comment">// buffer will be filled completely</span>
<a name="l02181"></a>02181         oldTarget = buffer2[j];
<a name="l02182"></a>02182         deleteSize = N - bufferSize;
<a name="l02183"></a>02183     }
<a name="l02184"></a>02184     <span class="keywordflow">else</span>
<a name="l02185"></a>02185     {
<a name="l02186"></a>02186         oldTarget = buffer2[j] + N - treeSize - bufferSize;
<a name="l02187"></a>02187         deleteSize = treeSize;
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190     <span class="keywordflow">if</span> (deleteSize &gt; 0)
<a name="l02191"></a>02191     {
<a name="l02192"></a>02192         <span class="comment">// shift  rest to beginning</span>
<a name="l02193"></a>02193         <span class="comment">// possible hack:</span>
<a name="l02194"></a>02194         <span class="comment">// - use memcpy if no overlap</span>
<a name="l02195"></a>02195         memmove(oldTarget, minBuffer2[j], bufferSize * <span class="keyword">sizeof</span>(value_type));
<a name="l02196"></a>02196         minBuffer2[j] = oldTarget;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198         <span class="comment">// fill remaining space from tree</span>
<a name="l02199"></a>02199         <span class="keywordflow">if</span> (j &lt; IntLevels)
<a name="l02200"></a>02200             itree[j].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#2e3778d4d5ba774fe693a11697c66e70">multi_merge</a>(oldTarget + bufferSize, deleteSize);
<a name="l02201"></a>02201 
<a name="l02202"></a>02202         <span class="keywordflow">else</span>
<a name="l02203"></a>02203         {
<a name="l02204"></a>02204             <span class="comment">//external</span>
<a name="l02205"></a>02205             etree[j - IntLevels].<a class="code" href="classpriority__queue__local_1_1ext__merger.html#9d1e9798b0a312b520b9a9a24c479ae1">multi_merge</a>(oldTarget + bufferSize,
<a name="l02206"></a>02206                                              oldTarget + bufferSize + deleteSize);
<a name="l02207"></a>02207         }
<a name="l02208"></a>02208     }
<a name="l02209"></a>02209 
<a name="l02210"></a>02210 
<a name="l02211"></a>02211     <span class="comment">//STXXL_MSG(deleteSize + bufferSize);</span>
<a name="l02212"></a>02212     <span class="comment">//std::copy(oldTarget,oldTarget + deleteSize + bufferSize,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
<a name="l02213"></a>02213 
<a name="l02214"></a>02214     <span class="keywordflow">return</span> deleteSize + bufferSize;
<a name="l02215"></a>02215 }
<a name="l02216"></a>02216 
<a name="l02217"></a>02217 
<a name="l02218"></a>02218 <span class="comment">// move elements from the 2nd level buffers</span>
<a name="l02219"></a>02219 <span class="comment">// to the buffer</span>
<a name="l02220"></a>02220 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02221"></a>02221 <span class="keywordtype">void</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::refillBuffer1</a>()
<a name="l02222"></a>02222 {
<a name="l02223"></a>02223     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer1()"</span>);
<a name="l02224"></a>02224 
<a name="l02225"></a>02225     <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a> totalSize = 0;
<a name="l02226"></a>02226     unsigned_type sz;
<a name="l02227"></a>02227     <span class="comment">//activeLevels is &lt;= 4</span>
<a name="l02228"></a>02228     <span class="keywordflow">for</span> (int_type i = activeLevels - 1;  i &gt;= 0;  i--)
<a name="l02229"></a>02229     {
<a name="l02230"></a>02230         <span class="keywordflow">if</span> ((buffer2[i] + N) - minBuffer2[i] &lt; BufferSize1)
<a name="l02231"></a>02231         {
<a name="l02232"></a>02232             sz = refillBuffer2(i);
<a name="l02233"></a>02233             <span class="comment">// max active level dry now?</span>
<a name="l02234"></a>02234             <span class="keywordflow">if</span> (sz == 0 &amp;&amp; unsigned_type(i) == activeLevels - 1)
<a name="l02235"></a>02235                 --activeLevels;
<a name="l02236"></a>02236 
<a name="l02237"></a>02237             <span class="keywordflow">else</span>
<a name="l02238"></a>02238                 totalSize += sz;
<a name="l02239"></a>02239         }
<a name="l02240"></a>02240         <span class="keywordflow">else</span>
<a name="l02241"></a>02241         {
<a name="l02242"></a>02242             totalSize += BufferSize1;    <span class="comment">// actually only a sufficient lower bound</span>
<a name="l02243"></a>02243         }
<a name="l02244"></a>02244     }
<a name="l02245"></a>02245 
<a name="l02246"></a>02246     <span class="keywordflow">if</span> (totalSize &gt;= BufferSize1)        <span class="comment">// buffer can be filled completely</span>
<a name="l02247"></a>02247     {
<a name="l02248"></a>02248         minBuffer1 = buffer1;
<a name="l02249"></a>02249         sz = BufferSize1;                <span class="comment">// amount to be copied</span>
<a name="l02250"></a>02250         size_ -= <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a>(BufferSize1); <span class="comment">// amount left in buffer2</span>
<a name="l02251"></a>02251     }
<a name="l02252"></a>02252     <span class="keywordflow">else</span>
<a name="l02253"></a>02253     {
<a name="l02254"></a>02254         minBuffer1 = buffer1 + BufferSize1 - totalSize;
<a name="l02255"></a>02255         sz = totalSize;
<a name="l02256"></a>02256         assert(size_ == <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a>(sz)); <span class="comment">// trees and buffer2 get empty</span>
<a name="l02257"></a>02257         size_ = 0;
<a name="l02258"></a>02258     }
<a name="l02259"></a>02259 
<a name="l02260"></a>02260     <span class="comment">// now call simplified refill routines</span>
<a name="l02261"></a>02261     <span class="comment">// which can make the assumption that</span>
<a name="l02262"></a>02262     <span class="comment">// they find all they are asked to find in the buffers</span>
<a name="l02263"></a>02263     minBuffer1 = buffer1 + BufferSize1 - sz;
<a name="l02264"></a>02264     STXXL_VERBOSE2(<span class="stringliteral">"Active levels = "</span> &lt;&lt; activeLevels);
<a name="l02265"></a>02265     <span class="keywordflow">switch</span> (activeLevels)
<a name="l02266"></a>02266     {
<a name="l02267"></a>02267     <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>;
<a name="l02268"></a>02268     <span class="keywordflow">case</span> 1:
<a name="l02269"></a>02269         std::copy(minBuffer2[0], minBuffer2[0] + sz, minBuffer1);
<a name="l02270"></a>02270         minBuffer2[0] += sz;
<a name="l02271"></a>02271         <span class="keywordflow">break</span>;
<a name="l02272"></a>02272     <span class="keywordflow">case</span> 2:
<a name="l02273"></a>02273         priority_queue_local::merge_iterator(
<a name="l02274"></a>02274             minBuffer2[0],
<a name="l02275"></a>02275             minBuffer2[1], minBuffer1, sz, cmp);
<a name="l02276"></a>02276         <span class="keywordflow">break</span>;
<a name="l02277"></a>02277     <span class="keywordflow">case</span> 3:
<a name="l02278"></a>02278         priority_queue_local::merge3_iterator(
<a name="l02279"></a>02279             minBuffer2[0],
<a name="l02280"></a>02280             minBuffer2[1],
<a name="l02281"></a>02281             minBuffer2[2], minBuffer1, sz, cmp);
<a name="l02282"></a>02282         <span class="keywordflow">break</span>;
<a name="l02283"></a>02283     <span class="keywordflow">case</span> 4:
<a name="l02284"></a>02284         priority_queue_local::merge4_iterator(
<a name="l02285"></a>02285             minBuffer2[0],
<a name="l02286"></a>02286             minBuffer2[1],
<a name="l02287"></a>02287             minBuffer2[2],
<a name="l02288"></a>02288             minBuffer2[3], minBuffer1, sz, cmp); <span class="comment">//side effect free</span>
<a name="l02289"></a>02289         <span class="keywordflow">break</span>;
<a name="l02290"></a>02290     <span class="keywordflow">default</span>:
<a name="l02291"></a>02291         STXXL_THROW(std::runtime_error, <span class="stringliteral">"priority_queue&lt;...&gt;::refillBuffer1()"</span>,
<a name="l02292"></a>02292                     <span class="stringliteral">"Overflow! The number of buffers on 2nd level in stxxl::priority_queue is currently limited to 4"</span>);
<a name="l02293"></a>02293     }
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     <span class="comment">//std::copy(minBuffer1,minBuffer1 + sz,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
<a name="l02296"></a>02296 }
<a name="l02297"></a>02297 
<a name="l02298"></a>02298 <span class="comment">//--------------------------------------------------------------------</span>
<a name="l02299"></a>02299 
<a name="l02300"></a>02300 <span class="comment">// check if space is available on level k and</span>
<a name="l02301"></a>02301 <span class="comment">// empty this level if necessary leading to a recursive call.</span>
<a name="l02302"></a>02302 <span class="comment">// return the level where space was finally available</span>
<a name="l02303"></a>02303 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02304"></a>02304 unsigned_type <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::makeSpaceAvailable</a>(unsigned_type level)
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::makeSpaceAvailable("</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">")"</span>);
<a name="l02307"></a>02307     unsigned_type finalLevel;
<a name="l02308"></a>02308     assert(level &lt; Levels);
<a name="l02309"></a>02309     assert(level &lt;= activeLevels);
<a name="l02310"></a>02310 
<a name="l02311"></a>02311     <span class="keywordflow">if</span> (level == activeLevels)
<a name="l02312"></a>02312         activeLevels++;
<a name="l02313"></a>02313 
<a name="l02314"></a>02314 
<a name="l02315"></a>02315     <span class="keyword">const</span> <span class="keywordtype">bool</span> spaceIsAvailable_ =
<a name="l02316"></a>02316         (level &lt; IntLevels) ? itree[level].spaceIsAvailable()
<a name="l02317"></a>02317         : ((level == Levels - 1) ? <span class="keyword">true</span> : (etree[level - IntLevels].spaceIsAvailable()));
<a name="l02318"></a>02318 
<a name="l02319"></a>02319     <span class="keywordflow">if</span> (spaceIsAvailable_)
<a name="l02320"></a>02320     {
<a name="l02321"></a>02321         finalLevel = level;
<a name="l02322"></a>02322     }
<a name="l02323"></a>02323     <span class="keywordflow">else</span>
<a name="l02324"></a>02324     {
<a name="l02325"></a>02325         finalLevel = makeSpaceAvailable(level + 1);
<a name="l02326"></a>02326 
<a name="l02327"></a>02327         <span class="keywordflow">if</span> (level &lt; IntLevels - 1)                             <span class="comment">// from internal to internal tree</span>
<a name="l02328"></a>02328         {
<a name="l02329"></a>02329             unsigned_type segmentSize = itree[level].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#cf7012aa5a362c3002862de0953c58f4">size</a>();
<a name="l02330"></a>02330             value_type * newSegment = <span class="keyword">new</span> value_type[segmentSize + 1];
<a name="l02331"></a>02331             itree[level].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#2e3778d4d5ba774fe693a11697c66e70">multi_merge</a>(newSegment, segmentSize); <span class="comment">// empty this level</span>
<a name="l02332"></a>02332 
<a name="l02333"></a>02333             newSegment[segmentSize] = buffer1[BufferSize1];    <span class="comment">// sentinel</span>
<a name="l02334"></a>02334             <span class="comment">// for queues where size &lt;&lt; #inserts</span>
<a name="l02335"></a>02335             <span class="comment">// it might make sense to stay in this level if</span>
<a name="l02336"></a>02336             <span class="comment">// segmentSize &lt; alpha * KNN * k^level for some alpha &lt; 1</span>
<a name="l02337"></a>02337             itree[level + 1].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#0080c550f559192c9dfbc1e904be9839">insert_segment</a>(newSegment, segmentSize);
<a name="l02338"></a>02338         }
<a name="l02339"></a>02339         <span class="keywordflow">else</span>
<a name="l02340"></a>02340         {
<a name="l02341"></a>02341             <span class="keywordflow">if</span> (level == IntLevels - 1) <span class="comment">// from internal to external tree</span>
<a name="l02342"></a>02342             {
<a name="l02343"></a>02343                 <span class="keyword">const</span> unsigned_type segmentSize = itree[IntLevels - 1].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#cf7012aa5a362c3002862de0953c58f4">size</a>();
<a name="l02344"></a>02344                 STXXL_VERBOSE1(<span class="stringliteral">"Inserting segment into first level external: "</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; segmentSize);
<a name="l02345"></a>02345                 etree[0].<a class="code" href="classpriority__queue__local_1_1ext__merger.html#5d827a16e474d742752bd15e4d885f09">insert_segment</a>(itree[IntLevels - 1], segmentSize);
<a name="l02346"></a>02346             }
<a name="l02347"></a>02347             <span class="keywordflow">else</span> <span class="comment">// from external to external tree</span>
<a name="l02348"></a>02348             {
<a name="l02349"></a>02349                 <span class="keyword">const</span> <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a> segmentSize = etree[level - IntLevels].<a class="code" href="classpriority__queue__local_1_1ext__merger.html#6b028e0192e2da99c14273ca58b10635">size</a>();
<a name="l02350"></a>02350                 STXXL_VERBOSE1(<span class="stringliteral">"Inserting segment into second level external: "</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; segmentSize);
<a name="l02351"></a>02351                 etree[level - IntLevels + 1].<a class="code" href="classpriority__queue__local_1_1ext__merger.html#5d827a16e474d742752bd15e4d885f09">insert_segment</a>(etree[level - IntLevels], segmentSize);
<a name="l02352"></a>02352             }
<a name="l02353"></a>02353         }
<a name="l02354"></a>02354     }
<a name="l02355"></a>02355     <span class="keywordflow">return</span> finalLevel;
<a name="l02356"></a>02356 }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358 
<a name="l02359"></a>02359 <span class="comment">// empty the insert heap into the main data structure</span>
<a name="l02360"></a>02360 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02361"></a>02361 <span class="keywordtype">void</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;Config_&gt;::emptyInsertHeap</a>()
<a name="l02362"></a>02362 {
<a name="l02363"></a>02363     STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::emptyInsertHeap()"</span>);
<a name="l02364"></a>02364     assert(insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">size</a>() == (N + 1));
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     <span class="keyword">const</span> value_type sup = getSupremum();
<a name="l02367"></a>02367 
<a name="l02368"></a>02368     <span class="comment">// build new segment</span>
<a name="l02369"></a>02369     value_type * newSegment = <span class="keyword">new</span> value_type[N + 1];
<a name="l02370"></a>02370     value_type * newPos = newSegment;
<a name="l02371"></a>02371 
<a name="l02372"></a>02372     <span class="comment">// put the new data there for now</span>
<a name="l02373"></a>02373     <span class="comment">//insertHeap.sortTo(newSegment);</span>
<a name="l02374"></a>02374     value_type * SortTo = newSegment;
<a name="l02375"></a>02375 
<a name="l02376"></a>02376     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#91872f7fcdd79a9f0bbb0fbc5d921b41" title="Sort all contained elements, write result to target.">sort_to</a>(SortTo);
<a name="l02377"></a>02377 
<a name="l02378"></a>02378     SortTo = newSegment + N;
<a name="l02379"></a>02379     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#3d09713e5d6dfdd0356879d875361a49" title="Remove all contained elements.">clear</a>();
<a name="l02380"></a>02380     insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#6a559e9b58f2bab9a2fe6dfbc696ed55" title="Add data to the queue.">push</a>(*SortTo);
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     assert(insertHeap.<a class="code" href="classpriority__queue__local_1_1internal__priority__queue.html#aba8f3ef96c9b58ebd8f28a7eb1efc2d">size</a>() == 1);
<a name="l02383"></a>02383 
<a name="l02384"></a>02384     newSegment[N] = sup; <span class="comment">// sentinel</span>
<a name="l02385"></a>02385 
<a name="l02386"></a>02386     <span class="comment">// copy the buffer1 and buffer2[0] to temporary storage</span>
<a name="l02387"></a>02387     <span class="comment">// (the temporary can be eliminated using some dirty tricks)</span>
<a name="l02388"></a>02388     <span class="keyword">const</span> unsigned_type tempSize = N + BufferSize1;
<a name="l02389"></a>02389     value_type temp[tempSize + 1];
<a name="l02390"></a>02390     unsigned_type sz1 = getSize1();
<a name="l02391"></a>02391     unsigned_type sz2 = getSize2(0);
<a name="l02392"></a>02392     value_type * pos = temp + tempSize - sz1 - sz2;
<a name="l02393"></a>02393     std::copy(minBuffer1, minBuffer1 + sz1, pos);
<a name="l02394"></a>02394     std::copy(minBuffer2[0], minBuffer2[0] + sz2, pos + sz1);
<a name="l02395"></a>02395     temp[tempSize] = sup; <span class="comment">// sentinel</span>
<a name="l02396"></a>02396 
<a name="l02397"></a>02397     <span class="comment">// refill buffer1</span>
<a name="l02398"></a>02398     <span class="comment">// (using more complicated code it could be made somewhat fuller</span>
<a name="l02399"></a>02399     <span class="comment">// in certain circumstances)</span>
<a name="l02400"></a>02400     priority_queue_local::merge_iterator(pos, newPos, minBuffer1, sz1, cmp);
<a name="l02401"></a>02401 
<a name="l02402"></a>02402     <span class="comment">// refill buffer2[0]</span>
<a name="l02403"></a>02403     <span class="comment">// (as above we might want to take the opportunity</span>
<a name="l02404"></a>02404     <span class="comment">// to make buffer2[0] fuller)</span>
<a name="l02405"></a>02405     priority_queue_local::merge_iterator(pos, newPos, minBuffer2[0], sz2, cmp);
<a name="l02406"></a>02406 
<a name="l02407"></a>02407     <span class="comment">// merge the rest to the new segment</span>
<a name="l02408"></a>02408     <span class="comment">// note that merge exactly trips into the footsteps</span>
<a name="l02409"></a>02409     <span class="comment">// of itself</span>
<a name="l02410"></a>02410     priority_queue_local::merge_iterator(pos, newPos, newSegment, N, cmp);
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     <span class="comment">// and insert it</span>
<a name="l02413"></a>02413     unsigned_type freeLevel = makeSpaceAvailable(0);
<a name="l02414"></a>02414     assert(freeLevel == 0 || itree[0].<a class="code" href="group__stlcontinternals.html#gc766dc1bbad05738e36916043c5da27d" title="Returns number of elements contained.">size</a>() == 0);
<a name="l02415"></a>02415     itree[0].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#0080c550f559192c9dfbc1e904be9839">insert_segment</a>(newSegment, N);
<a name="l02416"></a>02416 
<a name="l02417"></a>02417     <span class="comment">// get rid of invalid level 2 buffers</span>
<a name="l02418"></a>02418     <span class="comment">// by inserting them into tree 0 (which is almost empty in this case)</span>
<a name="l02419"></a>02419     <span class="keywordflow">if</span> (freeLevel &gt; 0)
<a name="l02420"></a>02420     {
<a name="l02421"></a>02421         <span class="keywordflow">for</span> (int_type i = freeLevel;  i &gt;= 0;  i--)
<a name="l02422"></a>02422         {
<a name="l02423"></a>02423             <span class="comment">// reverse order not needed</span>
<a name="l02424"></a>02424             <span class="comment">// but would allow immediate refill</span>
<a name="l02425"></a>02425             newSegment = <span class="keyword">new</span> value_type[getSize2(i) + 1]; <span class="comment">// with sentinel</span>
<a name="l02426"></a>02426             std::copy(minBuffer2[i], minBuffer2[i] + getSize2(i) + 1, newSegment);
<a name="l02427"></a>02427             itree[0].<a class="code" href="classpriority__queue__local_1_1loser__tree.html#0080c550f559192c9dfbc1e904be9839">insert_segment</a>(newSegment, getSize2(i));
<a name="l02428"></a>02428             minBuffer2[i] = buffer2[i] + N;               <span class="comment">// empty</span>
<a name="l02429"></a>02429         }
<a name="l02430"></a>02430     }
<a name="l02431"></a>02431 
<a name="l02432"></a>02432     <span class="comment">// update size</span>
<a name="l02433"></a>02433     size_ += <a class="code" href="classpriority__queue.html#fa37045f2773ca4aa4a5ad041a28a1e2" title="An unsigned integral type (64 bit).">size_type</a>(N);
<a name="l02434"></a>02434 
<a name="l02435"></a>02435     <span class="comment">// special case if the tree was empty before</span>
<a name="l02436"></a>02436     <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1)
<a name="l02437"></a>02437         refillBuffer1();
<a name="l02438"></a>02438 }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="keyword">namespace </span>priority_queue_local
<a name="l02441"></a>02441 {
<a name="l02442"></a>02442     <span class="keyword">struct </span>Parameters_for_priority_queue_not_found_Increase_IntM
<a name="l02443"></a>02443     {
<a name="l02444"></a>02444         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02445"></a>02445         <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
<a name="l02446"></a>02446     };
<a name="l02447"></a>02447 
<a name="l02448"></a>02448     <span class="keyword">struct </span>dummy
<a name="l02449"></a>02449     {
<a name="l02450"></a>02450         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02451"></a>02451         <span class="keyword">typedef</span> dummy result;
<a name="l02452"></a>02452     };
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type E_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">unsigned</span>_type B_, <span class="keywordtype">unsigned</span>_type m_, <span class="keywordtype">bool</span> stop = false&gt;
<a name="l02455"></a>02455     <span class="keyword">struct </span>find_B_m
<a name="l02456"></a>02456     {
<a name="l02457"></a>02457         <span class="keyword">typedef</span> find_B_m&lt;E_, IntM_, MaxS_, B_, m_, stop&gt; Self;
<a name="l02458"></a>02458         <span class="keyword">enum</span> {
<a name="l02459"></a>02459             k = IntM_ / B_, <span class="comment">// number of blocks that fit into M</span>
<a name="l02460"></a>02460             E = E_,         <span class="comment">// element size</span>
<a name="l02461"></a>02461             IntM = IntM_,
<a name="l02462"></a>02462             B = B_,         <span class="comment">// block size</span>
<a name="l02463"></a>02463             m = m_,         <span class="comment">// number of blocks fitting into buffers</span>
<a name="l02464"></a>02464             c = k - m_,
<a name="l02465"></a>02465             <span class="comment">// memory occ. by block must be at least 10 times larger than size of ext sequence</span>
<a name="l02466"></a>02466             <span class="comment">// &amp;&amp; satisfy memory req &amp;&amp; if we have two ext mergers their degree must be at least 64=m/2</span>
<a name="l02467"></a>02467             fits = c &gt; 10 &amp;&amp; ((k - m) * (m) * (m * B / (E * 4 * 1024))) &gt;= MaxS_ &amp;&amp; (MaxS_ &lt; ((k - m) * m / (2 * E)) * 1024 || m &gt;= 128),
<a name="l02468"></a>02468             step = 1
<a name="l02469"></a>02469         };
<a name="l02470"></a>02470 
<a name="l02471"></a>02471         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E, IntM, MaxS_, B, m + step, fits || (m &gt;= k - step)&gt;::result candidate1;
<a name="l02472"></a>02472         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E, IntM, MaxS_, B / 2, 1, fits || candidate1::fits&gt;::result candidate2;
<a name="l02473"></a>02473         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structIF.html" title="IF template metaprogramming statement.">IF&lt;fits, Self, typename IF&lt;candidate1::fits, candidate1, candidate2&gt;::result</a>&gt;::result result;
<a name="l02474"></a>02474     };
<a name="l02475"></a>02475 
<a name="l02476"></a>02476     <span class="comment">// specialization for the case when no valid parameters are found</span>
<a name="l02477"></a>02477     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type E_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">bool</span> stop&gt;
<a name="l02478"></a>02478     <span class="keyword">struct </span>find_B_m&lt;E_, IntM_, MaxS_, 2048, 1, stop&gt;
<a name="l02479"></a>02479     {
<a name="l02480"></a>02480         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02481"></a>02481         <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
<a name="l02482"></a>02482     };
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     <span class="comment">// to speedup search</span>
<a name="l02485"></a>02485     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type E_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_, <span class="keywordtype">unsigned</span>_type B_, <span class="keywordtype">unsigned</span>_type m_&gt;
<a name="l02486"></a>02486     <span class="keyword">struct </span>find_B_m&lt;E_, IntM_, MaxS_, B_, m_, true&gt;
<a name="l02487"></a>02487     {
<a name="l02488"></a>02488         <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
<a name="l02489"></a>02489         <span class="keyword">typedef</span> dummy result;
<a name="l02490"></a>02490     };
<a name="l02491"></a>02491 
<a name="l02492"></a>02492     <span class="comment">// E_ size of element in bytes</span>
<a name="l02493"></a>02493     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type E_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span>_type MaxS_&gt;
<a name="l02494"></a>02494     <span class="keyword">struct </span>find_settings
<a name="l02495"></a>02495     {
<a name="l02496"></a>02496         <span class="comment">// start from block size (8*1024*1024) bytes</span>
<a name="l02497"></a>02497         <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E_, IntM_, MaxS_, (8 * 1024 * 1024), 1&gt;::result result;
<a name="l02498"></a>02498     };
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="keyword">struct </span>Parameters_not_found_Try_to_change_the_Tune_parameter
<a name="l02501"></a>02501     {
<a name="l02502"></a>02502         <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_the_Tune_parameter result;
<a name="l02503"></a>02503     };
<a name="l02504"></a>02504 
<a name="l02505"></a>02505 
<a name="l02506"></a>02506     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type AI_, <span class="keywordtype">unsigned</span>_type X_, <span class="keywordtype">unsigned</span>_type CriticalSize_&gt;
<a name="l02507"></a>02507     <span class="keyword">struct </span>compute_N
<a name="l02508"></a>02508     {
<a name="l02509"></a>02509         <span class="keyword">typedef</span> compute_N&lt;AI_, X_, CriticalSize_&gt; Self;
<a name="l02510"></a>02510         <span class="keyword">enum</span>
<a name="l02511"></a>02511         {
<a name="l02512"></a>02512             X = X_,
<a name="l02513"></a>02513             AI = AI_,
<a name="l02514"></a>02514             N = X / (AI * AI) <span class="comment">// two stage internal</span>
<a name="l02515"></a>02515         };
<a name="l02516"></a>02516         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structIF.html" title="IF template metaprogramming statement.">IF&lt;(N &gt;</a>= CriticalSize_), Self, <span class="keyword">typename</span> compute_N&lt;AI / 2, X, CriticalSize_&gt;::result&gt;::result result;
<a name="l02517"></a>02517     };
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>_type X_, <span class="keywordtype">unsigned</span>_type CriticalSize_&gt;
<a name="l02520"></a>02520     <span class="keyword">struct </span>compute_N&lt;1, X_, CriticalSize_&gt;
<a name="l02521"></a>02521     {
<a name="l02522"></a>02522         <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_the_Tune_parameter result;
<a name="l02523"></a>02523     };
<a name="l02524"></a>02524 }
<a name="l02525"></a>02525 
<a name="l02527"></a>02527 
<a name="l02530"></a>02530 
<a name="l02532"></a>02532 
<a name="l02596"></a>02596 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span>_type IntM_, <span class="keywordtype">unsigned</span> MaxS_, <span class="keywordtype">unsigned</span> Tune_ = 6&gt;
<a name="l02597"></a><a class="code" href="classPRIORITY__QUEUE__GENERATOR.html">02597</a> <span class="keyword">class </span><a class="code" href="classPRIORITY__QUEUE__GENERATOR.html" title="Priority queue type generator.">PRIORITY_QUEUE_GENERATOR</a>
<a name="l02598"></a>02598 {
<a name="l02599"></a>02599 <span class="keyword">public</span>:
<a name="l02600"></a>02600     <span class="comment">// actual calculation of B, m, k and E</span>
<a name="l02601"></a>02601     <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::find_settings&lt;sizeof(Tp_), IntM_, MaxS_&gt;::result settings;
<a name="l02602"></a>02602     <span class="keyword">enum</span> {
<a name="l02603"></a>02603         B = settings::B,
<a name="l02604"></a>02604         m = settings::m,
<a name="l02605"></a>02605         X = B * (settings::k - m) / settings::E,  <span class="comment">// interpretation of result</span>
<a name="l02606"></a>02606         Buffer1Size = 32                          <span class="comment">// fixed</span>
<a name="l02607"></a>02607     };
<a name="l02608"></a>02608     <span class="comment">// derivation of N, AI, AE</span>
<a name="l02609"></a>02609     <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::compute_N&lt;(1 &lt;&lt; Tune_), X, 4 * Buffer1Size&gt;::result ComputeN;
<a name="l02610"></a>02610     <span class="keyword">enum</span>
<a name="l02611"></a>02611     {
<a name="l02612"></a>02612         N = ComputeN::N,
<a name="l02613"></a>02613         AI = ComputeN::AI,
<a name="l02614"></a>02614         AE = (m / 2 &lt; 2) ? 2 : (m / 2)            <span class="comment">// at least 2</span>
<a name="l02615"></a>02615     };
<a name="l02616"></a>02616     <span class="keyword">enum</span> {
<a name="l02617"></a>02617         <span class="comment">// Estimation of maximum internal memory consumption (in bytes)</span>
<a name="l02618"></a>02618         EConsumption = X * settings::E + settings::B * AE + ((MaxS_ / X) / AE) * settings::B * 1024
<a name="l02619"></a>02619     };
<a name="l02620"></a>02620     <span class="comment">/*</span>
<a name="l02621"></a>02621 <span class="comment">        unsigned BufferSize1_ = 32, // equalize procedure call overheads etc.</span>
<a name="l02622"></a>02622 <span class="comment">        unsigned N_ = 512,          // bandwidth</span>
<a name="l02623"></a>02623 <span class="comment">        unsigned IntKMAX_ = 64,     // maximal arity for internal mergers</span>
<a name="l02624"></a>02624 <span class="comment">        unsigned IntLevels_ = 4,</span>
<a name="l02625"></a>02625 <span class="comment">        unsigned BlockSize_ = (2*1024*1024),</span>
<a name="l02626"></a>02626 <span class="comment">        unsigned ExtKMAX_ = 64,     // maximal arity for external mergers</span>
<a name="l02627"></a>02627 <span class="comment">        unsigned ExtLevels_ = 2,</span>
<a name="l02628"></a>02628 <span class="comment">     */</span>
<a name="l02629"></a>02629     <span class="keyword">typedef</span> <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">priority_queue&lt;priority_queue_config&lt;Tp_, Cmp_, Buffer1Size, N, AI, 2, B, AE, 2&gt;</a> &gt; <a class="code" href="classpriority__queue.html" title="External priority queue data structure.">result</a>;
<a name="l02630"></a>02630 };
<a name="l02631"></a>02631 
<a name="l02633"></a>02633 
<a name="l02634"></a>02634 __STXXL_END_NAMESPACE
<a name="l02635"></a>02635 
<a name="l02636"></a>02636 
<a name="l02637"></a>02637 <span class="keyword">namespace </span>std
<a name="l02638"></a>02638 {
<a name="l02639"></a>02639     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l02640"></a>02640     <span class="keywordtype">void</span> swap(stxxl::priority_queue&lt;Config_&gt; &amp; a,
<a name="l02641"></a>02641               stxxl::priority_queue&lt;Config_&gt; &amp; b)
<a name="l02642"></a>02642     {
<a name="l02643"></a>02643         a.swap(b);
<a name="l02644"></a>02644     }
<a name="l02645"></a>02645 }
<a name="l02646"></a>02646 
<a name="l02647"></a>02647 <span class="preprocessor">#endif // !STXXL_PRIORITY_QUEUE_HEADER</span>
<a name="l02648"></a>02648 <span class="preprocessor"></span><span class="comment">// vim: et:ts=4:sw=4</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 21 06:45:40 2010 for Stxxl by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
