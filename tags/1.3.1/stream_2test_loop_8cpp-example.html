<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Stxxl: stream/test_loop.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>stream/test_loop.cpp</h1>  </div>
</div>
<div class="contents">
<p>This is an example of how to use some basic algorithms from the stream package to form a loop iterating over the data. Some input is generated, sorted, some elements are filtered out. The remaining elements are transformed, sorted and processed in the next pass. The loop will terminate if at most one element remains. A split sorter is used to cut the data flow (and type dependency) cycle.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/***************************************************************************</span>
<span class="comment"> *  stream/test_loop.cpp</span>
<span class="comment"> *</span>
<span class="comment"> *  example for building a loop of stream operations</span>
<span class="comment"> *</span>
<span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright © 2011 Jaroslaw Fedorowicz &lt;fedorow@cs.uni-frankfurt.de&gt;</span>
<span class="comment"> *  Copyright © 2011 Andreas Beckmann &lt;beckmann@cs.uni-frankfurt.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="comment"> **************************************************************************/</span>


<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;limits&gt;</span>

<span class="preprocessor">#include &lt;stxxl/mng&gt;</span>
<span class="preprocessor">#include &lt;stxxl/vector&gt;</span>
<span class="preprocessor">#include &lt;stxxl/stream&gt;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::endl;

<span class="keyword">const</span> stxxl::uint64 memory_to_use = 3ul * 1024 * 1024 * 1024;

<span class="keywordtype">bool</span> verbose;

<span class="keyword">struct </span>random_generator
{
    <span class="keyword">typedef</span> stxxl::random_number32::value_type value_type;
    <span class="keyword">typedef</span> stxxl::uint64 size_type;
    value_type current;
    size_type count;
    stxxl::random_number32 rnd;

    random_generator(size_type _count) : count(_count)
    {
        <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Random Stream: &quot;</span>;
        current = rnd();
    }

    value_type operator * ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> current;
    }
    random_generator &amp; operator ++ ()
    {
        count--;
        <span class="keywordflow">if</span> (verbose) {
            cout &lt;&lt; current &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
            <span class="keywordflow">if</span> (empty()) cout &lt;&lt; endl;
        }
        current = rnd();
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> (count == 0);
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> value_type&gt;
<span class="keyword">struct </span>Cmp : std::binary_function&lt;value_type, value_type, bool&gt;
{
    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type &amp; a, <span class="keyword">const</span> value_type &amp; b)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> a &lt; b;
    }
    <span class="keyword">static</span> value_type min_value()
    {
        <span class="keywordflow">return</span> value_type((std::numeric_limits&lt;value_type&gt;::min)());
    }
    <span class="keyword">static</span> value_type max_value()
    {
        <span class="keywordflow">return</span> value_type((std::numeric_limits&lt;value_type&gt;::max)());
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;
<span class="keyword">struct </span>filter
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type value_type;
    <span class="keyword">typedef</span> stxxl::uint64 size_type;
    Input &amp; input;
    value_type filter_value;
    size_type &amp; counter;

    <span class="keywordtype">void</span> apply_filter()
    {
        <span class="keywordflow">while</span> (!input.empty() &amp;&amp; *input == filter_value) {
            ++input;
            counter++;
        }
    }

    filter(Input &amp; _input, value_type _filter_value, size_type &amp; _counter) : input(_input), filter_value(_filter_value), counter(_counter)
    {
        apply_filter();
    }

    <span class="keyword">const</span> value_type operator * ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> *input;
    }

    filter &amp; operator ++ ()
    {
        ++input;
        apply_filter();
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> input.empty();
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;
<span class="keyword">struct </span>output
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type value_type;
    Input &amp; input;

    output(Input &amp; _input) : input(_input) { }

    <span class="keyword">const</span> value_type operator * ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> *input;
    }

    output &amp; operator ++ ()
    {
        <span class="keywordflow">if</span> (verbose) cout &lt;&lt; *input &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
        ++input;
        <span class="keywordflow">if</span> (empty() &amp;&amp; verbose)
            cout &lt;&lt; endl;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> input.empty();
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input&gt;
<span class="keyword">struct </span>shuffle
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type value_type;
    Input &amp; input;
    value_type current, next;
    <span class="keywordtype">bool</span> even, is_empty;

    <span class="comment">// from http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan</span>
    <span class="keywordtype">int</span> count_bits(stxxl::uint64 v)
    {
        <span class="keywordtype">int</span> c;
        <span class="keywordflow">for</span> (c = 0; v; c++) {
            v &amp;= v - 1;
        }
        <span class="keywordflow">return</span> c;
    }

    <span class="keywordtype">void</span> apply_shuffle()
    {
        is_empty = input.empty();
        <span class="keywordflow">if</span> (!is_empty) {
            current = *input;
            ++input;
            <span class="keywordflow">if</span> (!input.empty()) {
                STXXL_STATIC_ASSERT(<span class="keyword">sizeof</span>(value_type) == 4);
                stxxl::uint64 combined = current;
                combined = combined &lt;&lt; 32 | *input;
                combined = (1ul &lt;&lt; count_bits(combined)) - 1;
                current = combined &gt;&gt; 32;
                next = combined;
            }
        }
    }

    shuffle(Input &amp; _input) : input(_input), current(0), next(0), even(true), is_empty(false)
    {
        apply_shuffle();
    }

    value_type operator * ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> current;
    }

    shuffle &amp; operator ++ ()
    {
        even = !even;
        is_empty = input.empty();
        <span class="keywordflow">if</span> (even) {
            ++input;
            apply_shuffle();
        } <span class="keywordflow">else</span> {
            current = next;
        }
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> is_empty;
    }
};

<span class="keyword">typedef</span> random_generator input_generator_type;
<span class="keyword">typedef</span> Cmp&lt;input_generator_type::value_type&gt; cmp;
<span class="keyword">typedef</span> stxxl::stream::runs_creator&lt;input_generator_type, cmp&gt; runs_creator_type0;
<span class="keyword">typedef</span> runs_creator_type0::sorted_runs_type sorted_runs_type;
<span class="keyword">typedef</span> stxxl::stream::runs_merger&lt;sorted_runs_type, cmp&gt; runs_merger_type;
<span class="keyword">typedef</span> output&lt;runs_merger_type&gt; output_type;
<span class="keyword">typedef</span> filter&lt;output_type&gt; filter_type0;
<span class="keyword">typedef</span> filter&lt;filter_type0&gt; filter_type1;
<span class="keyword">typedef</span> shuffle&lt;filter_type1&gt; shuffle_type;
<span class="keyword">typedef</span> stxxl::stream::runs_creator&lt;shuffle_type, cmp&gt; runs_creator_type1;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)
{
    <span class="keywordflow">if</span> (argc &lt; 2) {
        cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; count [Options]\nOptions: -v \t prints elements of each iteration\n&quot;</span>;
        <span class="keywordflow">return</span> EXIT_FAILURE;
    }

    stxxl::block_manager::get_instance();

    verbose = (argc == 3) &amp;&amp; !strcmp(argv[2], <span class="stringliteral">&quot;-v&quot;</span>);

    stxxl::uint64 total = atoi(argv[1]);

    input_generator_type input_stream(total);

    runs_creator_type0 runs_creator(input_stream, cmp(), memory_to_use);

    sorted_runs_type sorted_runs = runs_creator.result();

    stxxl::uint64 counter = 0;
    <span class="keywordtype">int</span> i;

    <span class="keywordflow">for</span> (i = 0; counter &lt; total - 1; ++i) {
        <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;

        runs_merger_type runs_merger(sorted_runs, cmp(), memory_to_use);

        output_type output_stream(runs_merger);

        filter_type0 filter0(output_stream, 0, counter);

        filter_type1 filter1(filter0, filter_type1::value_type(-1), counter);

        shuffle_type shuffled_stream(filter1);

        runs_creator_type1 runs_creator(shuffled_stream, cmp(), memory_to_use);

        sorted_runs = runs_creator.result();
    }

    runs_merger_type runs_merger(sorted_runs, cmp(), memory_to_use);

    <span class="keywordflow">while</span> (!runs_merger.empty()) {
        <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Iteration &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; *runs_merger &lt;&lt; endl;
        ++runs_merger;
    }
    cout &lt;&lt; <span class="stringliteral">&quot;\nIteration needed: &quot;</span> &lt;&lt; i &lt;&lt; endl;
}

<span class="comment">// vim: et:ts=4:sw=4</span>
</pre></div> </div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
